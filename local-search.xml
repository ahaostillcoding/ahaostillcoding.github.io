<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>常用软件推荐</title>
    <link href="/2024/01/14/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/"/>
    <url>/2024/01/14/%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    
    <content type="html"><![CDATA[<h2 id="Everthing"><a href="#Everthing" class="headerlink" title="Everthing"></a>Everthing</h2><blockquote><p>下载地址： <a href="https://www.voidtools.com/zh-cn/downloads/">下载 - voidtools</a></p></blockquote><p>​    Windows资源管理器自带的文件搜索功能用过的都知道有多慢了。Windows的文件搜索是逐一扫描硬盘上的文件，而Everything是对硬盘上所有文件建立了一个索引，根据输入文件名来进行匹配搜索。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/%E8%87%AA%E5%B8%A6%E6%90%9C%E7%B4%A2.gif" alt="自带搜索"></p><p>可以看到Everything基本搜索都是秒出的，你也可以看教程实现高级搜索(根据文件类型、正则表达式搜索等)</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/everything%E5%AF%B9%E6%AF%94.gif" alt="everything对比"></p><hr><p>除了Everything之外，我有时候还会用到AnyTXT Searcher。Everything只能根据文件名进行搜索，而AnyTXT Searcher可以根据文件中内容进行搜索，对一些不记得名字的文档进行搜索还是很有用的。</p><h2 id="Listary"><a href="#Listary" class="headerlink" title="Listary"></a>Listary</h2><blockquote><p>下载地址： <a href="https://www.listary.com/">Listary – Free File Search Tool &amp; App Launcher</a></p></blockquote><p>​    有了它就不用把那么多软件快捷方式放在桌面啦</p><p>​    类似于uTools、quicker的快速启动软件。但是Listary用于启动软件更加纯粹简单，我往往用它搭配Everything使用。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119220100087.png" alt="image-20240119220100087"></p><h2 id="Fences"><a href="#Fences" class="headerlink" title="Fences"></a>Fences</h2><blockquote><p>下载地址： <a href="https://www.ittel.cn/archives/10705.html">Stardock Fences v4.21中文破解版 | 桌面图标分类工具 (ittel.cn)</a></p></blockquote><p>​    桌面整理软件，可以自定义建立格子管理桌面<img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/fences.gif" alt="fences"></p><h2 id="ManicTime"><a href="#ManicTime" class="headerlink" title="ManicTime"></a>ManicTime</h2><blockquote><p>下载地址： <a href="https://www.manictime.com/Download/">Download Windows Client - ManicTime</a></p></blockquote><p>​    记录电脑各软件使用时间</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240114173052471.png" alt="image-20240114173052471"></p><h2 id="geek"><a href="#geek" class="headerlink" title="geek"></a>geek</h2><blockquote><p>下载地址： <a href="https://geekuninstaller.com/">Geek Uninstaller - the best FREE uninstaller</a></p></blockquote><p>​    干净卸载软件。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119222510340.png" alt="image-20240119222510340"></p><h2 id="WizTree"><a href="#WizTree" class="headerlink" title="WizTree"></a>WizTree</h2><blockquote><p>下载地址： <a href="https://www.diskanalyzer.com/">WizTree - The Fastest Disk Space Analyzer (diskanalyzer.com)</a></p></blockquote><p>​    扫描查看磁盘中各文件的大小占用情况。我常用于文件清理</p><p>​    <img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119222634875.png" alt="image-20240119222634875"></p><h2 id="Windhawk"><a href="#Windhawk" class="headerlink" title="Windhawk"></a>Windhawk</h2><blockquote><p>下载地址：<a href="https://windhawk.net/">Windhawk</a></p></blockquote><p>​    各种好用插件的集合。我常用的就是图中几个，你可以在它商城中添加更多的mod。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/1705676107436.png" alt="1705676107436"></p><h2 id="PixPin-Snipaste"><a href="#PixPin-Snipaste" class="headerlink" title="PixPin/Snipaste"></a>PixPin/Snipaste</h2><blockquote><p>下载地址： <a href="https://pixpinapp.com/start/quick-start">开始使用PixPin | PixPin 截图/贴图/长截图/文字识别/标注 (pixpinapp.com)</a></p></blockquote><p>​    别再用你那手机摄像头怼着电脑拍了。</p><p>​    PixPin我是最近才开始使用的，之前一直用的是Snipaste。但是Snipaste这么多年了，功能一直只有那些。PixPin作为新软件一直在持续更新，我从11月开始1.1版本现在已经升级到1.5了，升级还是很快的，也一直在完善功能。</p><p>​    PixPin的功能会比Snipaste更多，比如长截图、录制Gif。基础的绘制图片，切图这些两者都是有的。但是相对来说Snipaste的相应速度更快，在PixPin早些版本中bug是真的多，相应也很忙，我一开始用了几天就受不了换回了Snipaste，但是在后面慢慢更新后相应速度变快了，bug也更新修正了很多，潜力很大</p><h2 id="Finalshell-Xshell"><a href="#Finalshell-Xshell" class="headerlink" title="Finalshell/Xshell"></a>Finalshell/Xshell</h2><blockquote><p>下载地址： <a href="https://www.finalshell.org/">FinalShell SSH工具,服务器管理,远程桌面加速软件,支持Windows,macOS,Linux - FinalShell官网</a></p></blockquote><p>​    同为SSH工具，我更多用的是Finalshell，Finalshell相较于Xshell来说了，多了Ftp功能和更加直观的文件管理。不过Finalshell最大的缺陷就是<strong>占用高</strong>，内置打开大文件时有崩溃的几率。Xshell则更为纯粹简洁</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119225238392.png" alt="image-20240119225238392"></p><h2 id="notepad–"><a href="#notepad–" class="headerlink" title="notepad–"></a>notepad–</h2><blockquote><p>下载地址： <a href="https://gitee.com/cxasm/notepad--">ndd: notepad–是一个国产跨平台、轻量级的文本编辑器，是替换notepad++的一种选择。其内置强大的代码对比功能，让你丢掉付费的beyond compare。 (gitee.com)</a></p></blockquote><p>好用的文本编辑器(至少比记事本好用)，支持语法高亮。</p><p>​    因为<strong>Notepad</strong>的辱华问题，而使用的代替品</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119231045328.png" alt="image-20240119231045328"></p><h2 id="催化剂加-CatalystPlus"><a href="#催化剂加-CatalystPlus" class="headerlink" title="催化剂加 CatalystPlus"></a>催化剂加 CatalystPlus</h2><blockquote><p>下载地址： <a href="https://cosmos.catalystplus.cn/">催化剂加 CatalystPlus</a></p></blockquote><p>​    查阅各种期刊文献很方便，UI也很漂亮</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240119231714652.png" alt="image-20240119231714652"></p><h2 id="Typora"><a href="#Typora" class="headerlink" title="Typora"></a>Typora</h2><p>​    不用多说，我自认为最简单纯粹的markdown工具，比什么notion,Obsidian更加专注于码字。本篇推荐就是用Typora写的了。</p><h2 id="Bandizip"><a href="#Bandizip" class="headerlink" title="Bandizip"></a>Bandizip</h2><blockquote><p>下载地址： <a href="https://www.bandisoft.com/bandizip/">Windows 版本的 Bandizip · 业内领先的压缩文件解决方案 (bandisoft.com)</a></p></blockquote><p>好用的解压软件，没有广告，支持多种压缩格式，别再傻傻的直接打开压缩文件用了。</p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第六章应用层</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%85%AD%E7%AB%A0%E5%BA%94%E7%94%A8%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><blockquote><p>DNS协议采用的UDP协议封装</p></blockquote><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>​    把域名转换成IP地址</p><p>​    DNS被设计成为一个联机分布式数据库系统，并采用客户服务器方式。DNS使大多数名字都在本地进行解析(通过保存在本地的host文件)，只有少量解析需要再互联网上通信</p><h3 id="域名结构"><a href="#域名结构" class="headerlink" title="域名结构"></a>域名结构</h3><blockquote><p>层次树状结构的域名结构</p></blockquote><p>1.国家顶级域名nTLD</p><ul><li>cn:中国</li><li>us:美国</li></ul><p>2.通用顶级域名gTLD</p><ul><li>com：公司企业</li><li>net：网络服务机构</li><li>org：非营利性机构</li><li>edu</li><li>gov</li><li>mil</li><li>int</li></ul><p>3.基础结构域名(反向域名)</p><ul><li>arpa:用于反向域名解析</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110105939210.png" alt="image-20240110105939210"></p><p><strong>域名空间</strong></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110110216537.png" alt="image-20240110110216537"></p><h3 id="域名服务器"><a href="#域名服务器" class="headerlink" title="域名服务器"></a>域名服务器</h3><h4 id="1-根域名服务器"><a href="#1-根域名服务器" class="headerlink" title="1.根域名服务器"></a>1.根域名服务器</h4><p>​    最高层次的域名服务器，每个<strong>根域名服务器都知道所有顶级域名服务器及其IP地址</strong>。</p><p>​    <strong>根域名服务器通常不直接进行对域名的解析，而是返回对该域名所在顶级域名的顶级域名服务器的IP地址</strong></p><ul><li>共有13个不同IP地址的根域名服务器</li><li>根域名服务器是最重要的域名服务器</li><li>每个域名的根域名服务器都由许多分布在全球各地的计算机构成服务器集群</li></ul><h4 id="2-顶级域名服务器"><a href="#2-顶级域名服务器" class="headerlink" title="2.顶级域名服务器"></a>2.顶级域名服务器</h4><p>​    负责管理在该顶级域名服务器注册的所有二级域名。</p><p>​    收到DNS查询就给出对于回答(最后的结果，或者是下一级权限域名服务器的IP地址)</p><h4 id="3-权限域名服务器"><a href="#3-权限域名服务器" class="headerlink" title="3.权限域名服务器"></a>3.权限域名服务器</h4><p>​    负责管理某个区的域名。<strong>每一个主机的域名都必须在某个权限域名服务器处注册登记</strong></p><ul><li>权限域名服务器还知道其下级域名服务器的地址</li></ul><h4 id="4-本地域名服务器"><a href="#4-本地域名服务器" class="headerlink" title="4.本地域名服务器"></a>4.本地域名服务器</h4><p>​    不属于域名服务器层次结构    </p><p>​    当发送DNS请求时，首先被送往本地域名服务器</p><ul><li><strong>本地域名服务器起代理作用</strong>，会将该报文转发到上述的域名服务器的等级结构中</li></ul><h3 id="域名解析过程"><a href="#域名解析过程" class="headerlink" title="域名解析过程"></a>域名解析过程</h3><h4 id="1-递归查询"><a href="#1-递归查询" class="headerlink" title="1.递归查询"></a>1.递归查询</h4><p>​    一般采用递归查询</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110111241110.png" alt="image-20240110111241110"></p><h4 id="2-迭代查询"><a href="#2-迭代查询" class="headerlink" title="2.迭代查询"></a>2.迭代查询</h4><p>​    迭代查询对域名服务器的负担大</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110111331718.png" alt="image-20240110111331718"></p><h4 id="高速缓存"><a href="#高速缓存" class="headerlink" title="高速缓存"></a>高速缓存</h4><p>​    如果在不久前用户查询过域名的IP地址，本地域名服务器不必再像根域名服务器重新查询。而是直接返回高速缓存中查询结果。</p><p>​    为保证高速缓存中内容正确，域名服务器为每项内容设置了<strong>计时器并删除超过合理时间的项</strong></p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第五章运输层</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%94%E7%AB%A0%E8%BF%90%E8%BE%93%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109200748597.png" alt="image-20240109200748597"></p><h2 id="一。运输层协议概述"><a href="#一。运输层协议概述" class="headerlink" title="一。运输层协议概述"></a>一。运输层协议概述</h2><blockquote><p><strong>运输层</strong>提供<strong>应用程序间</strong>的逻辑通信</p><p>运输层还要对收到的报文进行<strong>差错检测</strong></p><p><strong>网络层</strong>为<strong>主机之间</strong>的通信提供服务</p></blockquote><p>​    从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p>​    物理层、数据链路层、网络层共同解决了将主机通过异构网络互联起来所面临的问题，实现了主机到主机的通信</p><p>​    但实际在网络中进行通信的真正实体是<strong>位于通信两端主机中的进程</strong></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109202823853.png" alt="image-20240109202823853"></p><p>​    <strong>为运行在不同主机上的应用程序提供直接的通信服务</strong>是运输层的任务，运输层协议又称端到端协议</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><blockquote><p>端口号只有本地意义，端口号只是为了<strong>标识本计算机应用层中的各进程</strong></p><p>不同计算机的相同端口号没有联系</p></blockquote><p>​    范围： 0 ~ 65535</p><p><strong>熟知端口号</strong>： 1 ~ 1023</p><table><thead><tr><th align="center">应用</th><th align="center">FTP</th><th align="center">SSH</th><th align="center">TELNET</th><th align="center">SMTP</th><th align="center">DNS</th><th align="center">HTTP</th><th align="center">HTTPS</th></tr></thead><tbody><tr><td align="center">熟知端口号</td><td align="center">21</td><td align="center">22</td><td align="center">23</td><td align="center">25</td><td align="center">53</td><td align="center">80</td><td align="center">443</td></tr></tbody></table><p><strong>登记端口号：</strong> 1024 ~ 49151</p><p><strong>客户端使用的端口号</strong>：</p><ul><li>留给客户进程暂时使用(短暂端口号)</li><li>49152 ~ 65535</li></ul><p>​    </p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109205608583.png" alt="image-20240109205608583"></p><h3 id="发送方复用和接收方分用"><a href="#发送方复用和接收方分用" class="headerlink" title="发送方复用和接收方分用"></a>发送方复用和接收方分用</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109205157574.png" alt="image-20240109205157574"></p><p><strong>复用：</strong> 应用层所有的<strong>应用程序</strong>都可以<strong>通过运输层再传送到IP层</strong>(网络层)</p><p><strong>分用:</strong>    运输层从IP层收到发给各应用程序的数据后，<strong>必须分别交付指明的各应用程序</strong>(根据端口)</p><h2 id="二。用户数据报协议UDP"><a href="#二。用户数据报协议UDP" class="headerlink" title="二。用户数据报协议UDP"></a>二。用户数据报协议UDP</h2><h3 id="1-UDP概述"><a href="#1-UDP概述" class="headerlink" title="1.UDP概述"></a>1.UDP概述</h3><blockquote><p>UDP是只在IP的数据报服务之上增加很少的功能(<strong>复用分用</strong>功能和<strong>差错检测</strong>功能)</p></blockquote><h4 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h4><blockquote><p><strong>简单方便，但不可靠</strong></p></blockquote><ol><li>UDP是<strong>无连接</strong>的</li><li>UDP使用尽最大努力交付。不保证可靠交付。主机不需要维持复杂的连接状态表</li><li>UDP<strong>是面向报文的</strong>。</li></ol><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109212641036.png" alt="image-20240109212641036"></p><p>UDP一次交付一个完整的报文。</p><ul><li>若报文太长，UDP交给IP层后，IP层可能需要分片，降低效率</li><li>若报文太短，UDP交给IP层后，会使IP数据报的首部的相对长度太大，降低了IP层的效率</li></ul><ol start="4"><li><p>UDP没有拥塞控制</p></li><li><p>UDP支持一对一，一对多，多对一和多对多的交互通信</p></li><li><p>UDP的首部开销小，<strong>只有8个字节</strong>(TCP有20个字节)</p></li></ol><h4 id="UDP的首部格式"><a href="#UDP的首部格式" class="headerlink" title="UDP的首部格式"></a>UDP的首部格式</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109213135789.png" alt="image-20240109213135789"></p><ol><li><p>源端口： 源端口号。在需要对方回信时选用。不需要时可全为0</p></li><li><p>目的端口：目的端口号。终点交付报文时必须使用</p></li><li><p>长度： UDP用户数据报的长度，<strong>最小值为8(只有首部)</strong></p><p>​    IP数据报首部长度固定为20字节</p><p>​    数据长度 = 长度 - 首部长度 </p></li><li><p>检验和： 检验UDP用户数据报在传输中是否有错，有错丢弃</p></li></ol><p>UDP计算检验和的方法和计算IP数据报首部检验的方法相似</p><ul><li>IP数据报的检验和值检验IP数据报的首部</li><li>UDP的检验和是把<strong>首部和数据部分一起检验</strong>(TCP也一样)</li></ul><h2 id="三。传输控制协议TCP"><a href="#三。传输控制协议TCP" class="headerlink" title="三。传输控制协议TCP"></a>三。传输控制协议TCP</h2><h3 id="主要特点-1"><a href="#主要特点-1" class="headerlink" title="主要特点"></a>主要特点</h3><ol><li><p>TCP是<strong>面向连接</strong>的运输层协议</p></li><li><p>每一条TCP连接只能有两个端点，每一条TCP连接都是<strong>点对点</strong>的</p></li><li><p>TCP提供<strong>可靠交付</strong>的服务。无差错、不丢失、不重复，按序到达</p></li><li><p>TCP提供<strong>全双工</strong>通信</p></li><li><p>面向字节流</p></li></ol><h3 id="star-首部格式"><a href="#star-首部格式" class="headerlink" title=":star:首部格式"></a>:star:首部格式</h3><blockquote><p>TCP虽然面向字节流，但TCP传送的数据单元却是报文段</p></blockquote><p>TCP报文段分为<strong>首部</strong>和<strong>数据</strong>两部分</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109222115781.png" alt="image-20240109222115781"></p><h4 id="1-源端口和目的端口"><a href="#1-源端口和目的端口" class="headerlink" title="1.源端口和目的端口"></a>1.源端口和目的端口</h4><p>​    各占两个字节</p><h4 id="2-序号"><a href="#2-序号" class="headerlink" title="2.序号"></a>2.序号</h4><p>​    范围 0 ， 2^32-1。TCP连接中传送的字节流中的每一个字节都按顺序编号</p><h4 id="3-确认号-ack"><a href="#3-确认号-ack" class="headerlink" title="3.确认号(ack)"></a>3.确认号(ack)</h4><p>​    占4字节</p><p>​    是期望收到对方<strong>下一个报文段的第一个数据字节的序号</strong></p><h4 id="4-数据偏移"><a href="#4-数据偏移" class="headerlink" title="4.数据偏移"></a>4.数据偏移</h4><p>​    指出TCP报文段的<strong>数据起始处</strong>距离TCP报文段的起始处有多远</p><p>​    <strong>指出TCP报文段的首部长度</strong></p><h4 id="5-保留"><a href="#5-保留" class="headerlink" title="5.保留"></a>5.保留</h4><p>​    6位。保留为今后使用，目前置为零</p><h4 id="6-紧急URG"><a href="#6-紧急URG" class="headerlink" title="6.紧急URG"></a>6.紧急URG</h4><p>​    URG = 1 表明紧急指针字段有效。表明报文段中<strong>有紧急数据，应该尽快传送</strong></p><p>​    发送方TCP把紧急数据插入到<strong>本报文段数据的最前面</strong>。紧急数据后面的数据仍然是普通数据</p><h4 id="7-确认ACK"><a href="#7-确认ACK" class="headerlink" title="7.确认ACK"></a>7.确认ACK</h4><p>​    ACK = 1时确认号字段有效</p><p>​    ACK = 0时，确认号无效</p><p>​    TCP规定，在<strong>连接建立</strong>后所有传送的报文段必须把ACK置为 1 。</p><h4 id="8-推送PSH"><a href="#8-推送PSH" class="headerlink" title="8.推送PSH"></a>8.推送PSH</h4><p>​    发送方TCP把PSH置1，并立即创建一个报文段发送出去</p><p>​    接收方TCP收到PSH = 1的报文段，尽快交付接受应用进程，不再等到整个缓存都填满了再向上交付</p><h4 id="9-复位RST"><a href="#9-复位RST" class="headerlink" title="9.复位RST"></a>9.复位RST</h4><p>​    RST = 1时，表明TCP连接中出现<strong>严重差错</strong>(如主机崩溃等)，必须<strong>释放连接</strong>，然后再重新建立运输连接。</p><p>​    还可以用来拒绝一个非法的报文段或拒绝打开一个连接</p><h4 id="10-同步SYN"><a href="#10-同步SYN" class="headerlink" title="10.同步SYN"></a>10.同步SYN</h4><p>​    在连接建立时同步序号</p><p>​    SYN = 1而ACK = 0时，表明这是个<strong>连接请求报文</strong></p><p>​    若同意建立连接，在响应的报文段中使 SYN = 1 和 ACK = 1</p><p>​    SYN置1表示这是一个<strong>连接请求或连接接受报文</strong></p><h4 id="11-终止FIN"><a href="#11-终止FIN" class="headerlink" title="11.终止FIN"></a>11.终止FIN</h4><p>​    用来释放一个连接。</p><p>​    FIN = 1，表明此报文段的发送方的数据已放松完毕，并要求释放运输连接</p><h4 id="12-窗口"><a href="#12-窗口" class="headerlink" title="12.窗口"></a>12.窗口</h4><p>​    2个字节</p><p>​    指的是发送本报文段的一方的接收窗口(不是自己的发送窗口)</p><p>​    <strong>窗口值作为接收方让发送方设置其发送窗口的依据</strong>。</p><p>​    <strong>窗口字段明确指出了现在允许对方发送的数据量。</strong>窗口值经常动态变化</p><ul><li>发送一个报文段，确认号是701，窗口字段是1000<ul><li>告诉对方：701开始，我的接收缓存空间还能接收1000个字节数据</li></ul></li></ul><h4 id="13-检验和"><a href="#13-检验和" class="headerlink" title="13.检验和"></a>13.检验和</h4><p>​    2个字节</p><p>​    检验和字段检验的范围包括<strong>首部和数据</strong>两部分。同UDP</p><h4 id="14-紧急指针"><a href="#14-紧急指针" class="headerlink" title="14.紧急指针"></a>14.紧急指针</h4><p>​    2个字节</p><p>​    URG = 1 时才有意义</p><p>​    指出本报文段中的<strong>紧急数据的字节数</strong></p><h4 id="15-选项"><a href="#15-选项" class="headerlink" title="15.选项"></a>15.选项</h4><p>​    长度可变。最长40字节</p><p>​    没有使用选项时，TCP首部长度时20字节</p><p>​    最后的填充字段时为了使整个TCP首部长度是4字节的整数倍</p><hr><h4 id="最大报文段长度MSS"><a href="#最大报文段长度MSS" class="headerlink" title="最大报文段长度MSS"></a>最大报文段长度MSS</h4><p>​    指每个TCP报文段中的<strong>数据字段</strong>的最大长度(TCP报文段长度 - TCP首部长度）。</p><p>​    数据字段加上TCP首部 = TCP报文段</p><h3 id="star-TCP流量控制"><a href="#star-TCP流量控制" class="headerlink" title=":star:TCP流量控制"></a>:star:TCP流量控制</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>​    让发送方的发送速率不要太快，让接收方来得及接收</p><h4 id="流量控制举例"><a href="#流量控制举例" class="headerlink" title="流量控制举例"></a>流量控制举例</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110004211088.png" alt="image-20240110004211088"></p><h4 id="持续计时器"><a href="#持续计时器" class="headerlink" title="持续计时器"></a>持续计时器</h4><h5 id="作用："><a href="#作用：" class="headerlink" title="作用："></a><strong>作用</strong>：</h5><p>​    如果主机B发送了<strong>0窗口通知后</strong>，主机A会等待主机B发送<strong>非0窗口通知</strong>。如果主机B在发送非0窗口通知的报文段在传送过程中丢失后，主机B会一直等待主机A的数据，主机A 也在等待B发送非0窗口通知，陷入死锁。</p><p><img src="C:\Users\Stiches\AppData\Roaming\Typora\typora-user-images\image-20240110092139159.png" alt="image-20240110092139159"></p><h5 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h5><p>​    收到对方0窗口通知后，就启动持续计时器。如持续计时器超时，就发送一个<strong>零窗口探测报文段</strong>(携带1字节的数据)，对方就在确认这个探测报文段时给出现在的窗口值。</p><p>​    如果窗口仍然是零，那么收到这个报文段的一方就重新设置持续计时器。</p><p>​    零窗口计时器也有重传计时器，当超时后，零窗口计时器会重传</p><p>​    即使接收窗口为0，也必须接收零窗口探测报文段、确认报文段、携带紧急数据的报文段。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110004506109.png" alt="image-20240110004506109"></p><h3 id="star-拥塞控制"><a href="#star-拥塞控制" class="headerlink" title=":star:拥塞控制"></a>:star:拥塞控制</h3><blockquote><p>拥塞控制就是防止过多的数据注入到网络中，可以使网络中的路由器或链路不至于过载。拥塞控制的前提是网络能够承受现有的网络符负荷</p></blockquote><h4 id="拥塞的定义："><a href="#拥塞的定义：" class="headerlink" title="拥塞的定义："></a>拥塞的定义：</h4><p>​    某段时间，若对网络中某一<strong>资源的需求</strong>超过了该资源所能提供的<strong>可用部分</strong>，<strong>网络的性能就要变坏。</strong></p><p>​    如果出现拥塞不进行控制，整个网络的吞吐量将随输入负载的增大而下降</p><p>​    资源：网络中的链路容量(带宽)，交换结点中的缓存和处理机等</p><h4 id="发生原因："><a href="#发生原因：" class="headerlink" title="发生原因："></a>发生原因：</h4><p>1.某个节点缓存的容量太小，到达该节点的分组因无存储空间被丢弃</p><p>2.输出链路的容量和出来就的处理速度并未提高</p><p>3.处理机处理的速度太低</p><p>4.拥塞尝尝趋于恶化</p><h4 id="拥塞控制和流量控制的区别"><a href="#拥塞控制和流量控制的区别" class="headerlink" title="拥塞控制和流量控制的区别"></a>拥塞控制和流量控制的区别</h4><ul><li>流量控制往往是指点对点通信量的控制，是端到端的问题(接收端控制发送端)</li><li>流量控制要做的就是抑制发送端发送数据的速率</li></ul><ul><li>拥塞控制是<strong>全局性</strong>的过程。</li><li>防止过多的数据注入到网络中</li></ul><blockquote><p>拥塞控制算法假定</p><ul><li>数据是单方向传送的，对方只传送确认报文</li><li>接收方总是有足够大的缓存空间，因而<strong>发送窗口的大小由网络的拥塞程度来决定</strong><ul><li>发送窗口 = 拥塞窗口</li></ul></li></ul></blockquote><h4 id="1-慢开始算法和拥塞避免算法"><a href="#1-慢开始算法和拥塞避免算法" class="headerlink" title="1.慢开始算法和拥塞避免算法"></a>1.慢开始算法和拥塞避免算法</h4><p>​    TCP在开始发送报文段时，设置 cwnd = 1，swnd = cwnd(拥塞窗口值 = 发送窗口值)，即发送一个报文段。</p><p>​    <strong>一开始使用慢开始算法</strong>。设置cwnd = 1，ssthresh = 16(慢开始门限)发送方向接收发送TCP报文段0 ， 接收方向发送方发送对报文段0的确认。然后cwnd指数增长到2，发送TCP报文段1~2。</p><p>​    当cwnd &gt; 16时，使用<strong>拥塞避免算法</strong>，每经过一个往返时间RTT，cwnd每次加1。</p><ul><li><p>当 cwnd &lt; ssthresh 时 ， 使用慢开始算法</p></li><li><p>当 cwnd &gt; ssthresh 时 ， 使用拥塞避免算法</p></li><li><p>当 cwnd = ssthresh 时 ， 既可以用慢开始，也可以用拥塞避免算法</p></li></ul><p>​    如果在 cwnd = 24的时候网络出现了超时，这是网络发生拥塞的标志</p><ul><li>调整门限值 ssthresh = cwnd /2 = 12</li><li>cwnd = 1 开始执行慢开始算法</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110095938265.png" alt="image-20240110095938265"></p><p>​    有时候个别报文段会在网络中意外丢失(出现3-ACK：发送方一连收到3个对同一报文段的重复确认)，但实际上网络并没有发生拥塞。会误认为网络发生了拥塞，导致发送方错误地启动慢开始，减低效率。快重传和快恢复中解决</p><h4 id="2-快重传和快恢复"><a href="#2-快重传和快恢复" class="headerlink" title="2.快重传和快恢复"></a>2.快重传和快恢复</h4><blockquote><p>快重传就是让发送方今早知道发生了个别报文段的丢失。让发生方尽快进行重传，不是等超时重传计时器超时了再重传</p></blockquote><ul><li>接收方不要等到自己发送数据时才进行捎带确认，而是要<strong>立即发送确认</strong></li><li>即使收到了<strong>失序的报文段</strong>也要立即发出对已收到的报文段的<strong>重复确认</strong></li><li>发送方一旦收到<strong>3个连续的重复确认</strong>，就将相应的报文段立即重传，不是等超时计时器超时再重传</li><li>对于个别丢失的报文段，不会出现超时重传，不会被误认为出现了拥塞。</li><li>使用快重传可以使整个网络的吞吐量提高约20%</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110103016631.png" alt="image-20240110103016631"></p><ul><li>接收方发送对M2的重复确认，让发送方知道接收方没有收到报文段M3</li><li>接受方发送的确认号 是期望收到对方<strong>下一个报文段的第一个数据字节的序号</strong><ul><li>确认M1，即收到了序号0，期望收到序号1</li></ul></li></ul><hr><p>​    发送方一旦收到3个重复确认，就知道只是丢失了个别的报文段。就不启动慢开始算法，而是执行<strong>快恢复算法</strong></p><ul><li>把门限值 ssthresh 和拥塞窗口的数值 cwnd 调整为<strong>当前窗口的一半</strong>，开始执行拥塞避免算法</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110103729570.png" alt="image-20240110103729570"></p><h4 id="发送窗口"><a href="#发送窗口" class="headerlink" title="发送窗口"></a>发送窗口</h4><p>​    <strong>发送方窗口的上限值 = Min [ rwnd , cwnd]</strong></p><ul><li>rwnd: 接收方窗口值</li></ul><p>​    当 rwnd &lt; cwnd 接收方的接收能力限制发送方窗口的最大值</p><p>​    当 rwnd &gt; cwnd 网络的拥塞程度限制发送方窗口的最大值</p><ul><li>rwnd和cwnd中较小的一个，控制了发送方发送数据的速率</li></ul><h3 id="TCP的连接和释放"><a href="#TCP的连接和释放" class="headerlink" title="TCP的连接和释放"></a>TCP的连接和释放</h3><p>运输连接的三个阶段</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110195515133.png" alt="image-20240110195515133"></p><ul><li>建立TCP连接</li><li>数据传送</li><li>释放TCP连接</li></ul><h4 id="三报文握手"><a href="#三报文握手" class="headerlink" title="三报文握手"></a>三报文握手</h4><h5 id="建立过程中要解决的三个问题"><a href="#建立过程中要解决的三个问题" class="headerlink" title="建立过程中要解决的三个问题"></a>建立过程中要解决的三个问题</h5><p>1。要使每一方都能确知对方的存在</p><p>2。要允许双方协商一些参数(最大窗口值、是否使用窗口扩大选项和时间戳选择等)</p><p>3。能够对运输实体资源(缓存大小、连接表中的项目等)进行分配</p><blockquote><p>主动发起建立的应用程序叫作客户，被动等待连接建立的应用程序叫作服务器</p></blockquote><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110200203877.png" alt="image-20240110200203877"></p><p> <strong>为什么不能只使用两报文握手</strong></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110200402936.png" alt="image-20240110200402936"></p><ul><li>同步位 SYN = 1 表明是TCP连接请求报文段<ul><li>SYN = 1 不能携带数据，但要消耗掉一个序号</li></ul></li><li>SYN = 1, ACK = 1表明是TCP连接确认报文段</li></ul><h4 id="四报文挥手"><a href="#四报文挥手" class="headerlink" title="四报文挥手"></a>四报文挥手</h4><p>  <img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110201056003.png" alt="image-20240110201056003"></p><h5 id="等待2MSL原因"><a href="#等待2MSL原因" class="headerlink" title="等待2MSL原因"></a>等待2MSL原因</h5><p>​    MSL:最长报文段寿命</p><ul><li>防止客户端在发送最后的确认报文后，直接关闭。然而确认报文丢失的情况</li><li>服务器端收不到确认报文，一直超时重复TCP连接释放不能关闭</li></ul><h5 id="保活计时器"><a href="#保活计时器" class="headerlink" title="保活计时器"></a>保活计时器</h5><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110201445879.png" alt="image-20240110201445879"></p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><h3 id="1"><a href="#1" class="headerlink" title="1."></a>1.</h3><p>运输层在协议栈中的地位和作用。运输层的通信和网络层的通信有什么重要的区别？为什么运输层是必不可少的?</p><p>1）    运输层是ISO/OSI的第四层，处于 通信子网 和 资源子网 之间，<strong>是整个协议层次中最核心的一层</strong>。 它的作用是在优化 网络服务 的基础上，为源主机和目标主机之间提供可靠的价格合理的透明 数据传输 ，使高层服务用户在相互通信时不必关心通信子网实现的细节。</p><p>​    从通信和信息处理的角度看，运输层向它上面的应用层提供通信服务，属于面向通信部分的最高层，同时也是用户功能中的最低层。</p><p>2）<strong>运输层</strong>提供<strong>应用程序间</strong>的逻辑通信</p><p>运输层还要对收到的报文进行<strong>差错检测</strong></p><p><strong>网络层</strong>为<strong>主机之间</strong>的通信提供服务</p><p>​    网络层负责将数据包<strong>从源传输到目的地</strong>，而运输层负责<strong>确保数据包在源和目的地之间的可靠传输</strong>。</p><p>​    网络层是<strong>点对点</strong>的通信，而运输层是<strong>端到端</strong>的通信。</p><p>3）因为它<strong>提供了可靠的数据传输服务</strong>，确保数据在源和目的地之间的<strong>可靠传输</strong>。</p><p>​    如果没有运输层，数据报可能会在传输过程中丢失或损坏，导致通信失败。此外，运输层还提供了多种协议，如TCP和UDP，以满足不同的通信需求。</p><hr><h3 id="2"><a href="#2" class="headerlink" title="2."></a>2.</h3><p>网络层提供数据报或者虚电路服务对上面的运输层有何影响?</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">网络层提供数据报或者虚电路服务不影响上面的运输层的运行机制，但提供不同的服务质量<br></code></pre></td></tr></table></figure><hr><h3 id="3"><a href="#3" class="headerlink" title="3."></a>3.</h3><p>端口的作用是什么。为什么要划分为三种</p><ul><li><p>端口的作用是对TCP/IP体系的应用进程进行统一的标志，<strong>使运行不同操作系统的计算机的应用进程能够互相通信。</strong></p></li><li><p>端口号<strong>只有本地意义</strong>，端口号只是为了标识本计算机应用层中的各进程。不同计算机的相同端口号没有联系</p></li><li><p>端口是用来<strong>标志进程的</strong>。端口也就是协议端口号。</p></li><li><p>但这种在协议栈层间的抽象的协议端口是软件端口，和路由器或交换机上的硬件端口是完全不同的概念。</p><ul><li>硬件端口是不同硬件设备进行交互的接口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址。</li></ul></li><li><p>不同的系统，具体实现端口的方法可以是不同的（取决于系统使用的操作系统)。</p><ul><li>TCP/IP 的运输层用一个16位端口号来标志一个端口。</li></ul></li><li><p>两个计算机中的进程要互相通信,不仅必须知道对方的IP地址(为了找到对方的计算机)，而且还要知道对方的端口号</p></li></ul><p>​    不同的端口类别有其特殊的用途。例如，客户端是通信的发起方，而服务器是服务的提供方。它们对端口的使用要求是不同的。这三种端口号是:</p><p>(1)熟知端口号或系统端口号，数值为0<del>1023。<br>(2）登记端口号，数值为1024</del>49151。这类端口号是为没有熟知端口号的应用程序使用的。使用这类端口号必须按照IANA规定的手续登记，以防止重复。</p><p>(3)短暂端口号，数值为49152~65535。这类端口号仅在客户进程运行时才动态选择，是留给客户进程选择暂时使用。</p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第四章网络层</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E5%9B%9B%E7%AB%A0%E7%BD%91%E7%BB%9C%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<blockquote><p>网络层的主要任务是实现网络互连，进而实现数据包在个网络之间的传输</p></blockquote><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107154725315.png" alt="image-20240107154725315"></p><h2 id="一。重要概念"><a href="#一。重要概念" class="headerlink" title="一。重要概念"></a>一。重要概念</h2><h3 id="1-提供的两种服务"><a href="#1-提供的两种服务" class="headerlink" title="1.提供的两种服务"></a>1.提供的两种服务</h3><blockquote><p>网络层要设计得尽量简单，向其上层只提供简单灵活的、无连接的、尽最大努力交付的<strong>数据报服务(IP数据报/IP分组)</strong></p></blockquote><p>​    IP数据报 = IP分组</p><h4 id="1-虚电路服务"><a href="#1-虚电路服务" class="headerlink" title="1)虚电路服务"></a>1)虚电路服务</h4><p>​    通信时，需要先建立连接(分组交换中是建立一条虚电路）。</p><p>​    然后双方沿着建立的虚电路发送分组。</p><p>​    通信结束后要释放建立的虚电路</p><h4 id="2-数据报服务"><a href="#2-数据报服务" class="headerlink" title="2)数据报服务"></a>2)数据报服务</h4><p>​    每个分组独立发送，与前后的分组无关。</p><blockquote><p>应用层、传输层提供可靠传输</p></blockquote><table><thead><tr><th align="center">对比</th><th align="center">虚电路</th><th align="center">数据报</th></tr></thead><tbody><tr><td align="center">思路</td><td align="center">可靠通信应当由网络来保证</td><td align="center">可靠通信由用户主机来保证</td></tr><tr><td align="center">连接的建立</td><td align="center">必须建立连接</td><td align="center">不需要</td></tr><tr><td align="center">终点地址</td><td align="center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td align="center">每个分组都有终点的完整地址(IP地址)</td></tr><tr><td align="center">分组的转发</td><td align="center">属于同一条虚电路的分组均按照同一路由进行转发</td><td align="center">每个分组独立查找转发表进行转发</td></tr><tr><td align="center">当节点出现故障时</td><td align="center">所有通过出故障的节点的虚电路均不能工作</td><td align="center">出故障的节点可能丢失分组，一些路由可能会发生变化</td></tr><tr><td align="center">分组的顺序</td><td align="center">总是按发送顺序达到终点</td><td align="center">到达终点的顺序不一定按发送的顺序</td></tr><tr><td align="center">端到端的差错处理和流量控制</td><td align="center">可以由网络负责，也可由用户主机负责</td><td align="center">由用户主机负责</td></tr><tr><td align="center">成本</td><td align="center">成本高</td><td align="center">成本低</td></tr><tr><td align="center">是否可靠</td><td align="center">可靠传输</td><td align="center">不可靠传输</td></tr></tbody></table><h3 id="2-两个层面"><a href="#2-两个层面" class="headerlink" title="2.两个层面"></a>2.两个层面</h3><p>​    不同网络的两个主机之间通信，要经过若干个路由表转发分组完成，<strong>分组查找路由表中的转发表</strong>，根据转发表中指明转发到下一个路由器。</p><p>​    :star:<strong>转发表是由路由表导出的</strong>，路由表又是互联网中许多路由器，按共同选定的路由选择协议，通过许多次的相互交换路由信息产生的。</p><h4 id="路由器之间传送的信息"><a href="#路由器之间传送的信息" class="headerlink" title="路由器之间传送的信息"></a>路由器之间传送的信息</h4><ul><li>转发源主机和目的主机之间所传送的数据</li><li>传送路由信息</li></ul><h4 id="1-数据层面"><a href="#1-数据层面" class="headerlink" title="1.数据层面"></a>1.数据层面</h4><ul><li>每个路由器根据路由器生成的转发表，把收到的分组，按查找到的对应接口转发。</li><li>使用硬件进行转发。速度快</li></ul><h4 id="2-控制层面"><a href="#2-控制层面" class="headerlink" title="2.控制层面"></a>2.控制层面</h4><ul><li>路由选择算法使用软件，速度慢</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107153627806.png" alt="image-20240107153627806"></p><h4 id="软件定义网络SDN"><a href="#软件定义网络SDN" class="headerlink" title="软件定义网络SDN"></a>软件定义网络SDN</h4><blockquote><p>将控制层面的工作几种在远程控制器上执行</p></blockquote><p>​    计算出最佳的路由，在每个路由器中生成其正确的转发表</p><h2 id="二。网际协议IP-Internet-Protocol"><a href="#二。网际协议IP-Internet-Protocol" class="headerlink" title="二。网际协议IP(Internet Protocol)"></a>二。网际协议IP(Internet Protocol)</h2><h3 id="与协议IP配套使用的三个协议"><a href="#与协议IP配套使用的三个协议" class="headerlink" title="与协议IP配套使用的三个协议"></a>与协议IP配套使用的三个协议</h3><ul><li>地址解析协议ARP</li><li>网际控制报文协议ICMP</li><li>网际管理协议IGMP</li></ul><h3 id="1、IP地址"><a href="#1、IP地址" class="headerlink" title="1、IP地址"></a>1、IP地址</h3><h4 id="1-表示方法"><a href="#1-表示方法" class="headerlink" title="1.表示方法"></a>1.表示方法</h4><blockquote><p>IPV4    32位二进制    IPV6    128位</p><p>同一局域网的主机或路由器的IP地址的网络前缀必须时同样的</p></blockquote><p>IP地址由网络号和主机号组成</p><h4 id="2-分类的IP地址"><a href="#2-分类的IP地址" class="headerlink" title="2.分类的IP地址"></a>2.分类的IP地址</h4><h5 id="1）单播地址"><a href="#1）单播地址" class="headerlink" title="1）单播地址"></a>1）单播地址</h5><p><strong>A类： 网络号n = 8</strong></p><ul><li>网络号首位为固定为0，只有7位网络号可用<ul><li>网络号全0表示<strong>本网络</strong></li><li>01111111表示本地环回地址(127)</li></ul></li><li>可指派网络号为126个(2^7 - 1 = 126个)</li></ul><ul><li>全0和全1的主机号一般不指派<ul><li>全0主机号表示<strong>本主机</strong></li><li>全1主机号表示<strong>所有的</strong></li></ul></li><li>最大主机数2^24 -2 = 16777214</li></ul><p><strong>B类： 网络号n = 16</strong></p><ul><li>可指派网络数 2^14<ul><li>128开始</li></ul></li><li>最大主机数2^16 - 2</li></ul><p>C类： 网络号n = 24</p><ul><li>可指派网络数 2^21<ul><li>192开始</li></ul></li><li>最大主机数 2^8 - 2</li></ul><h5 id="2）多播地址"><a href="#2）多播地址" class="headerlink" title="2）多播地址"></a>2）多播地址</h5><p>D类： 网络号n = 4</p><p>3）保留地址</p><p>E类： 网络号 n = 4 保留之后使用</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107155749929.png" alt="image-20240107155749929"></p><h4 id="一般不指派的特殊IP地址"><a href="#一般不指派的特殊IP地址" class="headerlink" title="一般不指派的特殊IP地址"></a>一般不指派的特殊IP地址</h4><p><strong><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107160137025.png" alt="image-20240107160137025"></strong></p><h3 id="2、无分类编址CIDR"><a href="#2、无分类编址CIDR" class="headerlink" title="2、无分类编址CIDR"></a>2、无分类编址CIDR</h3><blockquote><p>把IP地址分为网络前缀和主机号</p><p>网络前缀的位数n不固定</p></blockquote><h4 id="表示方法"><a href="#表示方法" class="headerlink" title="表示方法"></a>表示方法</h4><ul><li>128.14.35.7/20 <ul><li>前20位位网络前缀</li></ul></li></ul><h4 id="地址块"><a href="#地址块" class="headerlink" title="地址块"></a>地址块</h4><ul><li>把<strong>网络前缀相同</strong>的所有<strong>连续</strong>IP地址组成一个CIDR地址块</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107163530354.png" alt="image-20240107163530354"></p><h4 id="地址掩码-子网掩码"><a href="#地址掩码-子网掩码" class="headerlink" title="地址掩码(子网掩码)"></a>地址掩码(子网掩码)</h4><blockquote><p><strong>计算机看不见斜线记法</strong>，使用二进制来进行各种计算时必须使用32位地址掩码能够从IP地址算出网络地址</p></blockquote><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><ul><li>由一连串1或者0组成<ul><li>1的个数就是网络前缀的程度</li></ul></li></ul><p>/20地址块的地址掩码就是 20个连续的1和12个连续的0组成</p><blockquote><p>IP地址与子网掩码进行 <strong>按位与运算</strong> 就能得到网络地址</p></blockquote><ul><li>A类网络： 地址掩码255.0.0.0或者255.0.0.0/8</li><li>B类网络： 地址掩码255.255.0.0或者255.255.0.0/16</li><li>C类网络： 地址掩码255.255.255.0或者255.255.255.0/24</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107164235381.png" alt="image-20240107164235381"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107164250713.png" alt="image-20240107164250713"></p><h5 id="路由聚合"><a href="#路由聚合" class="headerlink" title="路由聚合"></a>路由聚合</h5><blockquote><p>用一个较大的CIDR的地址块代替许多较小的地址块</p></blockquote><p>​    看习题4-22</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">212.56.132.0</span>/<span class="hljs-number">24</span><br><span class="hljs-number">212.56.133.0</span>/<span class="hljs-number">24</span><br><span class="hljs-number">212.56.134.0</span>/<span class="hljs-number">24</span><br><span class="hljs-number">212.56.135.0</span>/<span class="hljs-number">24</span><br>四个地址块进行最大可能聚合<br><br><span class="hljs-number">212.56.132.0</span>/<span class="hljs-number">24</span>          ------&gt;            <span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">10000100</span>.<span class="hljs-number">0</span><br><span class="hljs-number">212.56.133.0</span>/<span class="hljs-number">24</span>        ------&gt;  <span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">10000101</span>.<span class="hljs-number">0</span><br><span class="hljs-number">212.56.134.0</span>/<span class="hljs-number">24</span>------&gt;  <span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">10000110</span>.<span class="hljs-number">0</span><br><span class="hljs-number">212.56.135.0</span>/<span class="hljs-number">24</span>------&gt;  <span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">10000111</span>.<span class="hljs-number">0</span><br><br>划分成<br><span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">10000100</span>.<span class="hljs-number">0</span><br><br>即<span class="hljs-number">212</span>.<span class="hljs-number">56</span>.<span class="hljs-number">132</span>.<span class="hljs-number">0</span>/<span class="hljs-number">22</span><br></code></pre></td></tr></table></figure><h3 id="3-IP地址的特点"><a href="#3-IP地址的特点" class="headerlink" title="3.IP地址的特点"></a>3.IP地址的特点</h3><blockquote><p>IP地址是网络层和以上各层使用的地址，是一种逻辑地址(用软件实现)</p><p>MAC地址是数据链路层使用的地址</p></blockquote><p>1）每个IP地址都由网络前缀和主机号两部分注册</p><p>2）IP地址是标志一台主机和一条链路的接口</p><p>3）一个网络是指具有相同网络前缀的主机的集合</p><ul><li>用转发器或交换机连接起来的若干个局域网仍为一个网络</li></ul><p>4）IP地址中，所有分配到的网络前缀的网络都是平等的。</p><ul><li>互联网平等对待每一个IP地址</li></ul><ul><li>路由器总具有两个或两个以上的IP地址。每个接口的IP地址的网络前缀都不同</li></ul><h3 id="4-IP地址与MAC地址"><a href="#4-IP地址与MAC地址" class="headerlink" title="4.IP地址与MAC地址"></a>4.IP地址与MAC地址</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107201019963.png" alt="image-20240107201019963"></p><blockquote><p> 转发过程中源IP地址和目的IP地址没有改变</p></blockquote><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107201248590.png" alt="image-20240107201248590"></p><ul><li>IP层抽象的互联网上只能看到IP数据报<ul><li>路由器只根据目的站的IP地址进行转发</li></ul></li><li>在局域网的链路层，只能看到MAC帧</li></ul><h3 id="5-IP数据报的格式"><a href="#5-IP数据报的格式" class="headerlink" title="5.IP数据报的格式"></a>5.IP数据报的格式</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107202209133.png" alt="image-20240107202209133"></p><h4 id="1）首部长度："><a href="#1）首部长度：" class="headerlink" title="1）首部长度："></a>1）首部长度：</h4><ul><li><p>占4位</p></li><li><p>IP首部的固定部分是20字节</p><ul><li>IP数据报必须具有的部分</li></ul></li></ul><h4 id="2）总长度"><a href="#2）总长度" class="headerlink" title="2）总长度"></a>2）总长度</h4><ul><li>总长度指首部和数据之和的长度</li><li>16位</li></ul><p>​    数据帧的数据字段的最大长度称为MTU(最大传送单元)，如果数据报长度超过MTU，就必须把过长的数据报进行<strong>分片处理</strong></p><blockquote><p>数据报的最大程度为 2^16 -1 = 65535字节。而MTU一般为1500字节</p></blockquote><h4 id="3）标志"><a href="#3）标志" class="headerlink" title="3）标志"></a>3）标志</h4><ul><li>标志字段中的最低位为MF。<ul><li>MF = 1 表示后面还有分片</li><li>MF = 0 表示这是若干数据报片中的最后一个</li></ul></li><li>标志字段中间一位为DF<ul><li>代表不能分片</li><li>DF = 0 时候才能分片</li></ul></li></ul><h4 id="4）片偏移"><a href="#4）片偏移" class="headerlink" title="4）片偏移"></a>4）片偏移</h4><ul><li>较长的分组在分片后，某片在原分组中的相对位置</li><li>片偏移以<strong>8个字节</strong>为偏移单位</li><li>除了最后一个数据报片外，其他每个分片的长度一定是8字节的整数倍</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107203713325.png" alt="image-20240107203713325"></p><h4 id="5）生存时间"><a href="#5）生存时间" class="headerlink" title="5）生存时间"></a>5）生存时间</h4><ul><li>占8位</li><li>生存时间的英文TTL，表名是数据报在网络中的寿命</li></ul><p>现在已经把TTL改为了<strong>跳数限制</strong></p><blockquote><p>每经过一个路由器时，TTL就会就会减去1.</p><p>TTL为0时，就丢弃这个数据报</p></blockquote><h2 id="三。ICMP"><a href="#三。ICMP" class="headerlink" title="三。ICMP"></a>三。ICMP</h2><blockquote><p>网际控制报文协议ICMP</p><p>IP数据报首部的检验和并不检验IP数据报的内容，因此不能保证经过传输的ICMP报文不产生差错</p></blockquote><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>​    更有效转发IP数据报和提高交付成功的机会，在网际层使用了网际控制报文协议ICMP</p><h3 id="报文分类"><a href="#报文分类" class="headerlink" title="报文分类"></a>报文分类</h3><blockquote><p>ICMP报文被封装在<strong>IP数据报</strong>中发送</p></blockquote><h4 id="1）ICMP差错报告报文"><a href="#1）ICMP差错报告报文" class="headerlink" title="1）ICMP差错报告报文"></a>1）ICMP差错报告报文</h4><h5 id="终点不可达"><a href="#终点不可达" class="headerlink" title="终点不可达"></a>终点不可达</h5><ul><li>路由器或主机不能交付数据报是发送</li></ul><h5 id="时间超过"><a href="#时间超过" class="headerlink" title="时间超过"></a>时间超过</h5><ul><li>TTL = 0</li></ul><h5 id="参数问题"><a href="#参数问题" class="headerlink" title="参数问题"></a>参数问题</h5><ul><li>路由器或者目的主机收到的数据报的首部中有的字段值不正确，应该丢弃</li></ul><h5 id="改变路由-重定向"><a href="#改变路由-重定向" class="headerlink" title="改变路由(重定向)"></a>改变路由(重定向)</h5><ul><li>路由器把改变路由报文发给主机，让主机知道下次应将数据报发给另外的路由器</li></ul><h4 id="2）ICMP询问报文"><a href="#2）ICMP询问报文" class="headerlink" title="2）ICMP询问报文"></a>2）ICMP询问报文</h4><h5 id="1-回送-Echo-请求或回送回答"><a href="#1-回送-Echo-请求或回送回答" class="headerlink" title="1.回送(Echo)请求或回送回答"></a>1.回送(Echo)请求或回送回答</h5><blockquote><p>用于测试目的站是否可达以及了解其有关状态(Ping/tracert)</p></blockquote><ul><li>由主机或路由器向一个<strong>特定的目的主机</strong>发出的询问<ul><li>收到此报文的主机必须向源主机或路由器发送ICMP回送回答报文</li></ul></li></ul><h5 id="2-时间戳-Timestamp-请求或时间戳回答"><a href="#2-时间戳-Timestamp-请求或时间戳回答" class="headerlink" title="2.时间戳(Timestamp)请求或时间戳回答"></a>2.时间戳(Timestamp)请求或时间戳回答</h5><ul><li>时间戳请求报文发出后，就能够收到对方响应的ICMP时间戳回答报文<ul><li>计算出当前网络的往返时延</li></ul></li></ul><h3 id="不发送ICMP差错报告报文的情况"><a href="#不发送ICMP差错报告报文的情况" class="headerlink" title="不发送ICMP差错报告报文的情况"></a>不发送ICMP差错报告报文的情况</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240107211430679.png" alt="image-20240107211430679"></p><h2 id="star-四。路由选择协议"><a href="#star-四。路由选择协议" class="headerlink" title=":star:四。路由选择协议"></a>:star:四。路由选择协议</h2><blockquote><p>路由选择协议是网络层控制层面的内容</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="1。静态路由选择策略"><a href="#1。静态路由选择策略" class="headerlink" title="1。静态路由选择策略"></a>1。静态路由选择策略</h4><p>​    非自适应路由选择。</p><ul><li>简单和开销小</li><li>不能及时适应网络状态的变化</li><li>适用于简单的小网络</li></ul><h4 id="2。动态路由选择策略"><a href="#2。动态路由选择策略" class="headerlink" title="2。动态路由选择策略"></a>2。动态路由选择策略</h4><p>​    自适应路由选择</p><ul><li>能较好适应网络状态变化</li><li>实现起来较为复杂，开销也大</li></ul><p>采用的主要还是自适应的、分布式路由选择协议(动态路由选择)</p><h3 id="分层次的路由选择协议"><a href="#分层次的路由选择协议" class="headerlink" title="分层次的路由选择协议"></a>分层次的路由选择协议</h3><blockquote><p>互联网划分成许多较小的自治系统，即为AS</p><p>AS是单一技术管理下的许多网络、IP地址以及路由器</p></blockquote><h4 id="内部网关协议IGP"><a href="#内部网关协议IGP" class="headerlink" title="内部网关协议IGP"></a>内部网关协议IGP</h4><p>​    <strong>一个自治系统内部使用的路由选择协议</strong></p><ul><li>RIP</li><li>OSPF</li></ul><h4 id="外部网关协议EGP"><a href="#外部网关协议EGP" class="headerlink" title="外部网关协议EGP"></a>外部网关协议EGP</h4><p>​    源主机和目的主机不在同一个AS中，就需要使用EGP</p><ul><li>BGP-4</li></ul><h3 id="路由信息协议RIP"><a href="#路由信息协议RIP" class="headerlink" title="路由信息协议RIP"></a>路由信息协议RIP</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​    <strong>一种分布式的、基于距离向量的路由选择协议</strong></p><ul><li>是内部网关协议IGP最先得到广泛使用的协议</li></ul><h4 id="距离-跳数"><a href="#距离-跳数" class="headerlink" title="距离(跳数)"></a>距离(跳数)</h4><blockquote><p><strong>最佳路由 = 距离最短的路由</strong></p></blockquote><ul><li>路由器到直接连接的网络的距离 = 1</li><li>路由器到非直接连接的网络的距离 = 所经过的路由器数 + 1<ul><li>每经过一个路由器，跳数就加1</li></ul></li></ul><p>​    一条路径最多包含15个路由器</p><p>​    <strong>距离(跳数) = 16 表示不可达</strong></p><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><p>1）仅和<strong>相邻</strong>路由器交换信息</p><p>2）路由器交换的信息就是<strong>当前本路由器所知道的全部信息</strong>，即自己现在的<strong>路由表</strong></p><p>3）按<strong>固定的时间间隔</strong>交换路由信息(更新路由表)</p><p>开始工作的时候，路由表是空的</p><ul><li>只知道自己到直连网络的距离都为1</li><li>与相邻路由器周期交换更新路由信息</li><li>若干次交换和更新后，收敛(每个路由器都知道到达本AS内各个网络的最短距离和下一跳地址)</li></ul><p>​    </p><h4 id="距离向量算法"><a href="#距离向量算法" class="headerlink" title="距离向量算法"></a>距离向量算法</h4><ul><li>发现新的目的网络，更新</li><li>到达目的网络，相同下一跳。最新消息，更新</li><li>到达目的网络，不同下一跳，相同距离，等价负载均衡，更新</li><li>到达目的网络，不同下一跳，距离远，不更新</li></ul><h4 id="坏消息传播得慢"><a href="#坏消息传播得慢" class="headerlink" title="坏消息传播得慢"></a>坏消息传播得慢</h4><blockquote><p>好消息传播的快，而坏消息传播得慢</p></blockquote><p>​    出现路由环路问题</p><h4 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h4><ul><li>限制最大路径距离15</li><li>当路由表发送变化时就立即发送更新报文，不是周期性发送</li><li>让路由器记录收到特定路由信息得接口，而不让同一路由信息再通过此接口反方向传送</li></ul><h3 id="开放最短路径优先OSPF"><a href="#开放最短路径优先OSPF" class="headerlink" title="开放最短路径优先OSPF"></a>开放最短路径优先OSPF</h3><blockquote><p>克服RIP缺点提出</p><p>使用了最短路径算法SPF</p></blockquote><p>基于<strong>链路状态</strong>协议，不像RIP基于距离向量</p><ul><li>采用SPF算法计算路由，不会产生路由环路</li><li>不限制网络规模，更新效率高，收敛速度块</li></ul><p>链路状态是指路由器都和哪些路由器相近，以及相应链路的代价(cost)</p><ul><li>代价：费用、距离、时延、带宽</li></ul><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><blockquote><p><strong>链路状态数据库</strong>能较快地进行更新，使各个路由器能及时更新其路由表。</p><p>:star:<strong>OSPF更新过程收敛速度快</strong></p></blockquote><h4 id="三个特点"><a href="#三个特点" class="headerlink" title="三个特点"></a>三个特点</h4><p>1）采用<strong>洪泛法</strong>，向本自治系统中<strong>所有路由器</strong>发送消息</p><p>2）发送的消息是与本<strong>路由器相邻</strong>的所有路由器的<strong>链路状态</strong>，但这只是路由器知道的部分信息</p><ul><li>链路状态：本路由器都和哪些路由器<strong>相邻</strong>，以及该链路的度量(metric)<ul><li>度量：费用、距离、时延、代价、带宽等</li></ul></li></ul><p>3）当链路状态<strong>发生变化</strong>或<strong>每隔一段时间</strong>，路由器用洪泛法向所有路由器发送此消息</p><h4 id="划分区域"><a href="#划分区域" class="headerlink" title="划分区域"></a>划分区域</h4><blockquote><p>为了使OSPF能用于规模很大的网络，OSPF将一个自治系统再划分为若干个更小的范围，称为区域</p></blockquote><h5 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h5><ul><li>利用洪泛法交换链路状态信息的范围局限于每个区域而不是整个自治系统，减少了整个网络上的通信量</li><li>再一个区域内部的录取只知道本区域的网站网络拓扑，不知道其他区域的网络托盘情况</li></ul><h4 id="五种分组内容"><a href="#五种分组内容" class="headerlink" title="五种分组内容"></a>五种分组内容</h4><h5 id="1。问候-Hello-分组"><a href="#1。问候-Hello-分组" class="headerlink" title="1。问候(Hello)分组"></a>1。问候(Hello)分组</h5><ul><li>用于发现和维持邻站的可达性</li></ul><p>​    每10交换一次问候分组，如果40秒没有收到某个相邻路由器发送的问候分组，则可认为相邻路由器不可达</p><h5 id="2。数据库描述分组"><a href="#2。数据库描述分组" class="headerlink" title="2。数据库描述分组"></a>2。数据库描述分组</h5><ul><li>向邻站给出自己的链路状态数据库中的所有链路状态项目的<strong>摘要信息</strong></li></ul><h5 id="3。链路状态请求分组"><a href="#3。链路状态请求分组" class="headerlink" title="3。链路状态请求分组"></a>3。链路状态请求分组</h5><ul><li>向对方请求发送给某些链路状态项目的详细信息</li></ul><h5 id="4。链路状态更新分组"><a href="#4。链路状态更新分组" class="headerlink" title="4。链路状态更新分组"></a>4。链路状态更新分组</h5><ul><li>用洪泛法对全网更新链路状态。</li><li>是OSPF协议的最核心部分</li></ul><h5 id="5。链路状态确认分组"><a href="#5。链路状态确认分组" class="headerlink" title="5。链路状态确认分组"></a>5。链路状态确认分组</h5><ul><li>对链路更新分组的确认</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109160720793.png" alt="image-20240109160720793"></p><h4 id="工作过程"><a href="#工作过程" class="headerlink" title="工作过程"></a>工作过程</h4><h5 id="1-确认邻站可达"><a href="#1-确认邻站可达" class="headerlink" title="1.确认邻站可达"></a>1.确认邻站可达</h5><p>​    每10交换一次问候分组，如果40秒没有收到某个相邻路由器发送的问候分组，则可认为相邻路由器不可达</p><h5 id="2-同步链路状态数据库"><a href="#2-同步链路状态数据库" class="headerlink" title="2.同步链路状态数据库"></a>2.同步链路状态数据库</h5><p>​    <strong>同步：</strong>不同路由器的链路状态数据库的内容是一样的</p><p>​    <strong>完全邻接路由器</strong>：两个同步的路由器</p><h5 id="3-更新链路状态"><a href="#3-更新链路状态" class="headerlink" title="3.更新链路状态"></a>3.更新链路状态</h5><blockquote><p>OSPF链路状态只涉及相邻路由器，与整个互联网的规模无直接关系</p></blockquote><ul><li>只要链路状态发生变化，路由器就用链路状态更新分组，用<strong>可靠的洪泛法</strong>向全网更新链路状态</li></ul><p><strong>可靠的洪泛法</strong></p><ul><li>再收到更新分组后要发送确认。</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240109161218756.png" alt="image-20240109161218756"></p><h2 id="五、路由器的构成"><a href="#五、路由器的构成" class="headerlink" title="五、路由器的构成"></a>五、路由器的构成</h2><h3 id="1-路由器的结构"><a href="#1-路由器的结构" class="headerlink" title="1.路由器的结构"></a>1.路由器的结构</h3><blockquote><p>路由器是一种具有多个输入端口和多个输出端口的专用计算机，任务是<strong>转发分组</strong></p></blockquote><h4 id="1）路由选择部分-控制层面"><a href="#1）路由选择部分-控制层面" class="headerlink" title="1）路由选择部分(控制层面)"></a>1）路由选择部分(控制层面)</h4><ul><li>核心构件是<strong>路由选择处理机</strong><ul><li>路由选择处理机的任务是根据所选定的路由选择协议<strong>构造出路由表</strong>。并定期和相邻路由器交换路由信息更新和维护路由表</li></ul></li></ul><h4 id="2）分组转发部分-数据层面"><a href="#2）分组转发部分-数据层面" class="headerlink" title="2）分组转发部分(数据层面)"></a>2）分组转发部分(数据层面)</h4><p>1.交换结构</p><p>​    作用是<strong>根据转发表来对分组进行处理</strong>，将某个输入端口进入的分组从一个合适的输出端口转发出去</p><p>2.一组输入端口</p><p>3.一组输出端口(端口是硬件接口)</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2><p>1.网络层向上提供的服务有娜两种，比较优缺点</p><table><thead><tr><th align="center">对比</th><th align="center">虚电路</th><th align="center">数据报</th></tr></thead><tbody><tr><td align="center">思路</td><td align="center">可靠通信应当由网络来保证</td><td align="center">可靠通信由用户主机来保证</td></tr><tr><td align="center">连接的建立</td><td align="center">必须建立连接</td><td align="center">不需要</td></tr><tr><td align="center">终点地址</td><td align="center">仅在连接建立阶段使用，每个分组使用短的虚电路号</td><td align="center">每个分组都有终点的完整地址(IP地址)</td></tr><tr><td align="center">分组的转发</td><td align="center">属于同一条虚电路的分组均按照同一路由进行转发</td><td align="center">每个分组独立查找转发表进行转发</td></tr><tr><td align="center">当节点出现故障时</td><td align="center">所有通过出故障的节点的虚电路均不能工作</td><td align="center">出故障的节点可能丢失分组，一些路由可能会发生变化</td></tr><tr><td align="center">分组的顺序</td><td align="center">总是按发送顺序达到终点</td><td align="center">到达终点的顺序不一定按发送的顺序</td></tr><tr><td align="center">端到端的差错处理和流量控制</td><td align="center">可以由网络复制，也可由用户主机负责</td><td align="center">由用户主机负责</td></tr><tr><td align="center">成本</td><td align="center">成本高</td><td align="center">成本低</td></tr><tr><td align="center">是否可靠</td><td align="center">可靠传输</td><td align="center">不可靠传输</td></tr></tbody></table><p>虚电路服务</p><p>优点</p><ul><li>虚电路服务是面向连接的,网络能够保证分组总是按照发送顺序到达日的站,且不丢失、不重复,提供可靠的端到端数据传输</li><li>目的站地址仅在连接建立阶段使用,每个分组使用短的虚电路号,使分组的控制信息部分的比特数减少,减少了额外开销</li><li>端到端的差错处理和流量控制可以由分组交换网负责,也可以由用户机负责</li><li>虚电路服务适用于通信信息量大、速率要求高、传输可靠性要求高的场合</li></ul><p>缺点</p><ul><li>虚电路服务必须建立连接;</li><li>属于同一条虚电路的分组总是<strong>按照同一路由进行转发</strong>;</li><li>当结节发生故障时,所有通过出故障的节点的虚电路均不能工作。</li></ul><p>数据报服务</p><p>优点</p><ul><li>数据报服务不需要建立连接;</li><li>每个分组<strong>独立选择路由进行转发</strong>,当某个节点发生故障时,后续的分组可以另选路由,因而提高了通信的可靠性。</li><li>数据报服务的灵活性好。适用于传输可靠性要求不高、通信子网负载不均衡、需要选择最佳路径的场合。</li></ul><p>缺点</p><ul><li>数据报服务是面向无连接的,到达目的站时不一定按发送顺序,传输中的分组可能丢失和重复,提供面向无连接的、不可靠的数据传输;</li><li>每个分组都要有目的站的全地址;</li><li>当网络发生故障时,<strong>出故障的节点可能会丢失数据</strong>,一些路由可能会发生变化;</li><li>端到端的差错处理和流量控制只由主机负责。</li></ul><hr><p>2.中间设备、转发器、网桥、路由器和网关的区别</p><ul><li><p><strong>物理层</strong>使用的中间设备叫做<strong>转发器</strong></p></li><li><p><strong>数据链路层</strong>使用的中间设备叫做<strong>网桥或者桥接器，以及交换机</strong></p><ul><li>根据MAC地址转发</li></ul></li><li><p><strong>网络层</strong>使用的中间设备叫做<strong>路由器</strong></p><ul><li>根据路由表转发</li></ul></li><li><p><strong>网络层以上</strong>使用的中间设备叫做<strong>网关</strong>。网关连接两个不兼容的系统需要在高层进行协议的转换</p></li></ul><hr><p>3.简单说明IP、ARP和ICMP协议的作用</p><p>IP：</p><p>IP只为主机提供一种<strong>无连接、不可靠的、尽力而为</strong>的数据包传输服务。</p><ul><li><p><strong>网络层最核心的协议就是IP协议。</strong></p></li><li><p>IP协议根据数据包的目的IP地址来<strong>决定如何传输。</strong></p></li><li><p>IP协议<strong>根据「IP地址」将数据传输到指定的目标主机</strong></p></li><li><p>如果数据包不能直接发送到目标主机，那么IP协议就会为它寻找下一个合适的路由器，并将数据包交付给该路由器来转发。多次重复这一过程，数据包最终到达目标主机，或由于发送失败而被丢弃。</p></li><li><p>IP协议使用跳转的方式确定通信路径。</p></li></ul><p><strong>ARP：</strong></p><p>​    知道IP地址，需要找到其对应的MAC地址</p><p>在主机 ARP 高速缓存中存放一个从 IP 地址到硬件地址的映射表，并且这个映射表经常动态更新。每一台主机都设有一个 ARP 高速缓存(ARP Cache)，里面有本局域网上的各主机和路由器的 <strong>IP 地址到硬件地址的映射表</strong>(并且每一个映射地址都设置有生存时间)。</p><p><strong>ICMP：</strong></p><ul><li>更有效地<strong>转发IP数据报</strong>和<strong>提高交付成功</strong>的机会。</li><li>检测网络通信故障和实现链路追踪</li><li>提供差错ICMP差错报告报文和ICMP询问报文</li></ul><hr><p>4.简述RIP OSPF BGP路由选择协议的主要特点</p><table><thead><tr><th>RIP</th><th>OSPF</th><th>BPG</th></tr></thead><tbody><tr><td>1）仅和<strong>相邻</strong>路由器交换信息</td><td>1）采用<strong>洪泛法</strong>，向本自治系统中<strong>所有路由器</strong>发送消息</td><td>1)基于<strong>路径向量</strong>的路由选择协议</td></tr><tr><td>2）路由器交换的信息就是<strong>当前本路由器所知道的全部信息</strong>，即自己现在的<strong>路由表</strong></td><td>2）发送的消息是与本<strong>路由器相邻</strong>的所有路由器的<strong>链路状态</strong>，但这只是路由器知道的部分信息</td><td>2）对<strong>不同的自治系统</strong>的路由器之间发送交换</td></tr><tr><td>3）按<strong>固定的时间间隔</strong>交换路由信息(更新路由表)</td><td>3）当链路状态<strong>发送变化</strong>或<strong>每隔一段时间</strong>，路由器用洪泛法向所有路由器发送此消息</td><td>3）寻找较好的而非最佳路径</td></tr><tr><td>使用UDP</td><td>使用IP</td><td>使用TCP</td></tr></tbody></table><hr>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第三章数据链路层</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%89%E7%AB%A0%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105000331173.png" alt="image-20240105000331173"></p><h2 id="sweat-smile-一。三个基本问题"><a href="#sweat-smile-一。三个基本问题" class="headerlink" title=":sweat_smile: 一。三个基本问题"></a>:sweat_smile: 一。三个基本问题</h2><h3 id="yum-1-封装成帧"><a href="#yum-1-封装成帧" class="headerlink" title=":yum:1.封装成帧"></a>:yum:1.封装成帧</h3><p>​    在一段数据的前后分别添加首部和尾部，构成一个帧。</p><p>​    首部和尾部包括许多必要的控制信息，发送帧是从帧首部开始发送。</p><p>​    首部和尾部的一个重要作用就是<strong>帧定界(确定帧的界限)</strong></p><h4 id="帧定界符："><a href="#帧定界符：" class="headerlink" title="帧定界符："></a><strong>帧定界符：</strong></h4><p>​    一个帧有必须要有完整的帧定界符</p><ul><li>控制符SOH：帧开始符</li><li>控制符EOT：帧结束符</li></ul><h4 id="帧长："><a href="#帧长：" class="headerlink" title="帧长："></a><strong>帧长：</strong></h4><ul><li>帧的数据部分加上帧首部和帧尾部的长度</li></ul><h4 id="数据部分："><a href="#数据部分：" class="headerlink" title="数据部分："></a><strong>数据部分：</strong></h4><ul><li>网络层的IP数据包传送到数据链路层就成为了帧的数据部分</li></ul><h4 id="最大传送单元MTU："><a href="#最大传送单元MTU：" class="headerlink" title="最大传送单元MTU："></a><strong>最大传送单元MTU：</strong></h4><ul><li>所能传送的帧的数据部分长度上限</li></ul><h3 id="sunglasses-2-透明传输"><a href="#sunglasses-2-透明传输" class="headerlink" title=":sunglasses:2.透明传输"></a>:sunglasses:2.透明传输</h3><h4 id="透明："><a href="#透明：" class="headerlink" title="透明："></a><strong>透明：</strong></h4><ul><li>某一个实际存在的事物看起来却好像不存在一样</li><li>无论什么样的比特组合的数据，都能按照原样没有差别地通过这个数据链路层</li></ul><h4 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a><strong>解决方法：</strong></h4><p>​    设法使数据中可能出现的控制字符”SOH”和”EOT”在接收端不被解释为控制字符</p><p><strong>字符填充法</strong></p><p>​    <strong>发送端</strong>的数据链路层在数据中出现控制字符”SOH”或”EOT”的前面<strong>插入</strong>一个转义字符”ESC”(00011011).</p><p>​    <strong>接收端</strong>的数据链路层把数据送往网络层之前<strong>删除</strong>这个插入的转义字符</p><p>如果转义字符也出现在数据中，也是在转义字符前面加一个转义字符，接收端删除其中前面一个</p><h3 id="shit-3-差错检测"><a href="#shit-3-差错检测" class="headerlink" title=":shit:3.差错检测"></a>:shit:3.差错检测</h3><h4 id="误码率BER"><a href="#误码率BER" class="headerlink" title="误码率BER"></a>误码率BER</h4><p>​    一段时间内，传输错误的比特占所传输比特总数的比率称为误码率</p><h4 id="star-循环冗余检验CRC-看题"><a href="#star-循环冗余检验CRC-看题" class="headerlink" title=":star:循环冗余检验CRC(看题)"></a>:star:循环冗余检验CRC(看题)</h4><p>​    即在待发送的数据后面加上n位冗余码</p><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">数据 / 生成多项式 得到的余数作为冗余码</span><br><span class="hljs-attr"></span><br><span class="hljs-attr">最终要发的数据 </span>=<span class="hljs-string"> 原始数据 + 冗余码</span><br><span class="hljs-string"></span><br><span class="hljs-string">接收到的数据 / 生成多项式 余数为 0 表示发送正确可以接收</span><br></code></pre></td></tr></table></figure><h2 id="二。点对点协议PPP"><a href="#二。点对点协议PPP" class="headerlink" title="二。点对点协议PPP"></a>二。点对点协议PPP</h2><blockquote><p>目前使用最广泛的数据链路层协议</p><p><strong>支持异步链路和同步链路</strong></p></blockquote><h3 id="1-组成"><a href="#1-组成" class="headerlink" title="1.组成"></a>1.组成</h3><h4 id="1）一个将IP数据报封装到串行链路的方法。"><a href="#1）一个将IP数据报封装到串行链路的方法。" class="headerlink" title="1）一个将IP数据报封装到串行链路的方法。"></a>1）一个将IP数据报封装到串行链路的方法。</h4><p>​    IP数据报是PPP帧中的信号部分，受MTU限制</p><h4 id="2）链路控制协议LCP"><a href="#2）链路控制协议LCP" class="headerlink" title="2）链路控制协议LCP"></a>2）链路控制协议LCP</h4><p>​    一个用来建立、配置和测试数据链路连接的链路控制协议</p><h4 id="3）一套网络控制协议NCP"><a href="#3）一套网络控制协议NCP" class="headerlink" title="3）一套网络控制协议NCP"></a>3）一套网络控制协议NCP</h4><p>​    每一个协议支持不同网络层协议</p><h3 id="2-帧格式"><a href="#2-帧格式" class="headerlink" title="2.帧格式"></a>2.帧格式</h3><p><img src="https://img-blog.csdn.net/20160204105742700" alt="img"></p><h4 id="1-各字段含义"><a href="#1-各字段含义" class="headerlink" title="1.各字段含义"></a>1.各字段含义</h4><blockquote><p>PPP帧的首部和尾部分别是四个字段和两个字段</p></blockquote><h5 id="1-帧的开始或结束"><a href="#1-帧的开始或结束" class="headerlink" title="1)帧的开始或结束"></a>1)帧的开始或结束</h5><ul><li>首部的第一个字段和第二个字段都是<strong>标志字符F</strong>(Flag)，<strong>用”7E”来表示</strong><ul><li>连续两帧之间只需要一个标志字段。</li><li>如果出现连续两个标志字段，表示这是个空帧</li></ul></li></ul><h5 id="2-协议字段"><a href="#2-协议字段" class="headerlink" title="2)协议字段"></a>2)协议字段</h5><ul><li>协议字段为0X0021: PPP帧的信息字段为IP数据报</li><li>协议字段为0xC021: PPP帧的信息字段为LCP</li><li>协议字段为0x8021:为网络层的控制数据NCP</li></ul><h5 id="3-信息字段"><a href="#3-信息字段" class="headerlink" title="3)信息字段"></a>3)信息字段</h5><ul><li>长度可变，MTU为1500字节</li></ul><h3 id="3-字节填充-异步传输"><a href="#3-字节填充-异步传输" class="headerlink" title="3.字节填充(异步传输)"></a>3.字节填充(异步传输)</h3><p>​    信息字段中出现和标志字段中一样的比特(0x7E)组合时</p><p>1）把每个0x7E字节转换成<strong>2字节序列(0x7D,0x5E)</strong></p><p>2）信息字段出现一个0x7D，则把<strong>0x7D转义成(0x7D，0x5D)</strong></p><p>3）信息字段出现数据值<strong>小于 0x20</strong>的字符，将其<strong>本身加上0x20</strong>，然后在前面<strong>加入一个0x7D</strong>字节。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240111091513209.png" alt="image-20240111091513209"></p><h3 id="4-零比特填充-同步传输"><a href="#4-零比特填充-同步传输" class="headerlink" title="4.零比特填充(同步传输)"></a>4.零比特填充(同步传输)</h3><p>​    发送端只要发现 <strong>5个连续 1</strong>，就立即填入<strong>一个 0</strong></p><p>​    接收端先找标志字段F确认边界，再用硬件扫描发现5个连续1.把后面的0删去</p><h2 id="未写完"><a href="#未写完" class="headerlink" title="未写完"></a>未写完</h2><h2 id="三。使用广播信道的数据链路层"><a href="#三。使用广播信道的数据链路层" class="headerlink" title="三。使用广播信道的数据链路层"></a>三。使用广播信道的数据链路层</h2><h3 id="1-局域网的数据链路层"><a href="#1-局域网的数据链路层" class="headerlink" title="1.局域网的数据链路层"></a>1.局域网的数据链路层</h3><h4 id="1）局域网主要特点"><a href="#1）局域网主要特点" class="headerlink" title="1）局域网主要特点"></a>1）局域网主要特点</h4><p>​    网络为一个单位所拥有，且地理范围和站点数目均有限</p><h4 id="2）局域网的优点"><a href="#2）局域网的优点" class="headerlink" title="2）局域网的优点"></a>2）局域网的优点</h4><ul><li>具有<strong>广播</strong>功能</li><li>便于系统的扩展和逐渐地演变，各设备的位置可灵活调整和改变</li><li>提高了系统的可靠性、可用性、生存性</li></ul><h3 id="2-CSMA-CD协议"><a href="#2-CSMA-CD协议" class="headerlink" title="2.CSMA/CD协议"></a>2.CSMA/CD协议</h3><blockquote><p>全称：载波监听多址接入/碰撞检测</p><p>使用CSMA/CD协议的以太网只能进行半双工通信</p></blockquote><p>CS：<strong>载波侦听/监听</strong>，每一个站在<strong>发送数据之前</strong>以及<strong>发送数据</strong>时都要检测一下总线上是否有其他计算机在发送数据。</p><p>MA：多址接入，表示许多计算机以多点接入的方式连接在<strong>一根总线上</strong>。 <strong>总线型网络</strong></p><p>CD：碰撞检测（冲突检测），<strong>“边发送边监听”</strong>，适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站是否也在发送数据。    <strong>半双工网络</strong></p><h4 id="退避算法"><a href="#退避算法" class="headerlink" title="退避算法"></a>退避算法</h4><h5 id="争用期："><a href="#争用期：" class="headerlink" title="争用期："></a><strong>争用期</strong>：</h5><p>​    在发送数据帧后至多经过时间2t就可以知道所发送的数据帧遭受了碰撞。往返时间2t称为争用期(2t为两倍的传播时延)</p><p>​    又称碰撞窗口，在一个站在发送数据后，只有通过这个争用期的”考验”才能肯定这次发送不会发送碰撞。</p><p>​    站点从发送帧开始，经过争用期2t这段时间没有检测到碰撞，就可以肯定这次发送不会产生碰撞</p><ul><li>假设传输路径为5km时，争用期时间为51.2us。</li><li><strong>对于10 Mbit/s以太网，在争用期可发送512比特，即64字节。</strong><ul><li>争用期是512比特时间</li><li>1比特时间就是发送1比特所需的时间</li><li>其总线长度不能超过5120m</li></ul></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240111093637174.png" alt="image-20240111093637174"></p><h4 id="退避时间"><a href="#退避时间" class="headerlink" title="退避时间"></a>退避时间</h4><blockquote><p>发生碰撞后，不是等待信道变为空闲后就立即发送数据，而是退避一个随机时间</p></blockquote><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105205735460.png" alt="image-20240105205735460"></p><ul><li>K从重传次数和10中取小</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105205924639.png" alt="image-20240105205924639"></p><ul><li>连续多次发生碰撞，使用退避算法使重传需要退避的平均时间随重传次数而增大(动态退避)，减少产生碰撞的概率</li><li>重传达16次仍不成功的，丢弃该帧<ul><li>表明同时打算发送数据的站太多，导致连续发送冲突</li></ul></li></ul><h4 id="最小帧长"><a href="#最小帧长" class="headerlink" title="最小帧长"></a>最小帧长</h4><p>​    <strong>帧长太短，在发送完毕之前并没有检测处碰撞</strong>。假定这个帧在继续向前传播到达目的站之前和别的站发送的帧发生了碰撞，目的站将收到有差错的帧。可发送站不知道这个帧发生了碰撞，不会重传这个帧。</p><blockquote><p>规定发送时延不能少于共享总线以太网到端的往返时间，即一个争用期2t</p><p>规定最短帧长 64 字节，即512比特</p></blockquote><ul><li><p>如果要发送的数据太少，需要加入填充字节</p></li><li><p>如果在争用期没有检测到碰撞，一定不会发生碰撞</p></li></ul><h2 id="四。在数据链路层扩展以太网"><a href="#四。在数据链路层扩展以太网" class="headerlink" title="四。在数据链路层扩展以太网"></a>四。在数据链路层扩展以太网</h2><h3 id="1-用网桥扩展以太网"><a href="#1-用网桥扩展以太网" class="headerlink" title="1.用网桥扩展以太网"></a>1.用网桥扩展以太网</h3><blockquote><p><strong>网桥工作在数据链路层</strong>，<strong>交换式集线器</strong>即以太网交换机</p><p>转发器、集线器工作在物理层</p></blockquote><p>​    网桥对收到的帧根据其MAC帧的目的地址进行转发和过滤。当网桥收到一个帧时，不是向所有端口转发此帧，而是根据此帧的<strong>目的MAC地址</strong>，查找网桥中的<strong>地址表</strong>，然后确定将此帧转发到哪一个端口，或者丢弃。</p><p>​    以太网交换机实质上就是一个多端口网桥，通常都有十几个或更多端口，和工作在物理层的转发器、集线器有很大区别。</p><ul><li>每个端口都直接和一个单台主机或另一个以太网交换机相连，一般都工作在全双工方式。</li></ul><h4 id="1-网桥转发帧情况"><a href="#1-网桥转发帧情况" class="headerlink" title="1.网桥转发帧情况"></a>1.网桥转发帧情况</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105211423099.png" alt="image-20240105211423099"></p><h4 id="2-网桥丢弃帧情况"><a href="#2-网桥丢弃帧情况" class="headerlink" title="2.网桥丢弃帧情况"></a>2.网桥丢弃帧情况</h4><ul><li>发送主机和目的主机在同一个网段</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105211509477.png" alt="image-20240105211509477"></p><h4 id="3-网桥转发广播帧情况"><a href="#3-网桥转发广播帧情况" class="headerlink" title="3.网桥转发广播帧情况"></a>3.网桥转发广播帧情况</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105211637388.png" alt="image-20240105211637388"></p><h4 id="以太网交换机的特点"><a href="#以太网交换机的特点" class="headerlink" title="以太网交换机的特点"></a>以太网交换机的特点</h4><ul><li><p>以太网交换机就是一个多端口的网桥</p></li><li><p>端口有<strong>存储器</strong>，在输出端口繁忙时可以把到来的帧进行缓存</p><ul><li>存储转发形式</li></ul></li><li><p>(地址表)<strong>交换表</strong>存储在寄存器中，<strong>通过硬件转发</strong>，速度很快</p></li></ul><h3 id="2-自学习功能"><a href="#2-自学习功能" class="headerlink" title="2.自学习功能"></a>2.自学习功能</h3><blockquote><p>透明网桥通过自学习算法建立转发表</p></blockquote><h2 id="五。以太网的MAC层"><a href="#五。以太网的MAC层" class="headerlink" title="五。以太网的MAC层"></a>五。以太网的MAC层</h2><blockquote><p>MAC地址为6个字节，48位</p></blockquote><p>​    在局域网中，硬件地址又称为物理地址或MAC地址</p><h2 id="习题"><a href="#习题" class="headerlink" title="习题"></a>习题</h2>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第二章物理层</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%BA%8C%E7%AB%A0%E7%89%A9%E7%90%86%E5%B1%82/</url>
    
    <content type="html"><![CDATA[<h2 id="yum-一。基本概念"><a href="#yum-一。基本概念" class="headerlink" title=":yum:一。基本概念"></a>:yum:一。基本概念</h2><blockquote><p>作用：尽可能屏蔽掉这些传输媒体和通信手段的差异，使物理层上面的数据链路层感觉不到这些差异。</p><p>​    使数据链路层只需要考虑本层的协议和服务</p></blockquote><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105000331173.png" alt="image-20240105000331173"></p><h3 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h3><blockquote><p>可以将物理层的主要任务描述为确定与传输媒体的接口有关的一些特性</p></blockquote><p>1.机械特性</p><ul><li>指明接口所用接线器的形状和尺寸等</li></ul><p>2.电气特性</p><ul><li>指明在接口电缆的各条线上出现的<strong>电压范围</strong></li></ul><p>3.功能特性</p><ul><li>指明某条线上出现的某一电平的电压的意义</li></ul><p>4.过程特性</p><ul><li>指明对不同功能的各种可能事件的出现顺序</li></ul><h2 id="star-二。数据通信的基础知识"><a href="#star-二。数据通信的基础知识" class="headerlink" title=":star:二。数据通信的基础知识"></a>:star:二。数据通信的基础知识</h2><blockquote><p>一个数据通信系统可以划分为三个部分： 源系统(发送端、发送方)、传输系统(传输网络)、目的系统(接收端、接收方)</p></blockquote><p>信道: 向某一个方向传送信息的媒体</p><h3 id="通信的三种基本方式"><a href="#通信的三种基本方式" class="headerlink" title="通信的三种基本方式"></a>通信的三种基本方式</h3><p>1.单向通信(单工)</p><p>2.双向交替通信(半双工)</p><p>3.双向同时通信(双工)</p><h3 id="基本的带通调制方法"><a href="#基本的带通调制方法" class="headerlink" title="基本的带通调制方法"></a>基本的带通调制方法</h3><p>1.调幅</p><p>2.调频</p><p>3.调相</p><h3 id="信道的极限容量"><a href="#信道的极限容量" class="headerlink" title="信道的极限容量"></a>信道的极限容量</h3><h4 id="1-奈式准则"><a href="#1-奈式准则" class="headerlink" title="1.奈式准则"></a>1.奈式准则</h4><p>​    在带宽为W(Hz)的低通信道中，若不考虑噪声影响，则**码元传输的最高速率是2W(码元/秒)**。</p><ul><li>传输速率超过上限，就会出现码间串扰问题，使接收端对码元的判决(识别)成为不可能</li></ul><h4 id="2-信噪比S-N-dB"><a href="#2-信噪比S-N-dB" class="headerlink" title="2.信噪比S/N(dB)"></a>2.信噪比S/N(dB)</h4><p>​    信噪比就是：信号的平均功率和噪声的平均功率之比<br>$$<br>信噪比(dB) = 10log_{10}(S/N)<br>$$</p><h4 id="3-香农公式"><a href="#3-香农公式" class="headerlink" title="3.香农公式"></a>3.香农公式</h4><p>​    <strong>极限信息传输速率C(bit/s)</strong><br>$$<br>C = W log_2(1+S/N)<br>$$</p><ul><li><p>W: 信道带宽(Hz)</p></li><li><p>S: 信道中信号的平均功率</p></li><li><p>N：信道内的高斯噪声功率</p></li></ul><h3 id="信道复用"><a href="#信道复用" class="headerlink" title="信道复用"></a>信道复用</h3><blockquote><p>复用是将单一媒体的频带资源划分成很多子信道，这些子信道之间相互独立，互不干扰。从媒体的整体频带资源来看，每个子信道只占用该媒体频带资源的一部分</p></blockquote><h4 id="频分复用FDM"><a href="#频分复用FDM" class="headerlink" title="频分复用FDM"></a>频分复用FDM</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240111100537562.png" alt="image-20240111100537562"></p><h4 id="时分复用TDM"><a href="#时分复用TDM" class="headerlink" title="时分复用TDM"></a>时分复用TDM</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240111100625228.png" alt="image-20240111100625228"></p><h4 id="统计时分复用STDM"><a href="#统计时分复用STDM" class="headerlink" title="统计时分复用STDM"></a>统计时分复用STDM</h4><h4 id="波分复用WDM"><a href="#波分复用WDM" class="headerlink" title="波分复用WDM"></a>波分复用WDM</h4><p>​    <strong>光的频分复用</strong></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240111100735890.png" alt="image-20240111100735890"></p><h4 id="码分复用CDM"><a href="#码分复用CDM" class="headerlink" title="码分复用CDM"></a>码分复用CDM</h4><h2 id="shit-三。习题"><a href="#shit-三。习题" class="headerlink" title=":shit:三。习题"></a>:shit:三。习题</h2><p>1.假定某信道受奈式准则限制的最高码元速率为20000码元/秒。若采用振幅调制，把码元的振幅划分成16个不同的等级来传送，那么可以获得多高的数据率(bit/s)</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">16</span><span class="hljs-string">个不同等级的振幅要用4位2进制数字</span><br><span class="hljs-number">0000 </span><span class="hljs-number">0001 </span><span class="hljs-number">0010 </span><span class="hljs-number">0011 </span><span class="hljs-number">0100 </span><span class="hljs-number">0101 </span><span class="hljs-number">0110 </span><span class="hljs-number">0111 </span><span class="hljs-number">1000</span><span class="hljs-string">........</span><br><span class="hljs-string">一个码元可以表示4个比特</span><br><span class="hljs-string">码元速率为20000时，振幅调制后为4倍速率，即80000</span> <span class="hljs-string">bit/s</span><br><br><span class="hljs-string">----------------------------------------------------------------</span><br><span class="hljs-string">用香农公式</span><br><span class="hljs-string">数据率</span> <span class="hljs-string">=</span> <span class="hljs-string">C</span> <span class="hljs-string">*</span> <span class="hljs-string">log2(16)</span> <span class="hljs-string">=</span> <span class="hljs-number">20000</span> <span class="hljs-string">*</span> <span class="hljs-string">log2(16)</span><br></code></pre></td></tr></table></figure><p>2.假设用3kHz带宽的信道传送64kbit/s数据，信道需要多高的信噪比</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">64</span> kbit/s = <span class="hljs-number">3</span> kHz * log2(<span class="hljs-number">1</span>+S/N)<br><br><span class="hljs-attribute">S</span>/N = <span class="hljs-number">2</span>^(<span class="hljs-number">64</span>/<span class="hljs-number">3</span>) -<span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>3.用香农公式计算一下，假定信道带宽为3100Hz,最大信息传输速率是35kbit/s，若想让最大信息传输速率增大60%，信噪比要增大多少倍。    在刚刚基础上将信噪比增大到10倍，最大信息传输速率能否增加20%</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs tap">要增加到的信息传输速率 =<span class="hljs-number"> 35 </span>(1+0.60） = <span class="hljs-number"> 56 </span>kbit/s<br></code></pre></td></tr></table></figure><p>4.物理层接口有哪几个方面的特性？包含什么内容</p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计网第一章概述</title>
    <link href="/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/"/>
    <url>/2024/01/14/%E8%AE%A1%E7%BD%91%E7%AC%AC%E4%B8%80%E7%AB%A0%E6%A6%82%E8%BF%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="一。计算机网络的性能指标"><a href="#一。计算机网络的性能指标" class="headerlink" title="一。计算机网络的性能指标"></a>一。计算机网络的性能指标</h2><h3 id="1-速率"><a href="#1-速率" class="headerlink" title="1.速率"></a>1.速率</h3><p>​    <strong>数据的传送速率</strong> bit/s</p><h3 id="2-带宽"><a href="#2-带宽" class="headerlink" title="2.带宽"></a>2.带宽</h3><ol><li>某个信号具有的频带宽度。信号所包含的各种频率成分所占据的频率范围</li><li>计网中，<strong>带宽用来表示某通道传递数据的能力</strong>，单位就是bit/s(bps)</li></ol><h3 id="3-吞吐量"><a href="#3-吞吐量" class="headerlink" title="3.吞吐量"></a>3.吞吐量</h3><p>​    单位时间内通过某个网络的<strong>实际数据量。</strong></p><h3 id="star-4-时延"><a href="#star-4-时延" class="headerlink" title=":star:4.时延"></a>:star:4.时延</h3><figure class="highlight fix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs fix"><span class="hljs-attr">总时延 </span>=<span class="hljs-string"> 发送时延 + 传播时延 + 处理时延 + 排队时延</span><br></code></pre></td></tr></table></figure><ol><li><p>发送延迟</p><p>主机或路由器发送数据帧所需要的时间<br>$$<br>发送时延 = 数据帧长度(bit) / 发送速率(bit/s)<br>$$</p></li><li><p>传播延迟</p><p>电磁波在信道中传播一定距离所需要花的时间<br>$$<br>传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s)<br>$$</p><ul><li>1000KM的光纤上的传播时延约为5ms</li></ul></li><li><p>处理延迟</p><p>主机或路由器在收到分组时要花费一定的时间进行处理</p></li><li><p>排队延迟</p><p>分组在经过网络传输时，要经过许多路由器。分组在进入路由器后要先在输入队列中排队等待处理</p></li></ol><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110210222069.png" alt="image-20240110210222069"></p><ul><li>无论发送多少比特数据，都只有一个传播时延</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110210354141.png" alt="image-20240110210354141"></li></ul><h3 id="star-5-时延带宽积"><a href="#star-5-时延带宽积" class="headerlink" title=":star:5.时延带宽积"></a>:star:5.时延带宽积</h3><blockquote><p>圆柱体管道代表一个链路</p><p>传播时延表示链路长度，带宽代表管道的截面积，时延带宽积代表圆柱体体积，即链路可以容纳多少个比特</p></blockquote><ul><li>若发送端连续发送数据，则在发送的第一个比特即将到达终点时，发送端已经发送了时延带宽积个比特</li><li>时延带宽积又称 以比特为单位的链路长度</li></ul><p>$$<br>时延带宽积 = 传播时延 * 带宽<br>$$</p><h3 id="6-往返时间RTT"><a href="#6-往返时间RTT" class="headerlink" title="6.往返时间RTT"></a>6.往返时间RTT</h3><p>​    双向交互一次所需的时间<br>$$<br>有效数据率 = 数据长度 / (发送时间+RTT）<br>$$</p><h2 id="二。计算机网络体系结构"><a href="#二。计算机网络体系结构" class="headerlink" title="二。计算机网络体系结构"></a>二。计算机网络体系结构</h2><h3 id="1-协议与划分层次"><a href="#1-协议与划分层次" class="headerlink" title="1.协议与划分层次"></a>1.协议与划分层次</h3><h5 id="star-网络协议："><a href="#star-网络协议：" class="headerlink" title=":star:网络协议："></a>:star:<strong>网络协议：</strong></h5><p>定义：为进行网络中的<strong>数据交换</strong>而建立的<strong>规则、标准或约定</strong></p><p>:star:组成：</p><ul><li>语法：数据与控制信息的结构或格式</li><li>语义：需要发出何种控制信息，完成何种动作以及做出何种响应</li><li>同步：时间实现顺序的详细说明</li></ul><blockquote><p>计算机网络的各层及其协议的集合就是网络的体系结构</p></blockquote><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240105000331173.png"/><h2 id="三。三种交换方式"><a href="#三。三种交换方式" class="headerlink" title="三。三种交换方式"></a>三。三种交换方式</h2><h3 id="1-电路交换"><a href="#1-电路交换" class="headerlink" title="1.电路交换"></a>1.电路交换</h3><blockquote><p> 电话交换机接通电话线的方式</p></blockquote><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ul><li>建立连接(物理连接)：分配通信资源</li><li>通话（一直占用通信资源）</li><li>释放连接</li></ul><h3 id="2-分组交换"><a href="#2-分组交换" class="headerlink" title="2.分组交换"></a>2.分组交换</h3><p>​    首部数据 + 数据部分组成分组</p><p>发送方：</p><ul><li>构造分组，发送分组</li></ul><p>路由器(分组交换机)</p><ul><li>要完成的任务就是缓存分组和转发分组</li></ul><p>接收方：</p><ul><li>接收分组，还原报文</li></ul><h3 id="3-报文交换"><a href="#3-报文交换" class="headerlink" title="3.报文交换"></a>3.报文交换</h3><p>​    用于早期的电报通信网，现在基本已经被取代</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240110221902248.png" alt="image-20240110221902248"></p><h2 id="四。习题"><a href="#四。习题" class="headerlink" title="四。习题"></a>四。习题</h2><ol><li><p>网络协议的三要素是什么，各有什么含义</p></li><li><p>主机A向主机B连续传送一个600000bit的文件。A和B之间有一条带宽为1Mbit/s的链路相连，距离为5000km，在此链路上的传播速率为2.5*10^8m/s</p></li></ol><p>1)链路上的比特数目的最大值是多少</p><p>2)链路上每比特的宽度为多少</p><p>3)若把链路上每比特的宽度变为5000km，应该把发送速率调整到什么数值</p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机网络</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>安卓</title>
    <link href="/2024/01/07/%E5%AE%89%E5%8D%93/"/>
    <url>/2024/01/07/%E5%AE%89%E5%8D%93/</url>
    
    <content type="html"><![CDATA[<h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><blockquote><p> Android是Google公司基于Linux平台开发的手机及平板电脑的操作系统。</p></blockquote><h2 id="一。安卓体系的具体结构"><a href="#一。安卓体系的具体结构" class="headerlink" title="一。安卓体系的具体结构"></a>一。安卓体系的具体结构</h2><blockquote><p>分层结构，由高到低分别是应用程序层、应用程序框架层、核心类层、Linux内核</p></blockquote><h3 id="1-应用程序层-Applications"><a href="#1-应用程序层-Applications" class="headerlink" title="1.应用程序层(Applications)"></a>1.应用程序层(Applications)</h3><p>​    一个核心应用程序的集合，所有安装在手机上的应用程序都属于这一层，例如系统自带的联系人程序、短信程序等</p><h3 id="2-应用程序框架层-Application-Framework"><a href="#2-应用程序框架层-Application-Framework" class="headerlink" title="2.应用程序框架层(Application Framework)"></a>2.应用程序框架层(Application Framework)</h3><p>​    主要提供了构建应用程序时用到的各种API</p><h3 id="3-核心类层-Libraries"><a href="#3-核心类层-Libraries" class="headerlink" title="3.核心类层(Libraries)"></a>3.核心类层(Libraries)</h3><p>​    包含了系统库及Android运行时库。系统层这一层主要通过CC++库来位Android系统提供主要的特性支持。</p><h3 id="4-Linux内核"><a href="#4-Linux内核" class="headerlink" title="4.Linux内核"></a>4.Linux内核</h3><p>​    为Android设备的各种硬件提供了底层的驱动</p><h2 id="二。Dalvik虚拟机"><a href="#二。Dalvik虚拟机" class="headerlink" title="二。Dalvik虚拟机"></a>二。Dalvik虚拟机</h2><h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1.定义"></a>1.定义</h3><p>​    Google自己设计用于Android平台的虚拟机，可以简单地完成进程隔离和线程管理，并可以提高内存的使用效率。每个Android应用程序在底层都会对应一个独立的Dalvik虚拟机实例。</p><h3 id="2-与Java虚拟机的不同"><a href="#2-与Java虚拟机的不同" class="headerlink" title="2.与Java虚拟机的不同"></a>2.与Java虚拟机的不同</h3><p>Java虚拟机: <strong>基于栈的架构</strong></p><p>​    栈是连续的内存空间，取出存入的速度比较慢</p><ul><li>编译后文件：.java -&gt; .class -&gt; .jar</li></ul><hr><p>Dalvik虚拟机： <strong>基于寄存器的架构</strong></p><p>​    寄存器是CPU上的一块缓存，存取速度比从内存中快很多</p><ul><li>编译后文件: .java -&gt; .class -&gt; .dex -&gt; .odex</li></ul><h2 id="三。Android程序结构"><a href="#三。Android程序结构" class="headerlink" title="三。Android程序结构"></a>三。Android程序结构</h2><h3 id="1-manifests"><a href="#1-manifests" class="headerlink" title="1.manifests"></a>1.manifests</h3><p>思考题：<strong>清单文件的作用功能</strong></p><p>​    存放<strong>AndroidManifest.xml</strong>文件(清单文件)，是整个项目的配置文件。四大组件都需要在这个文件中注册。</p><p>​    还可以在该文件中给程序添加权限。</p><p>​    清单文件中的配置的信息会添加到安卓系统中，程序运行时，系统会找到清单文件中的配置信息</p><h4 id="四大组件注册"><a href="#四大组件注册" class="headerlink" title="四大组件注册"></a>四大组件注册</h4><h5 id="1-activity注册方法"><a href="#1-activity注册方法" class="headerlink" title="1.activity注册方法"></a>1.activity注册方法</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">activity</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:label</span>=<span class="hljs-string">&quot;@string/app_name&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:launchMode</span>=<span class="hljs-string">&quot;singleInstance&quot;</span></span><br><span class="hljs-tag">           <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.Day21_03_SmsActivity&quot;</span> &gt;</span><br>    <br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> &gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.MAIN&quot;</span> /&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">category</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.category.LAUNCHER&quot;</span> /&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <br>   <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-BroadcastReceiver静态注册方法"><a href="#2-BroadcastReceiver静态注册方法" class="headerlink" title="2.BroadcastReceiver静态注册方法"></a>2.BroadcastReceiver静态注册方法</h5><p>​    </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.SmsReceiver&quot;</span> &gt;</span><br>    <br>        <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> &gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="3-ContentProvider注册方法"><a href="#3-ContentProvider注册方法" class="headerlink" title="3.ContentProvider注册方法"></a>3.ContentProvider注册方法</h5><p>​        </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;com.aile.provider.student&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.StudentProvider&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span>  <br><br></code></pre></td></tr></table></figure><h5 id="4-Service服务-IntentService和service注册方法"><a href="#4-Service服务-IntentService和service注册方法" class="headerlink" title="4.Service服务(IntentService和service注册方法)"></a>4.Service服务(IntentService和service注册方法)</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">service</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyService&quot;</span> &gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-java"><a href="#2-java" class="headerlink" title="2.java"></a>2.java</h3><p>​    存放所有Java代码，可以创建多个包，每个包里可以存放不同文件或者Activity</p><h3 id="3-res"><a href="#3-res" class="headerlink" title="3.res"></a>3.res</h3><p>​    存放资源。</p><ul><li>drawable目录用于存放图片以及xml文件</li><li>layout存放布局文件</li><li>mipmap存放应用程序图标</li></ul><h3 id="4-Gradle-Scripts"><a href="#4-Gradle-Scripts" class="headerlink" title="4.Gradle Scripts"></a>4.Gradle Scripts</h3><p>​    存放项目创建的相关文件，无需修改</p><hr><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1><h2 id="一。布局"><a href="#一。布局" class="headerlink" title="一。布局"></a>一。布局</h2><h3 id="1-线性布局LinearLayout"><a href="#1-线性布局LinearLayout" class="headerlink" title="1.线性布局LinearLayout"></a>1.线性布局LinearLayout</h3><h4 id="1-orientation属性"><a href="#1-orientation属性" class="headerlink" title="1)orientation属性:"></a>1)orientation属性:</h4><ul><li>控制控件的排列方向</li><li>有vertical和horizontal(默认)<ul><li>vertical为线性垂直显示</li><li>horizontal为线性布局水平显示</li></ul></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-wrap-content和match-parent"><a href="#2-wrap-content和match-parent" class="headerlink" title="2)wrap_content和match_parent"></a>2)wrap_content和match_parent</h4><ul><li>wrap_content:包括内容让当前控件<strong>根据内容大小自动伸缩</strong></li><li>match_parent:填充父窗体<strong>由父容器大小决定控件大小</strong><ul><li>水平排列时不可用</li></ul></li></ul><h4 id="3-layout-weight权重"><a href="#3-layout-weight权重" class="headerlink" title="3)layout_weight权重"></a>3)layout_weight权重</h4><ul><li>按钮1的权重值为1<ul><li>计算方法： 1/(1+1+2) = 1/4</li><li>所以按钮1占一行的1/4</li></ul></li><li>设置android:layout_width=”match_parent”后Button中的layout_width会失去作用，所以设置为0dp作为规范写法，不会影响效果</li></ul><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs applescript">&lt;LinearLayout xmlns:android=<span class="hljs-string">&quot;&quot;</span><br>android:layout_width=<span class="hljs-string">&quot;match_parent&quot;</span><br>android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>&lt;Button<br>android:<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;@+id/btn_one</span><br><span class="hljs-string">android:layout_width=&quot;</span><span class="hljs-number">0</span>dp<br>android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>android:layout_weight=<span class="hljs-string">&quot;1&quot;</span><br>android:<span class="hljs-built_in">text</span>=<span class="hljs-string">&quot;按钮1&quot;</span>&gt;<br>&lt;Button<br>android:<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;@+id/btn_two</span><br><span class="hljs-string">android:layout_width=&quot;</span><span class="hljs-number">0</span>dp<br>android:layout_height=<span class="hljs-string">&quot;wrap_content&quot;</span><br>android:layout_weight=<span class="hljs-string">&quot;1&quot;</span><br>android:<span class="hljs-built_in">text</span>=<span class="hljs-string">&quot;按钮2&quot;</span>&gt;<br>&lt;Button<br>android:<span class="hljs-built_in">id</span>=<span class="hljs-string">&quot;@+id/btn_three&quot;</span><br>android:layout_width=<span class="hljs-string">&quot;0dp</span><br><span class="hljs-string">android:layout_height=&quot;</span>wrap_content<span class="hljs-string">&quot;</span><br><span class="hljs-string">android:layout_weight=&quot;</span><span class="hljs-number">2</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">android:text=&quot;</span>按钮<span class="hljs-number">3</span><span class="hljs-string">&quot;&gt;</span><br><span class="hljs-string"></span><br><span class="hljs-string">&lt;/LinearLayout&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-相对布局RelativeLayout"><a href="#2-相对布局RelativeLayout" class="headerlink" title="2.相对布局RelativeLayout"></a>2.相对布局RelativeLayout</h3><p>​    <strong>默认采用的是相对布局</strong></p><ul><li>px: 像素</li><li>pt: 磅数</li><li>dp: 基于屏幕密度的抽象单位，不同设备希纳是效果不同</li><li>sp: 可伸缩像素</li></ul><h3 id="3-帧布局FrameLayout"><a href="#3-帧布局FrameLayout" class="headerlink" title="3.帧布局FrameLayout"></a>3.帧布局FrameLayout</h3><ul><li><p>所有控件默认显示在左上角。</p></li><li><p>按先后放入顺序重叠摆放，先放入的控件显示在最底层，后放入的控件显示在最顶层</p></li></ul><table><thead><tr><th align="center">布局属性</th><th align="center">功能</th><th align="center">属性值</th></tr></thead><tbody><tr><td align="center">android:foreground</td><td align="center">设置前景图片(始终在所有子控件之上)</td><td align="center">图片路径</td></tr><tr><td align="center">android:foregroundGravity</td><td align="center">前景图片显示位置</td><td align="center">left right center</td></tr></tbody></table><h3 id="4-表格布局TableLayout"><a href="#4-表格布局TableLayout" class="headerlink" title="4.表格布局TableLayout"></a>4.表格布局TableLayout</h3><table><thead><tr><th align="center">布局属性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">android:stretchColumns</td><td align="center">设置该列被拉伸</td></tr><tr><td align="center">android:shrinkColumns</td><td align="center">设置该列被收缩</td></tr><tr><td align="center">android:collapseColumns</td><td align="center">设置该列被隐藏</td></tr></tbody></table><ul><li>所有列号都是从“0”开始</li></ul><table><thead><tr><th align="center">控件属性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">android:layout_column</td><td align="center">设置该单元显示位置</td></tr><tr><td align="center">android:layout_span</td><td align="center">设置该单元占据几列，默认为1</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">TableLayout</span> <span class="hljs-attr">xmln:android</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:stetchColumns</span>=<span class="hljs-string">&quot;2&quot;</span>&gt;</span>   //拉伸第三列<br>        <span class="hljs-tag">&lt;<span class="hljs-name">TableRow</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_column</span>=<span class="hljs-string">&quot;0&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;按钮1&quot;</span> /&gt;</span><br>             <span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:layout_column</span>=<span class="hljs-string">&quot;1&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;按钮2&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">TableRow</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">TableLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-绝对布局AbsoluteLayout"><a href="#5-绝对布局AbsoluteLayout" class="headerlink" title="5.绝对布局AbsoluteLayout"></a>5.绝对布局AbsoluteLayout</h3><h2 id="二。常用控件"><a href="#二。常用控件" class="headerlink" title="二。常用控件"></a>二。常用控件</h2><h3 id="1-TextView"><a href="#1-TextView" class="headerlink" title="1.TextView"></a>1.TextView</h3><table><thead><tr><th align="center">控件属性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">android:text</td><td align="center"></td></tr><tr><td align="center">android:textColor</td><td align="center"></td></tr><tr><td align="center">android:textSize</td><td align="center"></td></tr><tr><td align="center">android:textStyle</td><td align="center"></td></tr><tr><td align="center">android:height</td><td align="center"></td></tr><tr><td align="center">android:width</td><td align="center"></td></tr><tr><td align="center">android:maxLength</td><td align="center"></td></tr><tr><td align="center">android:password</td><td align="center"></td></tr><tr><td align="center">android:gravity</td><td align="center">设置文本位置</td></tr></tbody></table><h4 id="layout-width、layout-height和width-、height区别"><a href="#layout-width、layout-height和width-、height区别" class="headerlink" title="layout_width、layout_height和width 、height区别"></a>layout_width、layout_height和width 、height区别</h4><p>1.</p><ul><li>对于带layout前缀属性通常是相对父控件而言</li><li>不带是相对与控件本身而言</li></ul><p>2.layout的可以单独使用，不带的不能单独使用</p><p>3.不带的只能设置为固定值</p><p>4.要使用不带的，就必须同时设置layout_width和layout_height属性</p><h3 id="2-EditText"><a href="#2-EditText" class="headerlink" title="2.EditText"></a>2.EditText</h3><table><thead><tr><th align="center">控件属性</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">android:hint</td><td align="center">没有输入内容时显示的提示文本</td></tr><tr><td align="center">android:lines</td><td align="center">固定行数决定EditText高度</td></tr><tr><td align="center">android:editable</td><td align="center">是否可编辑</td></tr><tr><td align="center">android:scrollHorizontally</td><td align="center">是否出现横拉条</td></tr></tbody></table><p>可以设置android:maxLines来设置最大行数，超过行数会显示滚动条</p><h3 id="3-Button的3种常用的点击方式"><a href="#3-Button的3种常用的点击方式" class="headerlink" title="3.Button的3种常用的点击方式"></a>3.Button的3种常用的点击方式</h3><h4 id="1-布局中指定onClick属性"><a href="#1-布局中指定onClick属性" class="headerlink" title="1.布局中指定onClick属性"></a>1.布局中指定onClick属性</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span> = <span class="hljs-string">&quot;@id/btn_one&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:text</span> = <span class="hljs-string">&quot;按钮1&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span> = <span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span> = <span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:onClick</span> = <span class="hljs-string">&quot;click&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span>  &#123;<br>    <span class="hljs-keyword">private</span> Button myBtn_one;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//初始化控件</span><br>        myBtn_one = (Button) findViewById(R.id.btn_one)<br>    &#125;<br>        <span class="hljs-comment">//实现onClick()方法，实现按钮1点击事件</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">click</span><span class="hljs-params">(View v)</span>&#123;<br>        myBtn_one.setText(<span class="hljs-string">&quot;按钮1点击&quot;</span>)<br>    &#125;<br>&#125;<br>        <br></code></pre></td></tr></table></figure><h4 id="2-使用匿名内部类"><a href="#2-使用匿名内部类" class="headerlink" title="2.使用匿名内部类"></a>2.使用匿名内部类</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span> = <span class="hljs-string">&quot;@id/btn_two&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android::text</span> = <span class="hljs-string">&quot;按钮2&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span> = <span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span> = <span class="hljs-string">&quot;wrap_content&quot;</span>  /&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> Button myBtn_two;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//初始化控件</span><br>        myBtn_two = (Button) findViewById(R.id.btn_two);<br>        <br>      <span class="hljs-comment">//匿名内部类的方法实现按钮2点击事件</span><br>            myBtn_two.setOnclickListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">View</span>.OnClickListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-comment">//重写onClick方法</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>                    myBtn_two.setText(<span class="hljs-string">&quot;按钮2点击&quot;</span>);<br>                &#125;<br>            &#125;)<br>    &#125;<br>&#125;<br>          <br></code></pre></td></tr></table></figure><h4 id="3-在当前Activity中实现OnClickListener接口"><a href="#3-在当前Activity中实现OnClickListener接口" class="headerlink" title="3.在当前Activity中实现OnClickListener接口"></a>3.在当前Activity中实现OnClickListener接口</h4><ul><li>按钮较多时使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br>    <span class="hljs-keyword">private</span> Button myBtn_two;<br>    <span class="hljs-keyword">private</span> Button myBtn_one;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//初始化控件</span><br>        myBtn_two = (Button) findViewById(R.id.btn_two);<br>      myBtn_one = (Button) findViewById(R.id.btn_one);<br>        myBtn_one.setOnClickListener(<span class="hljs-built_in">this</span>);<br>        myBtn_two.setOnClickListener(<span class="hljs-built_in">this</span>);<br>    &#125;<br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-keyword">switch</span>(v.getId() )&#123;<br>            <span class="hljs-keyword">case</span> R.id.btn_one:<br>            myBtn_one.setText(<span class="hljs-string">&quot;按钮1&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> R.id.btn_two:<br>            myBtn_two.setText(<span class="hljs-string">&quot;按钮2&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="4-RadioButton"><a href="#4-RadioButton" class="headerlink" title="4.RadioButton"></a>4.RadioButton</h3><blockquote><p>RadioGrop是单选组合框，可容纳多个RadioButton</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">RadioGroup</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/rdg&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:orientation</span>=<span class="hljs-string">&quot;vertical&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">RadioButton</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/r_btn&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;女&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">RadioButton</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">RadioButton</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;25dp&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;男&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:checked</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">RadioButton</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">RadioGroup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>checked属性：设置为true则默认选中</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">View</span>.OnClickListener &#123;<br>    <span class="hljs-keyword">private</span> RadioGroup radioGroup<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        <span class="hljs-comment">//初始化控件</span><br>        radioGroup = (RadioGroup)  findViewById(R.id.rdg);<br>        <br>      <span class="hljs-comment">//匿名内部类的方法</span><br>            radioGroup.setOnCheckChangeListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">RadioGroup</span>.OnCheckChangeListener() &#123;<br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-comment">//重写方法</span><br>                <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">OnCheckChange</span><span class="hljs-params">(RadioGroup group)</span> &#123;<br><span class="hljs-keyword">if</span>(checkedId == R.id.r_btn) &#123;<br><br>&#125;<span class="hljs-keyword">else</span> &#123;<br><br>&#125;<br>                &#125;<br>            &#125;)<br>            <br>          <br></code></pre></td></tr></table></figure><h3 id="5-消息对话框"><a href="#5-消息对话框" class="headerlink" title="5.消息对话框"></a>5.消息对话框</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scala">public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MainActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AppCompatActivity</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> void onCreate(<span class="hljs-type">Bundle</span> savedInstanceState) &#123;<br>        <span class="hljs-keyword">super</span>.onCreate(savedInstanceState);<br>        setContentView(<span class="hljs-type">R</span>.layout.activity_main);<br>        <span class="hljs-comment">//创建Toast</span><br>        <span class="hljs-type">Toast</span>.makeText(<span class="hljs-keyword">this</span> , <span class="hljs-string">&quot;Hello,Toast&quot;</span>, <span class="hljs-type">Toast</span>.<span class="hljs-type">LENGTH_SHORT</span>).show();<br><br>            &#125;)<br></code></pre></td></tr></table></figure><h2 id="三。LogCat的使用"><a href="#三。LogCat的使用" class="headerlink" title="三。LogCat的使用"></a>三。LogCat的使用</h2><p>​    Android中的命令行工具，用于获取程序成启动到关闭的日志信息。</p><h3 id="等级"><a href="#等级" class="headerlink" title="等级"></a>等级</h3><p>​    <strong>等级由低到高排</strong></p><blockquote><p>import android.util.Log</p></blockquote><p>1.Verbose     全部消息 (黑色)</p><ul><li>Log.v()</li></ul><p>2.Debug       调试信息(蓝色)</p><ul><li>Log.d()</li></ul><p>3.Info        一般信息(绿色)</p><ul><li>Log.i()</li></ul><p>4.Warning     警告信息(橙色)</p><ul><li>Log.w()</li></ul><p>5.Error           错误信息(红色)</p><ul><li>Log.e()</li></ul><p>6.Assert</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><p>1.Filter Name 过滤器的名称</p><p>2.by Log Tag 根据定义的Tag过滤，通常使用类名</p><p>3.by Log Message 根据输出内容过滤信息</p><p>4.by PID 根据进程id</p><p>5.by Application Name 根据应用名称过滤信息</p><p>6.by Log Level 根据日志的级别过滤信息</p><h2 id="四。单元测试"><a href="#四。单元测试" class="headerlink" title="四。单元测试"></a>四。单元测试</h2><p>​    单元测试是指应用程序开发过程中对最小的功能模块进行测试，可以在完成某个功能之后对该功能进行单独测试，而不需要把应用程序安装到手机或启动模拟器再对各项功能进行测试，可以提高开发效率和质量</p><blockquote><p>Android Studio在创建项目时就默认创建了一个androidTest包和ApplicationTest类，把测试的功能模块写入此类即可</p></blockquote><h3 id="进行单元测试时的步骤"><a href="#进行单元测试时的步骤" class="headerlink" title="进行单元测试时的步骤"></a>进行单元测试时的步骤</h3><h4 id="1-在ApplicationTest类中添加一个test-测试方法"><a href="#1-在ApplicationTest类中添加一个test-测试方法" class="headerlink" title="1.在ApplicationTest类中添加一个test()测试方法"></a>1.在ApplicationTest类中添加一个test()测试方法</h4><ul><li>所有测试方法必须以test开头，否则没有测试选项</li></ul><p>2.单独选择test方法进行运行查看结果</p><hr><h1 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h1><h2 id="一。Activity创建"><a href="#一。Activity创建" class="headerlink" title="一。Activity创建"></a>一。Activity创建</h2><blockquote><p>包名处右键—&gt;new—-&gt;Activity—-&gt;Empty Activity</p></blockquote><p>输入Activity Name和Layout Name、Package name</p><p>创建的activity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_shop);<br>    &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>手动注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml">在AndroidManifest.xml中添加<br><span class="hljs-tag">&lt;<span class="hljs-name">activity</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.ActivityExample&quot;</span>&gt;</span> <span class="hljs-tag">&lt;/<span class="hljs-name">activity</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="二。生命周期"><a href="#二。生命周期" class="headerlink" title="二。生命周期"></a>二。生命周期</h2><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/activity_lifecycle.png" alt="img"></p><h3 id="1-生命周期状态"><a href="#1-生命周期状态" class="headerlink" title="1.生命周期状态"></a>1.生命周期状态</h3><blockquote><p>onCreate() —&gt; onStart() —&gt; onResume() —&gt; onPause() —&gt; onStop() —&gt; onDestroy()</p></blockquote><p>1）启动状态</p><p>2）运行状态</p><p>3）暂停状态</p><p>4）停止状态</p><p>5）销毁状态</p><h3 id="2-生命周期方法"><a href="#2-生命周期方法" class="headerlink" title="2.生命周期方法"></a>2.生命周期方法</h3><h4 id="1-onCreate-方法"><a href="#1-onCreate-方法" class="headerlink" title="1.onCreate()方法"></a>1.onCreate()方法</h4><blockquote><p>创建时调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br><span class="hljs-built_in">super</span>.onCreate(saveInstanceState);<br>setContentView(R.layout.activity_main);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-onStart-方法"><a href="#2-onStart-方法" class="headerlink" title="2.onStart()方法"></a>2.onStart()方法</h4><blockquote><p>在Activity即将可见时调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStart</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onStart();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-onResume-方法"><a href="#3-onResume-方法" class="headerlink" title="3.onResume()方法"></a>3.onResume()方法</h4><blockquote><p>在Activity<strong>获取焦点</strong>开始与用户交互时调用</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onResume</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onResume();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-onPause-方法"><a href="#4-onPause-方法" class="headerlink" title="4.onPause()方法"></a>4.onPause()方法</h4><blockquote><p>当前Activity被<strong>其他Activity覆盖或锁屏时调用</strong></p><p>当执行到onPause()方法失去焦点 , 重新回到前台会执行onResume()方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onPause</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onPause();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-onStop-方法"><a href="#5-onStop-方法" class="headerlink" title="5.onStop()方法"></a>5.onStop()方法</h4><blockquote><p>Activity对用户不可见时</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onStop</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onStop();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-onDestroy-方法"><a href="#6-onDestroy-方法" class="headerlink" title="6.onDestroy()方法"></a>6.onDestroy()方法</h4><blockquote><p>Activity销毁</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br><span class="hljs-built_in">super</span>.onDestroy();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-onRestart-方法"><a href="#7-onRestart-方法" class="headerlink" title="7.onRestart()方法"></a>7.onRestart()方法</h4><blockquote><p>Activity从停止状态再次启动</p></blockquote><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">onRestart</span>(<span class="hljs-params"></span>) &#123;<br><span class="hljs-variable language_">super</span>.<span class="hljs-title function_">onRestart</span>();<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="三。Activity之间的跳转"><a href="#三。Activity之间的跳转" class="headerlink" title="三。Activity之间的跳转"></a>三。Activity之间的跳转</h2><p>​    Intent称为意图，是程序中各组件进行交互的一种重要方式，不仅可以将指定当前组件要执行的动作，还可以在不同组件之间进行数据传递。一般用于启动Activity、Service以及发送广播等</p><h3 id="1-打开浏览器"><a href="#1-打开浏览器" class="headerlink" title="1.打开浏览器"></a>1.打开浏览器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onClick</span><span class="hljs-params">(View v)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        intent.setAction(<span class="hljs-string">&quot;android.intent.action.VIEW&quot;</span>);<br>        intent.setData(Uri.parse(<span class="hljs-string">&quot;http://www.baidu.com&quot;</span>));<br>        startActivity(intent);<br></code></pre></td></tr></table></figure><h3 id="2-数据传递"><a href="#2-数据传递" class="headerlink" title="2.数据传递"></a>2.数据传递</h3><blockquote><p>将要传递的数据暂存到Intent中，启动另外一个Activity后从Intent中取出数据即可</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//传递数据</span><br><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,Activity.class);<br>intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);  <span class="hljs-comment">//第一个参数为name，第二个参数为value</span><br>startActivity(intent);<br><br><span class="hljs-comment">//Activity中取数据</span><br><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> getIntent();<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> intent.getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-数据回传"><a href="#3-数据回传" class="headerlink" title="3.数据回传"></a>3.数据回传</h3><blockquote><p>startActivityForResult(Intent intent,int requestCode)</p><p>setResult(int resultCode,Intent data)方法</p><p>不过现在已经弃用</p><p>代替为registerForActivityResult()</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java">Activity01中<br><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>(<span class="hljs-built_in">this</span>,Activity02.class);<br>startActivityForResult(intent,<span class="hljs-number">1</span>)  <span class="hljs-comment">//第一个参数是Intent对象，第二个参数是请求码，输入一个唯一值即可</span><br><br><br>Activity02中返回数据<br><br><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>intent.putExtra(<span class="hljs-string">&quot;extra_data&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>); <br>setResult(<span class="hljs-number">1</span>,intent);  <span class="hljs-comment">//第一个参数用于向Activity返回处理结果，一般使用0或1</span><br><br><br>Activity02被销毁时会回调Activity01的onActivityResult()方法，Activity01中需要重写一下接收数据<br><br><span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onActivityResult</span><span class="hljs-params">(<span class="hljs-type">int</span> requestCode,<span class="hljs-type">int</span> resultCode,Intent data)</span>&#123;<br>        <span class="hljs-built_in">super</span>.onActivityResult(requestCode,resultCode,data);<br>        <span class="hljs-keyword">if</span> (requestCode == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (resultCode == <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">string</span> <span class="hljs-operator">=</span> data.getStringExtra(<span class="hljs-string">&quot;extra_data&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h1><h2 id="一。五种存储方式"><a href="#一。五种存储方式" class="headerlink" title="一。五种存储方式"></a>一。五种存储方式</h2><h3 id="1-文件存储"><a href="#1-文件存储" class="headerlink" title="1.文件存储"></a>1.文件存储</h3><p>​    读取/写入文件，通过openFileInput()和openFileOutput()方法读取设备上的文件。与Java中实现I/O程序一致</p><p>存储位置</p><ul><li>默认存储在 data/data/<packagename>/files/ 目录下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">FileOutputStream</span> <span class="hljs-variable">fos</span> <span class="hljs-operator">=</span> openFileOutput(String name,<span class="hljs-type">int</span> mode);  <span class="hljs-comment">//输出流</span><br><span class="hljs-type">FileInputStream</span> <span class="hljs-variable">fis</span> <span class="hljs-operator">=</span> openFileInput(String name);  <span class="hljs-comment">//输入流</span><br></code></pre></td></tr></table></figure><ul><li>“name” 表示文件名</li><li>“mode” 表示文件的操作模式<ul><li>MODE_PRIVATE: 文件只能被当前程序读写<ul><li>默认模式</li></ul></li><li>MODE_APPEND: 文件内容可以追加</li><li>MODE_WORLD_READABLE: 文件的内容可以被其他程序读</li><li>MODE_WORLD_WRITEABLE: 文件的内容可以被其他程序写</li></ul></li></ul><p>数据存储到文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">name</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;data.txt&quot;</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;hello&quot;</span>;<br>        FileOutputStream fos;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fos = openFileOutput(name,MODE_PRIVATE);<br>            fos.write(data.getBytes());;<br>            fos.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure><p>数据读取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">content</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;&quot;</span>;<br>        FileInputStream fis;<br>        <span class="hljs-keyword">try</span> &#123;<br>            fis = openFileInput(<span class="hljs-string">&quot;data.txt&quot;</span>);<br>            <span class="hljs-type">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[fis.available()]; <span class="hljs-comment">//创建缓冲区，获取文件长度</span><br>            fis.read(buffer);  <span class="hljs-comment">//内容读入buffer缓冲区</span><br>            content = <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(buffer) <span class="hljs-comment">//转换成字符串</span><br>            fis.close();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br></code></pre></td></tr></table></figure><h3 id="2-SharedPreferences"><a href="#2-SharedPreferences" class="headerlink" title="2.SharedPreferences"></a>2.SharedPreferences</h3><p>​    用XML格式将数据存储到设备中，可以存储应用程序的各种配置信息(用户名、密码等)</p><h4 id="存储位置"><a href="#存储位置" class="headerlink" title="存储位置"></a><strong>存储位置</strong></h4><ul><li>data/data/<packagename>/shared_prefs文件夹中</li></ul><h4 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a><strong>存储方式</strong></h4><ul><li>通过key/value(键值对)的形式将数据保存在XML文件中</li><li>value值的类型只能是Float,Int,Long,Boolean,String,StringSet类型数据</li></ul><h4 id="1-存储数据"><a href="#1-存储数据" class="headerlink" title="1.存储数据"></a><strong>1.存储数据</strong></h4><blockquote><p>1.调用getSharedPreferences(String name,int mode)方法获取实例对象</p><p>2.调用SharedPreferences的edit方法获取到可编辑的Editor对象</p><p>3.通过putString(),putInt()方法存储数据</p><p>4.通过commit()方法提交数据</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;data&quot;</span>,MODE_PRIVATE);<br>SharedPreferences.<span class="hljs-type">Editor</span> <span class="hljs-variable">editor</span> <span class="hljs-operator">=</span> sp.edit();<br>editor.putString(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;hello&quot;</span>);<br>editor.putInt(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">9</span>);<br>editor.commit(); <span class="hljs-comment">//提交</span><br><br><span class="hljs-comment">//删除数据</span><br>editor.remove(<span class="hljs-string">&quot;name&quot;</span>); <span class="hljs-comment">//删除一条数据</span><br>editor.clear(); <span class="hljs-comment">//删除所有数据</span><br></code></pre></td></tr></table></figure><h4 id="2-获取数据"><a href="#2-获取数据" class="headerlink" title="2.获取数据"></a>2.获取数据</h4><blockquote><p>1.获取SharedPreferences对象</p><p>2.通过getxxx()方法获取到对应的key值</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> getSharedPreferences(<span class="hljs-string">&quot;data&quot;</span>,MODE_PRIVATE);<br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span>getSring(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;&quot;</span>) <span class="hljs-comment">//第二个参数为缺省值，如果name不存在，则返回空字符串</span><br></code></pre></td></tr></table></figure><h3 id="3-SQLite数据库"><a href="#3-SQLite数据库" class="headerlink" title="3.SQLite数据库"></a>3.SQLite数据库</h3><p>​    Android自带的一个轻量级数据库，支持基本SQL语法，一般使用它作为复杂数据的存储引擎。</p><p>​    <strong>详细见第五章</strong></p><h3 id="4-ContentProvider"><a href="#4-ContentProvider" class="headerlink" title="4.ContentProvider"></a>4.ContentProvider</h3><p>​    四大组件之一，主要用于<strong>应用程序之间的数据交换</strong>，可以将自己的数据共享给其他应用程序使用</p><h3 id="5-网络存储"><a href="#5-网络存储" class="headerlink" title="5.网络存储"></a>5.网络存储</h3><p>​    将数据存储在服务器上</p><h3 id="二。XML解析"><a href="#二。XML解析" class="headerlink" title="二。XML解析"></a>二。XML解析</h3><h5 id="1-DOM解析"><a href="#1-DOM解析" class="headerlink" title="1.DOM解析"></a>1.DOM解析</h5><h5 id="2-SAX解析"><a href="#2-SAX解析" class="headerlink" title="2.SAX解析"></a>2.SAX解析</h5><h5 id="3-PULL解析"><a href="#3-PULL解析" class="headerlink" title="3.PULL解析"></a>3.PULL解析</h5><h3 id="三。JSON解析"><a href="#三。JSON解析" class="headerlink" title="三。JSON解析"></a>三。JSON解析</h3><hr><h1 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h1><h2 id="考编程题查询数据并展示在listview中"><a href="#考编程题查询数据并展示在listview中" class="headerlink" title="考编程题查询数据并展示在listview中"></a>考编程题查询数据并展示在listview中</h2><blockquote><p>看p138的绿豆通讯录</p></blockquote><h2 id="一。数据库的创建"><a href="#一。数据库的创建" class="headerlink" title="一。数据库的创建"></a>一。数据库的创建</h2><blockquote><p>1.创建一个类继承SQLiteOpenHelper</p><p>2.重写onCreate()和onUpgrade()方法</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyHelper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">SQLiteOpenHelper</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyHelper</span><span class="hljs-params">(Context context)</span> &#123;<br>        <span class="hljs-built_in">super</span>(context, <span class="hljs-string">&quot;ahao&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-number">2</span>);<br>        <span class="hljs-comment">//上下文对象 数据库名称 游标工厂(通常为null) 数据库版本</span><br>    &#125;<br>    <span class="hljs-comment">//数据库第一次创建时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(SQLiteDatabase db)</span> &#123;<br>        <span class="hljs-comment">//初始化数据库的库结构</span><br>        db.execSQL(<span class="hljs-string">&quot;CREATE TABLE information(_id INTEGER PRIMARY KEY AUTOINCREMENT,name VARCHAR(20), price Integer)&quot;</span>);<br>        <span class="hljs-comment">//表名为information,数值_id,name,price</span><br>    &#125;<br>        <span class="hljs-comment">//数据库的版本号增加时调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onUpgrade</span><span class="hljs-params">(SQLiteDatabase db,<span class="hljs-type">int</span> oldVersion,<span class="hljs-type">int</span> newVersion)</span> &#123;<br>        <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="二。增删改查"><a href="#二。增删改查" class="headerlink" title="二。增删改查"></a>二。增删改查</h2><h3 id="1-增加数据"><a href="#1-增加数据" class="headerlink" title="1.增加数据"></a>1.增加数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(String name,String price)</span> &#123;<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();  <span class="hljs-comment">//获取可读写SQLiteDatabase对象</span><br>    <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();  <span class="hljs-comment">//创建 ContentValues 对象</span><br>    values.put(<span class="hljs-string">&quot;name&quot;</span>,name);    <span class="hljs-comment">//添加数据到 ContentValues对象</span><br>    values.put(<span class="hljs-string">&quot;price&quot;</span>,price);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">id</span> <span class="hljs-operator">=</span> db.insert(<span class="hljs-string">&quot;information&quot;</span>,<span class="hljs-literal">null</span>,values);  <span class="hljs-comment">//插入一条数据到information表</span><br>    <span class="hljs-comment">// 第一个参数是表名 第二个参数是要插入的行为空行时，将这个列名的值设为null 第三个参数为 ContentValues 对象 通过键值对的形式存入数据</span><br>    db.close();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-修改数据"><a href="#2-修改数据" class="headerlink" title="2.修改数据"></a>2.修改数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">update</span><span class="hljs-params">(String name, String price)</span> &#123;<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br>    <span class="hljs-type">ContentValues</span> <span class="hljs-variable">values</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ContentValues</span>();<br>    values.put(<span class="hljs-string">&quot;price&quot;</span>,price);<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> db.update(<span class="hljs-string">&quot;information&quot;</span>,values,<span class="hljs-string">&quot;name=?&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;name&#125;);<br>    <span class="hljs-comment">//第一个参数表示表名，第二个参数接收一个ContentValues对象 第三个参数为可选的where语句， 第四个参数表示whereClause语句中表达式的占位参数列表，会替换where中的&quot;?&quot;</span><br>    db.close();<br>    <span class="hljs-keyword">return</span> number;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-删除数据"><a href="#3-删除数据" class="headerlink" title="3.删除数据"></a>3.删除数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">delete</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> db.delete(<span class="hljs-string">&quot;information&quot;</span>,<span class="hljs-string">&quot;_id=?&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;id+<span class="hljs-string">&quot;&quot;</span>&#125;);<br>    db.close();<br>    <span class="hljs-keyword">return</span>  number;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4.查询数据"></a>4.查询数据</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">find</span><span class="hljs-params">(<span class="hljs-type">long</span> id)</span> &#123;<br>    <span class="hljs-type">SQLiteDatabase</span> <span class="hljs-variable">db</span> <span class="hljs-operator">=</span> helper.getWritableDatabase();<br>    <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.query(<span class="hljs-string">&quot;information&quot;</span>,<span class="hljs-literal">null</span>,<span class="hljs-string">&quot;_id=?&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;id+<span class="hljs-string">&quot;&quot;</span>&#125;,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br>   <span class="hljs-comment">// 第一个参数表示表名称 </span><br>  <span class="hljs-comment">// 第二个参数表示查询的列名 </span><br>  <span class="hljs-comment">// 第三个参数表示接收查询条件子句 </span><br>  <span class="hljs-comment">//第四个参数接收查询子句对应的条件值 </span><br>  <span class="hljs-comment">//第五个参数表示分组方式   第六个参数表示接收having条件(定义组的过滤器)   第七个参数表示排序方式</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> cursor.moveToNext();<br>    cursor.close();  <span class="hljs-comment">//关闭游标</span><br>    db.close();<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用execSQL-方法操作"><a href="#使用execSQL-方法操作" class="headerlink" title="使用execSQL()方法操作"></a>使用execSQL()方法操作</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//插入</span><br>db.execSQL(<span class="hljs-string">&quot;insert into information (name,price) values (?,?)&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;name,price&#125;);<br><span class="hljs-comment">//修改</span><br>db.execSQL(<span class="hljs-string">&quot;update information set name=? where price =?&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[]&#123;name,price&#125;);<br><span class="hljs-comment">//删除</span><br>db.execSQL(<span class="hljs-string">&quot;delete from information where _id = 1&quot;</span>);<br><span class="hljs-comment">//查询</span><br><span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> db.rawQuery(<span class="hljs-string">&quot;select * from person where name=?&quot;</span>,<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[]&#123;name&#125;);<br></code></pre></td></tr></table></figure><h2 id="三。SQLite中的事务"><a href="#三。SQLite中的事务" class="headerlink" title="三。SQLite中的事务"></a>三。SQLite中的事务</h2><blockquote><p>事务时一个对数据库执行工作的单元，是针对数据库的一组操作，可以由一条或多条SQL语句构成。</p><p>事务是以逻辑顺序完成的工作单位或序列，可以由用户手动操作完成，也可以由某种数据库程序自动完成</p><p>同一事务的操作具备同步的特点，一条语句无法执行，所有语句都不会执行</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">db.beginTransaction();  <span class="hljs-comment">//开始事务</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            db.execSQL();<br>            db.setTransactionSuccessful();<span class="hljs-comment">//标志事务执行完成</span><br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            Log.i(<span class="hljs-string">&quot;处理失败&quot;</span>,e.toString());<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            db.endTransaction(); <span class="hljs-comment">//关闭事务</span><br>            db.close();<br>        &#125;<br><br></code></pre></td></tr></table></figure><ul><li>当执行到endTransaction()方法时，首先会检查是否有事务执行完成标记，有则提交数据，无则回滚数据</li></ul><h2 id="四。ListView控件"><a href="#四。ListView控件" class="headerlink" title="四。ListView控件"></a>四。ListView控件</h2><blockquote><p>ListView是一个列表视图，由很多Item(条目)组成，每个Item的布局时相同的，Item布局单独使用一个XML定义</p></blockquote><h3 id="1-数据适配器"><a href="#1-数据适配器" class="headerlink" title="1.数据适配器"></a>1.数据适配器</h3><h4 id="1）BaseAdapter"><a href="#1）BaseAdapter" class="headerlink" title="1）BaseAdapter"></a>1）BaseAdapter</h4><p>​    基本的适配器，实际上是一个抽象类，通常在使用自定义适配器时需要继承BaseAdapter。有四个抽象方法</p><table><thead><tr><th align="center">方法</th><th align="center">功能描述</th></tr></thead><tbody><tr><td align="center">public int getCount()</td><td align="center">得到Item条目的总数</td></tr><tr><td align="center">public Object getItem(int position)</td><td align="center">根据position(位置)得到某个Item的对象</td></tr><tr><td align="center">public long getItemId(int postion)</td><td align="center">根据position得到某个Item的id</td></tr><tr><td align="center">public View getView(int position, View converView, ViewGroup parent)</td><td align="center">得到相应position对应的Item视图，position是当前Item的位置，converView用于复用旧视图，parent用于加载XML布局</td></tr></tbody></table><h4 id="2）SimpleAdapter"><a href="#2）SimpleAdapter" class="headerlink" title="2）SimpleAdapter"></a>2）SimpleAdapter</h4><p>​    继承自BaseAdapter,实现对四个抽象方法进行了封装。使用SimpleAdapter进行数据适配时，只需要在构造方法中传入相应的参数即可</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public <span class="hljs-constructor">SimpleAdapter(Context <span class="hljs-params">context</span>, List&lt;? <span class="hljs-params">extends</span> Map&lt;String,?&gt;&gt; <span class="hljs-params">data</span>, <span class="hljs-params">int</span> <span class="hljs-params">resource</span>, String[] <span class="hljs-params">from</span>,<span class="hljs-params">int</span>[] <span class="hljs-params">to</span>)</span>;<br></code></pre></td></tr></table></figure><ul><li>Context context: Context上下文对象</li><li>List<? extends Map<String,?>&gt; data: 数据集合，data中每一项对应ListView中每一项数据</li><li>int resource: Item布局的资源id</li><li>String[] from: Map集合里面的key值</li><li>int[] to: Item布局相应的控件id</li></ul><h4 id="3）ArrayAdapter"><a href="#3）ArrayAdapter" class="headerlink" title="3）ArrayAdapter"></a>3）ArrayAdapter</h4><p>​    BaseAdapter的子类，只需要在构造方法中传入相应参数即可。通常用于设配TextView控件。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>activity_main.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">RelativeLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">xmlns:tools</span>=<span class="hljs-string">&quot;http://schemas.android.com/tools&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">tools:context</span>=<span class="hljs-string">&quot;.ShopFragment&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ListView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/list_view&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_below</span>=<span class="hljs-string">&quot;@id/shop_image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:divider</span>=<span class="hljs-string">&quot;#d0d0d0&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:dividerHeight</span>=<span class="hljs-string">&quot;1dp&quot;</span> /&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">RelativeLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>item.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">LinearLayout</span> <span class="hljs-attr">xmlns:android</span>=<span class="hljs-string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;match_parent&quot;</span></span><br><span class="hljs-tag">    <span class="hljs-attr">android:gravity</span>=<span class="hljs-string">&quot;center_vertical&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">ImageView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;48dp&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/image&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:background</span>=<span class="hljs-string">&quot;@drawable/shop&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">ImageView</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">TextView</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@+id/item_tv&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;wrap_content&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:text</span>=<span class="hljs-string">&quot;我的item布局&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:textSize</span>=<span class="hljs-string">&quot;18sp&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">TextView</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">LinearLayout</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MainActivity.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ShopActivity</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AppCompatActivity</span> &#123;<br>    <span class="hljs-keyword">private</span> ListView listView;<br>    <span class="hljs-keyword">private</span> String[] name = &#123;<span class="hljs-string">&quot;京东&quot;</span>, <span class="hljs-string">&quot;pdd&quot;</span>&#125;;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span>[] icons = &#123;R.drawable.apple,&#125;;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_shop);<br><br><span class="hljs-comment">//设置ListView</span><br>        <span class="hljs-comment">//1、绑定控件</span><br>        <span class="hljs-type">ListView</span> <span class="hljs-variable">listView</span> <span class="hljs-operator">=</span> (ListView) findViewById(R.id.list_view);<br>        <span class="hljs-comment">//2.创建一个Adapter实例</span><br>        <span class="hljs-type">MyBaseAdapter</span> <span class="hljs-variable">myBaseAdapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBaseAdapter</span>();<br>        <span class="hljs-comment">//设置Adapter</span><br>        listView.setAdapter(myBaseAdapter);<br>    &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBaseAdapter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BaseAdapter</span> &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getCount</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> name.length;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getItem</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> &#123;<br>            <span class="hljs-keyword">return</span> name[position];<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-type">long</span> <span class="hljs-title function_">getItemId</span><span class="hljs-params">(<span class="hljs-type">int</span> position)</span> &#123;<br>            <span class="hljs-keyword">return</span> position;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> View <span class="hljs-title function_">getView</span><span class="hljs-params">(<span class="hljs-type">int</span> position, View convertView, ViewGroup parent)</span> &#123;<br>            <span class="hljs-type">View</span> <span class="hljs-variable">view</span> <span class="hljs-operator">=</span> View.inflate(MainActivity.<span class="hljs-built_in">this</span>, R.layout.item, <span class="hljs-literal">null</span>);   <span class="hljs-comment">//从item.xml中找到并转换成View对象</span><br>            <span class="hljs-type">TextView</span> <span class="hljs-variable">textView</span> <span class="hljs-operator">=</span> (TextView) findViewById(R.id.item_tv);<br>            textView.setText(name[position]);<br>            <span class="hljs-type">ImageView</span> <span class="hljs-variable">image</span> <span class="hljs-operator">=</span> (ImageView) findViewById(R.id.shop_image);<br>            image.setBackground(icons[position]);<br>            <span class="hljs-keyword">return</span> view;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><hr><h1 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h1><blockquote><p>当产生一个广播事件时，可以有多个BroadcastReceiver 接收并处理数据。</p><p>广播接收者只需要在清单文件或代码中进行注册并指定要接收的广播事件，创建一个类继承自BroadcastReceiver类，重写onReceive()方法，在方法中处理广播事件即可</p></blockquote><h2 id="一。基础"><a href="#一。基础" class="headerlink" title="一。基础"></a>一。基础</h2><h3 id="1-创建"><a href="#1-创建" class="headerlink" title="1.创建"></a>1.创建</h3><p>new —-&gt; other —-&gt; Broadcast Receiver</p><h4 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h4><h5 id="1）静态注册"><a href="#1）静态注册" class="headerlink" title="1）静态注册"></a>1）静态注册</h5><p>AndroidMainfest.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyReceiver&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:enable</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><p>MyReceiver.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceivver</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyReceier</span><span class="hljs-params">()</span> &#123;<br>        <br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        <span class="hljs-comment">//用于实现广播接收者的相关操作</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2）动态注册"><a href="#2）动态注册" class="headerlink" title="2）动态注册"></a>2）动态注册</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_shop);<br>        <span class="hljs-comment">//实例化广播接收者</span><br>        <span class="hljs-type">MyReceiver</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyReceiver</span>();<br>        <span class="hljs-comment">//实例化过滤器并设置要过滤的广播</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">action</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;android.provider.Telephony.SMS_RECEIVED&quot;</span>;<br>        <span class="hljs-type">IntentFilter</span> <span class="hljs-variable">intentFilter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IntentFilter</span>(action);<br>        <span class="hljs-comment">//注册广播</span><br>        registerReceiver(receiver, intentFilter);<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onDestroy</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>.onDestroy();<br>        <span class="hljs-comment">//Activity销毁时取消注册BroadcastReceiver</span><br>        unregisterReceiver(receiver);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-拦截电话案例"><a href="#2-拦截电话案例" class="headerlink" title="2.拦截电话案例"></a>2.拦截电话案例</h3><h5 id="广播接收者OutCallReceiver"><a href="#广播接收者OutCallReceiver" class="headerlink" title="广播接收者OutCallReceiver"></a>广播接收者OutCallReceiver</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">OutCallReceiver</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>        <span class="hljs-comment">//获取拨打的电话号码</span><br>        <span class="hljs-type">String</span> <span class="hljs-variable">number</span> <span class="hljs-operator">=</span> getResultData();<br>        <span class="hljs-comment">//创建SharedPreferences对象，拦截号码</span><br>        <span class="hljs-type">SharedPreferences</span> <span class="hljs-variable">sp</span> <span class="hljs-operator">=</span> context.getSharedPreferences(<span class="hljs-string">&quot;config&quot;</span>,Context.MODE_PRIVATE);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">number2</span> <span class="hljs-operator">=</span> sp.getString(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;&quot;</span>);<br>        <span class="hljs-keyword">if</span>(number.equals(number2))&#123;<br>            <span class="hljs-comment">//清除电话</span><br>            setResultData(<span class="hljs-literal">null</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            .................<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>AndroidManifest.xml中添加权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.OutCallReceiver&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;android.intent.action.NEW_OUTGOING_CALL&quot;</span>/&gt;</span> //权限<br><span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="二-广播类型"><a href="#二-广播类型" class="headerlink" title="二.广播类型"></a>二.广播类型</h2><h3 id="1-有序广播"><a href="#1-有序广播" class="headerlink" title="1.有序广播"></a>1.有序广播</h3><blockquote><p>可以被拦截</p></blockquote><p>​    按照接收者声明的优先级别依次接收，发送广播时，只有一个广播接收者能够接收此消息，当此广播接收者中逻辑执行完毕后，广播才会继续传递。</p><hr><h4 id="优先级设置"><a href="#优先级设置" class="headerlink" title="优先级设置"></a>优先级设置</h4><ul><li>在注册广播接收者时，在<intent-filter>标签中使用priority属性设置优先级</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>属性值越大，优先级越高</li><li>优先级相同时，先注册的优先级高</li></ul><h3 id="2-无序广播"><a href="#2-无序广播" class="headerlink" title="2.无序广播"></a>2.无序广播</h3><p>​    完全异步执行，发送广播时，所有监听这个广播的广播接收者都会接收到此广播消息，但接收和执行的顺序不确定</p><h3 id="拦截广播案例"><a href="#拦截广播案例" class="headerlink" title="拦截广播案例"></a>拦截广播案例</h3><p>发送有序广播</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>  <span class="hljs-title function_">send</span><span class="hljs-params">(View view)</span> &#123;<br>        <span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        <span class="hljs-comment">//定义广播的事件类型</span><br>        intent.setAction(<span class="hljs-string">&quot;Intercept_Stitch&quot;</span>);<br>        <span class="hljs-comment">//发送广播</span><br>        sendOrderedBroadcast(intent,<span class="hljs-literal">null</span>);<br>    <br>    <span class="hljs-comment">//第二个参数指定接收者的权限</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>添加广播接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBroadcastReceiverOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>Log.i(<span class="hljs-string">&quot;广播接收者1接收到广播事件&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册广播接收者</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">receiver</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyBroadReceiverTwo&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">intent-filter</span> <span class="hljs-attr">android:priority</span>=<span class="hljs-string">&quot;1000&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">action</span> <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;Intercept_Stitch&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">action</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">intent-filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">receiver</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拦截有序广播</p><blockquote><p>优先级高的广播接收者可以拦截收到的广播</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBroadcastReceiverOne</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">BroadcastReceiver</span> &#123;<br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onReceive</span><span class="hljs-params">(Context context, Intent intent)</span> &#123;<br>Log.i(<span class="hljs-string">&quot;广播接收者1接收到广播事件&quot;</span>)<br>              abortBroadcast() <span class="hljs-comment">//比这个广播接收者优先级低的广播接收者都会被拦截</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指定广播接收者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">Intent</span> <span class="hljs-variable">intent</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Intent</span>();<br>        <span class="hljs-comment">//定义广播的事件类型</span><br>        intent.setAction(<span class="hljs-string">&quot;Intercept_Stitch&quot;</span>);<br>        <span class="hljs-comment">//发送有序广播</span><br>        <span class="hljs-type">MyBroadcastReceiverThree</span> <span class="hljs-variable">receiver</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBroadcastReceiverThree</span><br>        sendOrderedBroadcast(intent,<span class="hljs-literal">null</span>,receiver,<span class="hljs-literal">null</span>,<span class="hljs-number">0</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure><hr><h1 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h1><blockquote><p>Service(服务)是一个长期运行在后台的用户组件，没有用户界面。因此服务更适合执行一段事件而又不需要显示界面的后台操作(下载数据、播放音乐等)</p></blockquote><h2 id="一。创建"><a href="#一。创建" class="headerlink" title="一。创建"></a>一。创建</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Service</span> &#123;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">MyService</span><span class="hljs-params">()</span> &#123;<br><br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> IBinder <span class="hljs-title function_">onBind</span><span class="hljs-params">(Intent intent)</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>默认包含一个构造方法和一个onBind()方法</li><li>onBind()用于绑定服务，放回一个IBinder对象</li></ul><p>注册</p><blockquote><p>name中填的是服务的路径</p><p>enabled:是否实例化该组件</p><p>exported:该服务是否能够被其他应用程序调用或交互</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>.........<br>    <span class="hljs-tag">&lt;<span class="hljs-name">service</span> </span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyService&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">service</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br><br></code></pre></td></tr></table></figure><h2 id="二。生命周期-1"><a href="#二。生命周期-1" class="headerlink" title="二。生命周期"></a>二。生命周期</h2><p>​    服务的启动方式有两种，分别是**startService()<strong>方法和</strong>bindService()**方法</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/3ec6534aeaecba1eb2c6ba09f1abe6bb.png" alt="image.png"></p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><strong>onCreate()</strong>:第一次创建服务时执行</li><li><strong>onDestory()</strong>:服务被销毁时执行</li><li><strong>onStartCommand()</strong>: 通过startService()方式启动服务</li><li><strong>onBind()</strong>: 通过bindService()方法启动服务</li><li><strong>onUnbind()</strong>: 客户端调用unBindService()断开服务器绑定时执行</li></ul><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><h4 id="1-startService-方式"><a href="#1-startService-方式" class="headerlink" title="1.startService 方式"></a>1.startService 方式</h4><h2 id="三。服务的通信"><a href="#三。服务的通信" class="headerlink" title="三。服务的通信"></a>三。服务的通信</h2><blockquote><p>通过<strong>绑定方式</strong>开启服务后，服务与Activity可以通信。</p><p>必须保证服务是以绑定方式开启的，否转无法进行通信和数据交换。</p></blockquote><h4 id="1-本地服务通信"><a href="#1-本地服务通信" class="headerlink" title="1.本地服务通信"></a>1.本地服务通信</h4><blockquote><p>应用程序内部的通信</p></blockquote><h4 id="2-远程服务通信"><a href="#2-远程服务通信" class="headerlink" title="2.远程服务通信"></a>2.远程服务通信</h4><blockquote><p>两个应用程序之间的通信</p></blockquote><h4 id="注意看p175"><a href="#注意看p175" class="headerlink" title="注意看p175"></a>注意看p175</h4><hr><h1 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h1><h2 id="一。简介"><a href="#一。简介" class="headerlink" title="一。简介"></a>一。简介</h2><p>​    ContentProvicer内容提供者是四大组件之一，功能是在<strong>不同程序之间实现数据共享</strong>。</p><ul><li>文件存储、SharePreferences存储、数据库存储这些只能在当前应用程序中访问</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/20200512141503209.png" alt="【Android】第十二周、内容提供者（ContentProvider）_内容提供者的工作原理__popo_的博客-CSDN博客"></p><ul><li>要访问ContentProvider中共享的数据，一定要借助ContentProvider类</li></ul><h3 id="Uri"><a href="#Uri" class="headerlink" title="Uri"></a>Uri</h3><blockquote><p>为内容提供者的数据建立了唯一的标识符。主要由<strong>scheme、authoritied和path</strong>三部分组成</p></blockquote><h4 id="scheme"><a href="#scheme" class="headerlink" title="scheme:"></a>scheme:</h4><ul><li>“content://“ 是一个标准前缀，表明这个数据被ContentProvider所控制</li></ul><h4 id="authority"><a href="#authority" class="headerlink" title="authority:"></a>authority:</h4><ul><li>在创建内容提供者时指定的authorities属性值，用于区分不同的应用程序</li><li>一般采用程序包名命名</li></ul><h4 id="path"><a href="#path" class="headerlink" title="path:"></a>path:</h4><ul><li>代表资源(数据)</li></ul><h2 id="二。内容提供者的创建"><a href="#二。内容提供者的创建" class="headerlink" title="二。内容提供者的创建"></a>二。内容提供者的创建</h2><p>增删改查</p><ul><li>insert()</li><li>delete()</li><li>update()</li><li>query()</li></ul><h4 id="注册-1"><a href="#注册-1" class="headerlink" title="注册"></a>注册</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">application</span>&gt;</span><br>...<br>    <span class="hljs-tag">&lt;<span class="hljs-name">provider</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:authorities</span>=<span class="hljs-string">&quot;cn.app&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;.MyContentProvider&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:enabled</span>=<span class="hljs-string">&quot;true&quot;</span></span><br><span class="hljs-tag">            <span class="hljs-attr">android:exported</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">provider</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">application</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="三。使用"><a href="#三。使用" class="headerlink" title="三。使用"></a>三。使用</h2><h3 id="1-访问内容提供者"><a href="#1-访问内容提供者" class="headerlink" title="1.访问内容提供者"></a>1.访问内容提供者</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">       <span class="hljs-comment">//获取相应操作的Uri</span><br><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(<span class="hljs-string">&quot;content://cn.app/person&quot;</span>);<br><span class="hljs-comment">//获取到ContentResolver对象</span><br><span class="hljs-type">ContentResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> context.getContentResolver();<br><br>       <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> resolver.query(uri, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>&#125;,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)<br>        <br>       <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> cursor.getString(<span class="hljs-number">0</span>);<br>           <span class="hljs-type">long</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cursor.getLong(<span class="hljs-number">1</span>);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> cursor.getInt(<span class="hljs-number">2</span>);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> cursor.getString(<span class="hljs-number">3</span>);<br>       &#125;<br></code></pre></td></tr></table></figure><h3 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">       <span class="hljs-comment">//获取短信操作的Uri</span><br><span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(<span class="hljs-string">&quot;content://sms/&quot;</span>);<br><span class="hljs-comment">//获取到ContentResolver对象</span><br><span class="hljs-type">ContentResolver</span> <span class="hljs-variable">resolver</span> <span class="hljs-operator">=</span> context.getContentResolver();<br><br>       <span class="hljs-type">Cursor</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> resolver.query(uri, <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[] &#123; <span class="hljs-string">&quot;address&quot;</span>, <span class="hljs-string">&quot;date&quot;</span>, <span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;body&quot;</span>&#125;,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>,<span class="hljs-literal">null</span>)<br>        <span class="hljs-keyword">if</span>(cursor != <span class="hljs-literal">null</span> &amp;&amp; cursor.getCount() &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">while</span> (cursor.moveToNext()) &#123;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">address</span> <span class="hljs-operator">=</span> cursor.getString(<span class="hljs-number">0</span>);<br>           <span class="hljs-type">long</span> <span class="hljs-variable">date</span> <span class="hljs-operator">=</span> cursor.getLong(<span class="hljs-number">1</span>);<br>           <span class="hljs-type">int</span> <span class="hljs-variable">type</span> <span class="hljs-operator">=</span> cursor.getInt(<span class="hljs-number">2</span>);<br>           <span class="hljs-type">String</span> <span class="hljs-variable">body</span> <span class="hljs-operator">=</span> cursor.getString(<span class="hljs-number">3</span>);<br>       &#125;<br>        &#125;<br>       <br></code></pre></td></tr></table></figure><h2 id="四。内容观察者"><a href="#四。内容观察者" class="headerlink" title="四。内容观察者"></a>四。内容观察者</h2><blockquote><p>观察指定Uri所代表的数据，数据变化时会触发ContentObserver的onChange()方法。</p><p>在onChange()方法中使用ContentResovler可以查询到变化的数据</p></blockquote><hr><h1 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h1><p>GET方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://192.168.1.1:8080/web?username=&quot;</span>+URLEncoder.encode(<span class="hljs-string">&quot;zhangsan&quot;</span>)+<span class="hljs-string">&quot;&amp;password=&quot;</span>+URLEncoder.encode(<span class="hljs-string">&quot;123&quot;</span>);<br><br><span class="hljs-comment">//创建URL对象</span><br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>(path)<br><br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) url.openConnection();<br><br>conn.setRequestMethod(<span class="hljs-string">&quot;GET&quot;</span>);<br>conn.setConnectTimeout(<span class="hljs-number">5000</span>);<br><span class="hljs-type">int</span> <span class="hljs-variable">responsecode</span> <span class="hljs-operator">=</span> conn.getResponseCode;<br><span class="hljs-keyword">if</span>( responsecode == <span class="hljs-number">200</span>) &#123;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>URL长度一般要小于1KB</li></ul><p>POST方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">String</span> <span class="hljs-variable">path</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;http://192.168.1.1:8080/web&quot;</span>;<br><span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">URL</span>();<br><span class="hljs-type">HttpURLConnection</span> <span class="hljs-variable">conn</span> <span class="hljs-operator">=</span> (HttpURLConnection) conn.openConnection();<br>conn.setRequestMethos(<span class="hljs-string">&quot;POST&quot;</span>);<br>conn.setConnectTime(<span class="hljs-number">5000</span>);<br><br><span class="hljs-type">String</span> <span class="hljs-variable">data</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;username=&quot;</span>+URLEncoder.encode(<span class="hljs-string">&quot;zhangsan&quot;</span>)+<span class="hljs-string">&quot;&amp;password=&quot;</span>+URLEncoder.encoder(<span class="hljs-string">&quot;123&quot;</span>)<br><br><span class="hljs-comment">//设置请求头数据提交方式，以form表单方式提交</span><br>conn,setRequestProperty(<span class="hljs-string">&quot;Content-Type&quot;</span>, <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>)<br><span class="hljs-comment">//设置提交数据长度</span><br>conn.setRequestProperty(<span class="hljs-string">&quot;Content-Length&quot;</span>, data.length() + <span class="hljs-string">&quot;&quot;</span>);<br><br>conn.setDoOutput(<span class="hljs-literal">true</span>);  <span class="hljs-comment">//设置运行向外写数据</span><br><span class="hljs-type">OutputStream</span> <span class="hljs-variable">os</span> <span class="hljs-operator">=</span> conn.getOutputStream();  <span class="hljs-comment">//利用输出流向服务器写数据</span><br>os.write(data.getBytes());  <span class="hljs-comment">//将数据写给服务器</span><br><span class="hljs-type">int</span> <span class="hljs-variable">code</span> <span class="hljs-operator">=</span> conn.getRequestCode();<br><span class="hljs-keyword">if</span>( code == <span class="hljs-number">200</span> ) &#123;<br><span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> conn.getInputStream();<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h1 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h1><h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><blockquote><p>Fragment不能独立存在，必须嵌入到Activity中使用</p></blockquote><ul><li>Activity暂停时，它所拥有的Fragment都暂停</li><li>Activity销毁时，它所拥有的Activity都销毁</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20240106130326103.png" alt="image-20240106130326103"></p><h3 id="生命周期方法"><a href="#生命周期方法" class="headerlink" title="生命周期方法"></a>生命周期方法</h3><ul><li>onAttach() : 当Fragment和Activity建立关联时调用</li><li>onCreateView(): 创建视图</li><li>onDetach(): 当Fragment和Activity解除关联时调用</li></ul><h4 id="注册-2"><a href="#注册-2" class="headerlink" title="注册"></a>注册</h4><ul><li>在Activity的布局文件中引用即可</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span></span><br><span class="hljs-tag"><span class="hljs-attr">android:id</span>=<span class="hljs-string">&quot;@id/fragment&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:name</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_width</span>=<span class="hljs-string">&quot;&quot;</span></span><br><span class="hljs-tag">        <span class="hljs-attr">android:layout_height</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> List&lt;Fragment&gt; fragmentList;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">onCreate</span><span class="hljs-params">(Bundle savedInstanceState)</span> &#123;<br>        <span class="hljs-built_in">super</span>.onCreate(savedInstanceState);<br>        setContentView(R.layout.activity_main);<br>        List&lt;Fragment&gt; fragments = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(Fragment) ();<br>        fragments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fragment1</span>());<br>        fragments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fragment2</span>());<br>        fragments.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Fragment3</span>());<br>        <span class="hljs-type">FragAdapter</span> <span class="hljs-variable">adapter</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FragAdapter</span>(getSupportFragmentManager(), fragments);<br>        <span class="hljs-comment">//设定设配器</span><br>        <span class="hljs-type">ViewPager</span> <span class="hljs-variable">vp</span> <span class="hljs-operator">=</span> (ViewPager) findViewById(R.id.viewpager);<br>        vp.setAdapter(adapter);<br>    &#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>传感器原理与应用</title>
    <link href="/2023/11/22/%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
    <url>/2023/11/22/%E4%BC%A0%E6%84%9F%E5%99%A8%E5%8E%9F%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20231122085148784.png" alt="image-20231122085148784"></p><h2 id="1、传感器与组成、基本特性（静态特性指标）；"><a href="#1、传感器与组成、基本特性（静态特性指标）；" class="headerlink" title="1、传感器与组成、基本特性（静态特性指标）；"></a>1、传感器与组成、基本特性（静态特性指标）；</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a><strong>定义：</strong></h3><p>  从广义来说，传感器是一种能把物理量、化学量或生物量等按照一定规律转换为与之<strong>有确定对应关系的</strong>、<strong>便于应用的</strong>某种<strong>物理量</strong>的<strong>器件或者装置</strong>。包含以下几层意思。</p><p>（1）  传感器是测量器件或装置，<strong>能完成一定的检测任务</strong></p><p>（2）  它的<strong>输入量是某一被测量</strong>，可能时物理量，也可能是化学量、生物量等</p><p>（3）  他的<strong>输出量是某种物理量</strong>，这种量要便于传输、转换、处理、显示等，这种量可以是气、光、电量等，一般情况下是电量</p><h3 id="组成："><a href="#组成：" class="headerlink" title="组成："></a><strong>组成：</strong></h3><p>  通常传感器由<strong>敏感元件</strong>、<strong>转换元件</strong>及<strong>信息调理电路</strong>三部分组成。有时候还需要加<strong>辅助电源。</strong></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/clip_image002.jpg" alt="img"></p><h3 id="基本特性："><a href="#基本特性：" class="headerlink" title="基本特性："></a><strong>基本特性：</strong></h3><blockquote><p> 传感器的基本特性是指传感器的<strong>输入-输出关系特性</strong>，是传感器的<strong>内部结构参数作用关系的外部特性表现</strong>。不同的传感器有不同的内部结构参数，决定了他们具有不同的外部特性</p></blockquote><p>  传感器所测量的物理量基本上有两种特性，<strong>静态特性和动态特性。</strong>静态特性的信号<strong>不随时间变化</strong>(或变化很缓慢)；动态特性的信号是<strong>随时间变化而变化的。</strong></p><h4 id="一．-静态特性指标"><a href="#一．-静态特性指标" class="headerlink" title="一．  静态特性指标"></a><strong>一．  静态特性指标</strong></h4><p><strong>1.</strong> <strong>测量范围</strong></p><p><strong>2.</strong> <strong>灵敏度</strong></p><p><strong>3.</strong> <strong>精确度</strong></p><p><strong>4.</strong> <strong>线性度</strong></p><ul><li>传感器的输出量与输入量之间的关系曲线<strong>偏移理想直线的程度</strong>。越小越好(越小即静态特性越接近于拟合直线)</li></ul><p><strong>5.</strong> <strong>分辨力与分辨率</strong></p><ul><li><p>分辨力：传感器能检测到的最小的输入增量。</p></li><li><p>分辨力用绝对值表示，其与满量程的百分比表示时称为分辨率</p></li></ul><p><strong>6.</strong> <strong>阈值</strong></p><ul><li>传感器输入从零增加到传感器给出<strong>可分辨输出量</strong>称为阈值</li></ul><p><strong>7.</strong> <strong>迟滞</strong></p><ul><li>传感器在正(输入量增大)反(输入量减少)行程期间其输出-输入特性曲线<strong>不重合的现象</strong></li></ul><p><strong>8.</strong> <strong>重复性</strong></p><ul><li>在<strong>同一个工作条件</strong>下，输入量按<strong>同一个方向</strong>在全测量范围内<strong>连续变动多次</strong>所得特性曲线的<strong>不一致性</strong></li></ul><p><strong>9.</strong> <strong>稳定性</strong></p><ul><li>在较长的时间内保持其性能参数的能力</li></ul><p><strong>10.</strong> <strong>漂移</strong></p><ul><li>在外界的<strong>干扰</strong>下，<strong>在一定时间间隔内</strong>，传感器输出量发生与输入流无关或不需要的变化。<ul><li>包括零点漂移和灵敏度漂移</li></ul></li></ul><p><strong>11.</strong> <strong>可靠性</strong></p><ul><li>传感器或者检测系统在规定的工作条件和规定的时间内，具有正常工作性能的能力</li></ul><h4 id="二．-动态特性分析"><a href="#二．-动态特性分析" class="headerlink" title="二．  动态特性分析"></a><strong>二．</strong>  <strong>动态特性分析</strong></h4><p><strong>1.</strong> <strong>时域</strong></p><p>​    a)    采用<strong>瞬态响应法</strong>分析</p><p>​    b)    采用<strong>阶跃函数</strong></p><p><strong>2.</strong> <strong>频域</strong></p><p>​    a)    采用<strong>频率响应法</strong>分析</p><p>​    b)    采用<strong>正弦函数</strong>    </p><hr><h2 id="2、电阻应变式传感器工作原理（应变效应、压阻效应）、测量电路（平衡电桥）；"><a href="#2、电阻应变式传感器工作原理（应变效应、压阻效应）、测量电路（平衡电桥）；" class="headerlink" title="2、电阻应变式传感器工作原理（应变效应、压阻效应）、测量电路（平衡电桥）；"></a>2、电阻应变式传感器工作原理（应变效应、压阻效应）、测量电路（平衡电桥）；</h2><h3 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h3><p>​    电阻式传感器是一种把非电量(力、压力、位移、扭矩)转换成与之有对应关系的电阻值，再经过<strong>测量电桥</strong>把电阻值转换成便于传送和记录的电压(电流)的装置</p><p>​    电阻式传感器只要分为<strong>电位器式和电阻应变式</strong>。电阻应变式传感器是应用最广泛的传感器</p><ul><li>电位器式主要用于非电量变化较大的测量场合</li><li>电阻应变式主要用于<strong>测量变化量相对较小的场合。</strong></li></ul><h3 id="电阻应变式传感器："><a href="#电阻应变式传感器：" class="headerlink" title="电阻应变式传感器："></a>电阻应变式传感器：</h3><h4 id="核心元件："><a href="#核心元件：" class="headerlink" title="核心元件："></a>核心元件：</h4><p>​    金属应变片，它可以将应变片上的应变变化转换成电阻变化</p><h4 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h4><ol><li>精度高，测量范围广</li><li>频率响应特性较好</li><li>结构简单，尺寸小，质量轻</li><li>可在恶虐条件下正常工作</li><li>易于实现小型化、固态化</li><li>价格低廉，品种多样，便于选择</li></ol><h4 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h4><ol><li>具有<strong>非线性</strong>，输出信号微弱，抗干扰能力差，需要<strong>信号线采取屏蔽措施。</strong></li><li>只能测量一点或应变范围内的<strong>平均应变</strong>，不能显示应变场中应变梯度的变化</li><li>是将非电量转换成电阻值的变化，再经过转换电路变换成电量(电流、电压)输出</li></ol><h4 id="应变效应："><a href="#应变效应：" class="headerlink" title="应变效应："></a>应变效应：</h4><h5 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h5><p>​    导体或半导体材料在<strong>外界力</strong>的作用下，会产生<strong>机械形变</strong>，其<strong>电阻值也会随之变化</strong>，这种现象称为应变效应</p><h4 id="压阻效应："><a href="#压阻效应：" class="headerlink" title="压阻效应："></a>压阻效应：</h4><h5 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h5><p>​    半导体材料当<strong>某一轴向受外力作用</strong>时，其<strong>电阻率发生变化</strong>的现象</p><h4 id="半导体应变片的灵敏系数"><a href="#半导体应变片的灵敏系数" class="headerlink" title="半导体应变片的灵敏系数"></a>半导体应变片的灵敏系数</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs"><br></code></pre></td></tr></table></figure><h4 id="应变片分类："><a href="#应变片分类：" class="headerlink" title="应变片分类："></a>应变片分类：</h4><p>​    <strong>金属丝式</strong></p><ul><li>价格便宜，多用于要求不高的应变、应力的大量或者一次性实验</li></ul><p>​    <strong>金属箔式</strong></p><ul><li>散热性好，可以通过较大电流</li><li>长时间测量的蠕动较小</li></ul><p>​    <strong>薄膜式</strong></p><h3 id="测量电路"><a href="#测量电路" class="headerlink" title="测量电路"></a>测量电路</h3><p>​    应变式电阻传感器中最常用的转换电路是电桥电路，作用是<strong>将应变片电阻的变化转换成电压的变化</strong>。</p><h4 id="一。直流电桥电路"><a href="#一。直流电桥电路" class="headerlink" title="一。直流电桥电路"></a>一。直流电桥电路</h4><h5 id="电桥平衡"><a href="#电桥平衡" class="headerlink" title="电桥平衡"></a>电桥平衡</h5><blockquote><p>电桥输出电压U = 0时，电桥处于平衡状态</p></blockquote><p>要让电桥平衡，需要<br>$$<br>R_1<em>R_4 = R_2</em>R_3<br>$$</p><p>(1)单臂半桥形式电桥电路</p><p>​    R1为应变片，R2,R3,R4为普通电阻</p><p>​    U0 = E/4 * Ke(e为应变)</p><p>(2)双臂半桥形式电桥电路</p><p>​    R1,R2为应变片，R3,R4为普通电阻</p><p>​    U0 = E/2 * Ke</p><p>(3)全桥式电桥电路</p><p>​    R1,R2,R3,R4全为应变片</p><p>​    U0 = E * Ke</p><ul><li>灵敏度最高，双臂的两倍，<strong>单臂的四倍</strong></li></ul><h5 id="二。交流电桥电路"><a href="#二。交流电桥电路" class="headerlink" title="二。交流电桥电路"></a>二。交流电桥电路</h5><h5 id="三。直流电桥、交流电桥比较"><a href="#三。直流电桥、交流电桥比较" class="headerlink" title="三。直流电桥、交流电桥比较"></a>三。直流电桥、交流电桥比较</h5><p><strong>直流电桥</strong></p><p>优点：</p><ul><li><strong>电源稳定</strong>、平衡电路简单，是主要测量电路</li></ul><p>缺点</p><ul><li>直流放大器较复杂，<strong>存在零漂和工频干扰</strong></li></ul><p><strong>交流电桥</strong></p><p>优点：</p><ul><li>放大电路简答无零漂，不受干扰，为特定传感器带来方便</li></ul><p>缺点：</p><ul><li><strong>需要专用测量仪器或电路</strong>，不易取得高精度</li></ul><h3 id="温度补偿"><a href="#温度补偿" class="headerlink" title="温度补偿"></a>温度补偿</h3><h3 id="应用："><a href="#应用：" class="headerlink" title="应用："></a>应用：</h3><ul><li>测力传感器</li><li>压阻式传感器的压力测量</li><li>液位测量</li></ul><h2 id="3、电容传感器工作原理（画图、公式）及分类；"><a href="#3、电容传感器工作原理（画图、公式）及分类；" class="headerlink" title="3、电容传感器工作原理（画图、公式）及分类；"></a>3、电容传感器工作原理（画图、公式）及分类；</h2><h3 id="概念："><a href="#概念：" class="headerlink" title="概念："></a>概念：</h3><h4 id="定义：-4"><a href="#定义：-4" class="headerlink" title="定义："></a>定义：</h4><p>​    利用电容器的原理，将非电量转换成电容量，进而实现非电量到电量的转换的器件或装置，叫做电容传感器</p><h4 id="优点：-1"><a href="#优点：-1" class="headerlink" title="优点："></a>优点：</h4><ul><li>测量范围大</li><li>灵敏度高</li><li>结构简单、适应性强</li><li>动态响应时间短、易实现非接触测量</li></ul><p><strong>电容量：</strong><br>$$<br>C = A / d<br>$$</p><h3 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h3><ul><li><strong>变面积式</strong></li><li><strong>变极距式</strong></li><li><strong>变介电常数式</strong></li></ul><h4 id="一。变面积式电容传感器"><a href="#一。变面积式电容传感器" class="headerlink" title="一。变面积式电容传感器"></a>一。变面积式电容传感器</h4><p>1.平板形直线位移式</p><p>2.半圆形角位移式</p><p>3.同心圆筒式</p><h4 id="二。变极距式电容传感器"><a href="#二。变极距式电容传感器" class="headerlink" title="二。变极距式电容传感器"></a>二。变极距式电容传感器</h4><h4 id="三。变介电常数式电容传感器"><a href="#三。变介电常数式电容传感器" class="headerlink" title="三。变介电常数式电容传感器"></a>三。变介电常数式电容传感器</h4><p>1.平板结构</p><ol><li>串联结构</li><li>并联结构</li></ol><p>2.圆筒结构</p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><ul><li>电容压力传感器</li><li>电容位移传感器</li><li>电容加速度传感器</li><li>电容厚度传感器</li><li>电容液位传感器</li></ul><h2 id="4、电感传感器原理（画图、公式）及分类；两种传感器区别"><a href="#4、电感传感器原理（画图、公式）及分类；两种传感器区别" class="headerlink" title="4、电感传感器原理（画图、公式）及分类；两种传感器区别"></a>4、电感传感器原理（画图、公式）及分类；两种传感器区别</h2><h3 id="概念：-1"><a href="#概念：-1" class="headerlink" title="概念："></a>概念：</h3><h4 id="定义：-5"><a href="#定义：-5" class="headerlink" title="定义："></a>定义：</h4><p>​    电感式传感器建立在电磁感应的基础上，利用线圈自感或者互感来实现非电量的检测。</p><h4 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h4><ul><li>结构简单、工作可靠、灵敏度高</li><li>测量精度高、输出功率大</li><li>可实现信息的远距离传输、记录、显示和控制</li><li>灵敏度、线性度和测量范围相互制约，传感器本身频率响应低，不适应快速动态测量</li></ul><h3 id="一。自感式电感传感器："><a href="#一。自感式电感传感器：" class="headerlink" title="一。自感式电感传感器："></a>一。自感式电感传感器：</h3><h4 id="1-变气隙式电感传感器"><a href="#1-变气隙式电感传感器" class="headerlink" title="1.变气隙式电感传感器"></a>1.变气隙式电感传感器</h4><h5 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h5><p>​    在铁芯和衔铁之间有气隙，传感器的运动部分与衔铁相连，当衔铁移动时，气隙厚度发生改变，引起磁路中磁阻变化，从而导致电感线圈的电感值变化，只要测出这种电感量的变化，就能确定衔铁位移量的大小和方向</p><h4 id="2-变截面式电感传感器"><a href="#2-变截面式电感传感器" class="headerlink" title="2.变截面式电感传感器"></a>2.变截面式电感传感器</h4><h5 id="原理：-1"><a href="#原理：-1" class="headerlink" title="原理："></a>原理：</h5><p>​    磁路气隙的截面积变化，使传感器的电感发生相应变化。若保持气隙厚度为常数，则电感L是气隙截面积A的函数，A和L之间是线性关系</p><p>灵敏度<br>$$<br>K = dL / dA =<br>$$</p><h5 id="特点"><a href="#特点" class="headerlink" title="特点:"></a>特点:</h5><p>与变气隙式电感传感器相比</p><ul><li>灵敏度低</li><li>被测位移量很小，工业中应用少</li></ul><h4 id="3-螺线管式电感传感器"><a href="#3-螺线管式电感传感器" class="headerlink" title="3.螺线管式电感传感器"></a>3.螺线管式电感传感器</h4><h5 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h5><p>​    主要元件为一只螺线管和一根圆柱形铁芯。传感器工作时，铁芯在线圈中伸入长度的变化引起螺管线圈自感值的变化。当用恒流源激励时，线圈的输出电压与铁芯的位移量有关</p><p>$$<br>电感值 L_0 =<br>$$</p><h5 id="特点：-1"><a href="#特点：-1" class="headerlink" title="特点："></a>特点：</h5><ul><li>结构简单，制造装配容易</li><li>因为空气间隙大，磁路的磁阻高，因此灵敏度低，线性范围大</li><li>磁路大部分为空气，因此易受外部磁场干扰</li><li>由于磁阻高，为了达到某一自感量，需要的线圈匝数多，因而线圈分布电容大</li><li>要求线圈框架的尺寸和形状必须稳定，否则会影响其线性和稳定性</li></ul><h3 id="二。互感式传感器-差动变压器式传感器-："><a href="#二。互感式传感器-差动变压器式传感器-：" class="headerlink" title="二。互感式传感器(差动变压器式传感器)："></a>二。互感式传感器(差动变压器式传感器)：</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><h5 id="定义：-6"><a href="#定义：-6" class="headerlink" title="定义："></a>定义：</h5><p>​    把被测的非电量变化转换为线圈互感量变化的传感器叫做互感式传感器。根据变压器的基本原理制成</p><h5 id="分类：-1"><a href="#分类：-1" class="headerlink" title="分类："></a>分类：</h5><ul><li>变隙式</li><li>变截面式</li><li>螺线管式</li></ul><p>​    三种方式工作原理基本一致，在非电量测量中，<strong>螺线管式差动变压器应用最多</strong></p><h5 id="螺线管式差动变压器组成"><a href="#螺线管式差动变压器组成" class="headerlink" title="螺线管式差动变压器组成"></a>螺线管式差动变压器组成</h5><p>​    基本元件有衔铁、初级线圈、次级线圈和线圈框架等</p><ul><li>初级线圈作为差动变压器激励，相当于<strong>变压器的原边</strong></li><li>次级线圈由结构尺寸和参数相同的两个线圈反向串接而成，相当于<strong>变压器的副边</strong></li></ul><h5 id="特点：-2"><a href="#特点：-2" class="headerlink" title="特点："></a>特点：</h5><ul><li>测量精度高、灵敏度高</li><li>结构简单、性能可靠</li></ul><h3 id="三。自感式传感器和互感式传感器的区别"><a href="#三。自感式传感器和互感式传感器的区别" class="headerlink" title="三。自感式传感器和互感式传感器的区别"></a>三。自感式传感器和互感式传感器的区别</h3><p>​    主要区别在于其测量原理不同。</p><p><strong>自感式传感器</strong>利用被测量物体上<strong>自己产生的电磁场来实现测量</strong>。在自感式传感器中，线圈中的<strong>电流会产生一个磁场</strong>，该磁场与被测物体产生的电磁场相互作用，从而产生电压信号。因此，自感式传感器的测量范围通常比较局限，只适用于测量接近或贴近线圈的物体。</p><p><strong>互感式传感器</strong>则利用被测量物体上<strong>周围环境中的电磁场变化情况来实现测量</strong>。在互感式传感器中，线圈所处的<strong>环境中存在着外部的电磁场</strong>，该电磁场会改变线圈中的电感值，从而产生电压信号。因此，互感式传感器的测量范围通常比较广泛，可以测量较远距离的物体。</p><h3 id="四。应用："><a href="#四。应用：" class="headerlink" title="四。应用："></a>四。应用：</h3><ul><li>差动压力传感器</li><li>加速度测量</li></ul><h2 id="5、电涡流传感器工作原理与分类；"><a href="#5、电涡流传感器工作原理与分类；" class="headerlink" title="5、电涡流传感器工作原理与分类；"></a>5、电涡流传感器工作原理与分类；</h2><h3 id="概念：-2"><a href="#概念：-2" class="headerlink" title="概念："></a>概念：</h3><h4 id="定义：-7"><a href="#定义：-7" class="headerlink" title="定义："></a>定义：</h4><p>​    利用电涡流效应进行工作。</p><p>​    根据<strong>法拉第电磁感应定律</strong>，将<strong>金属</strong>导体置于<strong>变化的磁场中</strong>，<strong>导体表面就会有感应电流产生</strong>。电流的流线在金属体内自行闭合，这种由电磁感应原理产生的漩涡状感应电流就称为电涡流，这种现象叫做<strong>电涡流效应</strong> 。</p><p>​    电涡流只集中在金属导体的表面，这一现象称为<strong>趋肤效应</strong></p><p>形成电涡流必须具备两个条件</p><ul><li>存在交变磁场</li><li>导电体处于交变磁场中</li></ul><p>​    </p><h4 id="特点：-3"><a href="#特点：-3" class="headerlink" title="特点："></a>特点：</h4><ul><li>结构简单</li><li>灵敏度高</li><li>频响范围宽</li><li>不受油污等介质影响</li><li><strong>能进行非接触测量、使用范围广</strong>(无损探伤)</li></ul><h3 id="分类：-2"><a href="#分类：-2" class="headerlink" title="分类："></a>分类：</h3><h4 id="一。高频放射式电涡流传感器"><a href="#一。高频放射式电涡流传感器" class="headerlink" title="一。高频放射式电涡流传感器"></a>一。高频放射式电涡流传感器</h4><p>​    结构简单，主要是一个安置在框架上的线圈，线圈可以绕成一个扁平圆形黏贴在框架上，也可以在框架上开一条槽，导线绕制在槽内形成一个线圈。</p><h4 id="二。低频透射式电涡流传感器"><a href="#二。低频透射式电涡流传感器" class="headerlink" title="二。低频透射式电涡流传感器"></a>二。低频透射式电涡流传感器</h4><h5 id="原理：-2"><a href="#原理：-2" class="headerlink" title="原理："></a>原理：</h5><p>​    由于趋肤效应，金属导体产生的电涡流的贯穿深度与传感器线圈激磁电流的频率有关</p><p>​    <strong>频率越低，电涡流的贯穿深度越厚</strong>。</p><p>​    利用此原理制成的低频透射涡流传感器适合<strong>测量金属材料的厚度</strong></p><h5 id="影响因素："><a href="#影响因素：" class="headerlink" title="影响因素："></a>影响因素：</h5><p>​    金属板中电涡流的大小除了受金属板厚度影响外，还与其电阻率有关(电阻率与温度有关)</p><ul><li>测薄金属板时，频率应略高<ul><li>在测电阻率较大材料时，应选用较高频率(2kHz)</li></ul></li><li>测厚金属板时，频率应低些<ul><li>在测量电阻率较小的材料时，应该选用较低频率(500Hz)</li></ul></li></ul><h3 id="应用：-1"><a href="#应用：-1" class="headerlink" title="应用："></a>应用：</h3><ul><li>电涡流转速传感器</li><li>振动的测量</li><li>电涡流探伤</li><li>位移测量</li><li>温度测量</li><li>电涡流安全通道检查门</li></ul><h2 id="6、霍尔效应及霍尔传感器的应用；"><a href="#6、霍尔效应及霍尔传感器的应用；" class="headerlink" title="6、霍尔效应及霍尔传感器的应用；"></a>6、霍尔效应及霍尔传感器的应用；</h2><h3 id="磁电感应式传感器"><a href="#磁电感应式传感器" class="headerlink" title="磁电感应式传感器"></a>磁电感应式传感器</h3><blockquote><p>磁电感应式传感器是利用电磁感应原理将被测量转换成电信号的一种传感器。</p></blockquote><p>​    当导体和磁场发生相对运动时，在导体两端有感应电动势输出，磁电感应式传感器工作时不需要外加电源(将被测物体的机械能转换成电量)，是有源传感器</p><p>​    导体在磁场中运动切割磁力线，或者通过闭合线圈的磁通发生变化时，导体两端或线圈将产生感应电动势</p><h3 id="霍尔传感器"><a href="#霍尔传感器" class="headerlink" title="霍尔传感器"></a>霍尔传感器</h3><h4 id="概念：-3"><a href="#概念：-3" class="headerlink" title="概念："></a>概念：</h4><p>​    是目前国内外应用最广泛的一种磁敏传感器，它利用磁场作为媒介</p><p>​    它可以实现非接触测量，多数情况下，可以用永磁铁来产生磁场，不需要附加能源</p><p>​    霍尔传感器属于半导体磁敏元件，磁敏元件也是基于磁电转换原理，把磁学物理量转换成电信号的传感器</p><p>​    霍尔传感器有<strong>霍尔元件</strong>和<strong>霍尔集成电路</strong>两种类型</p><ul><li>霍尔集成电路是把霍尔元件、放大器、温度补偿电路以及稳压电源等集成在一个芯片上的集成电路型结构</li></ul><h4 id="霍尔效应"><a href="#霍尔效应" class="headerlink" title="霍尔效应"></a>霍尔效应</h4><p>​    霍尔效应的产生是由于运动电荷受到磁场中洛伦兹力作用，霍尔元件中的电流是金属中自由电子在电场作用下的定向运动。</p><h4 id="集成霍尔传感器分类："><a href="#集成霍尔传感器分类：" class="headerlink" title="集成霍尔传感器分类："></a>集成霍尔传感器分类：</h4><p>​    根据输出信号的形式不同，分为开关型和线性两种</p><p><strong>开关型集成霍尔传感</strong>器根据检测的磁感应强度大小输出高低两个电压电平</p><p><strong>线性集成霍尔传感器</strong>输出一个与检测的磁感应强度信号成正比的电压信号</p><h4 id="应用-1"><a href="#应用-1" class="headerlink" title="应用"></a>应用</h4><ul><li><strong>霍尔转速表</strong><ul><li>齿盘的转动使磁路的磁阻随气隙的改变而周期性变化</li></ul></li><li><strong>霍尔式无触点点火装置</strong><ul><li>产生很高的感应电压，火花塞产生火花放电点火</li></ul></li><li><strong>霍尔式功率计</strong></li><li><strong>霍尔式无刷直流电机</strong><ul><li>采用霍尔传感器驱动的无触点直流电动机。</li></ul></li><li><strong>钳型电流表</strong><ul><li>根据安培定律，在载流导体周围产生正比于该电流的磁场。用霍尔元件测量这一磁场，可得到正比于该磁场的霍尔电动势。通过测量霍尔点当时的大小来间接测量电流的大小</li></ul></li></ul><h2 id="7、压电效应，逆压电效应及应用；"><a href="#7、压电效应，逆压电效应及应用；" class="headerlink" title="7、压电效应，逆压电效应及应用；"></a>7、压电效应，逆压电效应及应用；</h2><h3 id="概念：-4"><a href="#概念：-4" class="headerlink" title="概念："></a>概念：</h3><h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>​    压电式传感器是以某些电介质的压电效应为基础，在外力作用下，电介质的表面上会产生电荷，从而实现非电量的测量</p><p>​    压电式传感元件是力敏感元件，所以它能测量最终能变换为力的那些物理量，例如力、压力、加速度等</p><h4 id="特点：-4"><a href="#特点：-4" class="headerlink" title="特点："></a>特点：</h4><ul><li>响应频带宽高、灵敏度高</li><li>信噪比大、结构简单、工作可靠、质量轻</li></ul><h3 id="压电效应："><a href="#压电效应：" class="headerlink" title="压电效应："></a>压电效应：</h3><h4 id="正压电效应"><a href="#正压电效应" class="headerlink" title="正压电效应"></a>正压电效应</h4><h5 id="概念：-5"><a href="#概念：-5" class="headerlink" title="概念："></a>概念：</h5><p>​    当某些电介质，<strong>沿着一定方向对其施力而使它变形时</strong>，<strong>内部发生了极化现象</strong>，同时在它<strong>表面上产生电荷</strong>，当外力去掉后，又<strong>重新恢复</strong>不带电状态的现象。</p><p>​    当作用力方向改变时，电荷极性也随着改变</p><h4 id="逆压电效应"><a href="#逆压电效应" class="headerlink" title="逆压电效应"></a>逆压电效应</h4><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>​    当在电介质的<strong>极化方向施加电场</strong>，这些电介质就在一定方向上<strong>产生机械变形或机械压力</strong>，当外加电场撤去时，这些变形或应力也随之消失的现象</p><h3 id="应用：-2"><a href="#应用：-2" class="headerlink" title="应用："></a>应用：</h3><ul><li><p><strong>玻璃打碎报警装置</strong></p><ul><li>用胶黏贴在玻璃上，当玻璃遭到暴力打碎时，压电薄膜感受到剧烈振动。在两个输出引脚之间产生窄脉冲信号，信号经过放大后，用电缆输送到集中报警装置，产生报警信号</li></ul></li><li><p>压电式加速度计的原理与设计</p></li><li><p><strong>压电式传感器测表面粗糙度</strong></p></li><li><p><strong>压电式煤气炉电子点火装置</strong></p></li><li><p><strong>压电式流量计</strong></p></li><li><p><strong>压电式水漏探测仪</strong></p></li><li><p><strong>压电式压力传感器</strong></p></li></ul><h2 id="8、热电偶的工作原理（作图及公式）、热电偶的基本定律，二次查表法；"><a href="#8、热电偶的工作原理（作图及公式）、热电偶的基本定律，二次查表法；" class="headerlink" title="8、热电偶的工作原理（作图及公式）、热电偶的基本定律，二次查表法；"></a>8、热电偶的工作原理（作图及公式）、热电偶的基本定律，二次查表法；</h2><h3 id="概念：-6"><a href="#概念：-6" class="headerlink" title="概念："></a>概念：</h3><h4 id="定义：-8"><a href="#定义：-8" class="headerlink" title="定义："></a>定义：</h4><blockquote><p>热电式传感器是将温度变化转换为电量变化的装置，它利用敏感元件的电磁参数随温度变化的特性来实现温度的测量</p></blockquote><h4 id="主要构成："><a href="#主要构成：" class="headerlink" title="主要构成："></a>主要构成：</h4><p>​    主要包括热电偶、热电阻和热敏电阻</p><h3 id="热电偶传感器："><a href="#热电偶传感器：" class="headerlink" title="热电偶传感器："></a>热电偶传感器：</h3><h4 id="热电效应："><a href="#热电效应：" class="headerlink" title="热电效应："></a>热电效应：</h4><p>​    在两种<strong>不同材料</strong>的导体A和导体B组成的闭合回路中，<strong>当两个结点温度不相同时</strong>，回路中<strong>将产生电动势</strong>。</p><ul><li>两种不同材料的导体所组成的回路称为<strong>热电偶</strong></li><li>热电偶所产生的电动势称为热电动势<ul><li>热电偶的两个结点中，置于温度T的被测对象中的结点称之为**测量端(**工作端或热端)</li><li>而置于<strong>参考温度T0</strong>的另一端结点称为参考端(自由端或冷端)</li></ul></li></ul><h4 id="接触电动势"><a href="#接触电动势" class="headerlink" title="接触电动势"></a>接触电动势</h4><p>​    由于不同金属材料所具有的自由电子密度不同，<strong>当A和B两种不同材料的导体接触时</strong>，在A和B两导体的接触处所产生的电位差</p><ul><li>温度越高，接触电动势越大</li><li>两种导体电子密度的比值越大，接触电动势越大</li></ul><h4 id="温度电动势"><a href="#温度电动势" class="headerlink" title="温度电动势"></a>温度电动势</h4><p>​    高温端(T)的电子向低温端扩散，致使高温端因失去电子带正电，低温端因获得电子而带负电</p><ul><li>导致同一导体两端也产生了电位差，并阻止电子从高温端扩散到低温端，<strong>形成动态平衡</strong></li><li><strong>此时建立的电位差即温差电势</strong><ul><li>温差电动势的大小与导体的<strong>电子密度</strong>以及<strong>两端温度</strong>有关</li></ul></li></ul><h4 id="热电偶的基本定理"><a href="#热电偶的基本定理" class="headerlink" title="热电偶的基本定理"></a>热电偶的基本定理</h4><h5 id="1-均质导体定律"><a href="#1-均质导体定律" class="headerlink" title="1.均质导体定律"></a>1.均质导体定律</h5><p>​    <strong>同一种均质导体</strong>组成的闭合回路，不会产生电动势</p><h5 id="2-参考电极定律"><a href="#2-参考电极定律" class="headerlink" title="2.参考电极定律"></a>2.参考电极定律</h5><p>​    导体A、B分别与参考电极C组成热电偶</p><figure class="highlight cos"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cos">热端<span class="hljs-number">100</span>°C，冷端<span class="hljs-number">0</span>°C，镍铬合金与铂组成的热电偶的热电动势为<span class="hljs-number">2</span>，<span class="hljs-number">95</span><span class="hljs-keyword">mv</span>,考铜与铂组成的热电偶的热电动势为-<span class="hljs-number">4.0</span><span class="hljs-keyword">mv</span>，求镍铬和考铜组合的热电偶的热电动势<br><span class="hljs-number">2.95</span><span class="hljs-keyword">mv</span> - (-<span class="hljs-number">4.0</span>) = <span class="hljs-number">6.95</span><span class="hljs-keyword">mv</span><br></code></pre></td></tr></table></figure><h5 id="3-中间导体定律"><a href="#3-中间导体定律" class="headerlink" title="3.中间导体定律"></a>3.中间导体定律</h5><p>​    在热电偶回路中接入第三种导体，<strong>只要第三种导体和原导体的两结点温度相同</strong>，则回路的热电动势不变。</p><ul><li>可以将第三根导线换乘测试仪表或连接导线，只要保持两结点的温度相同，就可与对热电势进行测量而不影响原热电势的数值</li></ul><h5 id="4-中间温度定律"><a href="#4-中间温度定律" class="headerlink" title="4.中间温度定律"></a>4.中间温度定律</h5><p>​    热电偶在两结点温度T、T0时的热电势等于该热电偶在结点温度为T、Tn和Tn、T0时的相应热电势的代数和</p><h3 id="应用-2"><a href="#应用-2" class="headerlink" title="应用"></a>应用</h3><ul><li><strong>炉温测量</strong></li><li><strong>管道温度测量</strong></li></ul><h2 id="9、热敏电阻传感器原理；"><a href="#9、热敏电阻传感器原理；" class="headerlink" title="9、热敏电阻传感器原理；"></a>9、热敏电阻传感器原理；</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><blockquote><p>热电阻温度传感器是利用导体的电阻值随温度变化的特性，对温度和与温度有关的参数进行检测的装置</p></blockquote><h3 id="金属热电阻"><a href="#金属热电阻" class="headerlink" title="金属热电阻"></a>金属热电阻</h3><p>​    金属热电阻是利用电阻与温度呈一定函数关系的特性，由金属材料制成的感温元件。通过测量电阻值的变化大小而得到温度变化的情况及数值大小</p><h4 id="材料要求"><a href="#材料要求" class="headerlink" title="材料要求"></a>材料要求</h4><ul><li>电阻温度系数要大，电阻温度系数越大，热电阻的灵敏度越高；纯金属的电阻温度系数比合金的高，一般采用纯金属做热电阻元件</li><li>在测温范围内，材料的物理、化学物质应稳定</li><li>在测温范围内，电阻温度系数保持常数，便于实现温度表的线性刻度特性</li><li>具有比较大的电阻率，以利于减少热电阻的体积，减少热惯性</li><li>特性复现性好，容易复制</li></ul><h3 id="热敏电阻："><a href="#热敏电阻：" class="headerlink" title="热敏电阻："></a>热敏电阻：</h3><h4 id="构成："><a href="#构成：" class="headerlink" title="构成："></a>构成：</h4><p>​    主要由热敏探头、引线、壳体构成，热敏电阻一般做成二端器件，也可以做成三端、四端器件</p><ul><li>二端和三端器件为直热式<ul><li>热敏电阻直接由连接的电路中获得功率</li></ul></li><li>四端器件是旁热式</li></ul><h4 id="分类：-3"><a href="#分类：-3" class="headerlink" title="分类："></a>分类：</h4><blockquote><p>分为负温度系数(NTC)和正温度系数(PTC)之分。</p></blockquote><p><strong>NTF：</strong></p><ul><li>第一类用于测量温度<ul><li>电阻值与温度呈负指数关系</li></ul></li><li>第二类为突变型(CTR)<ul><li>当温度上升到某临界值时，电阻值突然下降</li><li>用于作温度开关</li></ul></li></ul><p><strong>PTC:</strong></p><p>​    既可以作为温度敏感元件，又可以在电子线路中起<strong>限流、保护作用</strong></p><ul><li>PTC突变型热敏电阻主要用作温度开关</li><li>PTC缓变型主要用于在较宽的温度范围内进行<strong>温度补偿和温度测量</strong></li></ul><h4 id="应用：-3"><a href="#应用：-3" class="headerlink" title="应用："></a>应用：</h4><ul><li>热敏电阻测温</li><li>管道流量测量</li></ul><hr><h3 id="热敏电阻和热电偶的区别"><a href="#热敏电阻和热电偶的区别" class="headerlink" title="热敏电阻和热电偶的区别"></a>热敏电阻和热电偶的区别</h3><ol><li>测温原理不同。热电偶是热电效应，热电阻是阻值变化</li><li>测温范围不同。热电偶连续测量范围宽，</li><li>种类和结构不同</li><li>应用不同。热电偶适用于高温工作，电势反应灵敏，需要补偿导线，造价高</li></ol><p>​    </p><h2 id="10、光电效应与光电元件；"><a href="#10、光电效应与光电元件；" class="headerlink" title="10、光电效应与光电元件；"></a>10、光电效应与光电元件；</h2><h3 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h3><p>​    光由光子构成，每一个光子具有的能力E正比于光的频率f    E = hf</p><ul><li>光子的频率越高，光子的能力越大</li></ul><p>​    光电传感器是将光信号转换成电信号的一种传感器</p><h3 id="光电效应"><a href="#光电效应" class="headerlink" title="光电效应"></a>光电效应</h3><h4 id="定义：-9"><a href="#定义：-9" class="headerlink" title="定义："></a>定义：</h4><blockquote><p>用光照射一个物体，可以看作物体受到一连串能力hf的光子轰击，组成这个物体的材料吸收光子能力而发生相应的电效应的物理现象称为光电效应</p></blockquote><p>​    因光照引起电学特性改变的现象，包括光照射到物体上使物体发射电子，电导率发生变化，产生光生电动势</p><p>​    </p><p>​    光电效应传感器是应用光敏材料的光电效应制成的光敏器件</p><h4 id="光电效应分类"><a href="#光电效应分类" class="headerlink" title="光电效应分类"></a>光电效应分类</h4><p>​    <strong>外光电效应</strong>：在光线作用下能使电子<strong>逸出物体表面</strong>的光电效应</p><ul><li><p><strong>光电管</strong></p></li><li><p><strong>光电倍增管</strong></p></li></ul><p>​    <strong>内光电效应</strong>：在光线作用下能使物体的<strong>电阻率改变</strong>的光电效应</p><ul><li>光敏电阻</li><li>光敏二极管</li></ul><p>​    <strong>光生伏特效应：</strong>在光线的作用下，物体产生<strong>一定方向电动势的光电效应</strong>(光电池、光敏晶体管)</p><ul><li>光电池</li><li>光敏晶体管</li></ul><h4 id="光源分类"><a href="#光源分类" class="headerlink" title="光源分类"></a>光源分类</h4><p>​    热辐射光源</p><p>​    气体放电光源</p><p>​    发光二极管</p><p>​    激光</p><h3 id="光电元件"><a href="#光电元件" class="headerlink" title="光电元件"></a>光电元件</h3><h4 id="一。基于外光电效应的光电元件"><a href="#一。基于外光电效应的光电元件" class="headerlink" title="一。基于外光电效应的光电元件"></a>一。基于外光电效应的光电元件</h4><h4 id="光电管"><a href="#光电管" class="headerlink" title="光电管"></a><strong>光电管</strong></h4><p>​    由一个阴极和一个阳极构成，密封在一支真空玻璃管内。</p><p>​    阳极通常用金属丝弯曲成矩形或者圆形，置于玻璃管中央，阴极装在玻璃管内壁，徒有光电发射材料。</p><ul><li>光电管的特性主要取决于<strong>光电管阴极材料</strong></li></ul><p>$$<br>E = 1/2mv^2 + A<br>$$<br><strong>光电效应方程</strong></p><ul><li>只有当光子能力E大于电子逸出功A时，物质内的电子才能脱离原子核的吸引力向外逸出</li></ul><p><strong>红限极限</strong></p><p>​    不同材料具有不同逸出功，对某种材料而言便有一个频率限</p><ul><li>当入射光频率低于红限频率时，无论入射光多强，照射时间多久，都不能激发出光电子</li><li>当入射高频率高于红限频率时，无论它多为若，也能激发电子。光越强，单位时间内入射光子数越多，激发的电子数目越大，光电流越大</li></ul><p><strong>光电管的基本特性</strong></p><p>1）伏安特性</p><p>​    在一定光照下，对光电管阴极所加的电压与阳极所产生的电流之间的关系称为伏安特性</p><p>2）光照特性</p><p>​    当光电管的阴极与阳极之间<strong>所加的电压一定时</strong>，光通量与光电流之间的关系称之为光照特性</p><p>3）光谱特性</p><p>​    光电管的光谱特性通常指阳极与阴极之间<strong>所加的电压不变时</strong>，入射光的波长与其相对灵敏度之间的关系</p><ul><li>主要取决于阴极材料</li><li>阴极材料不同的光电管适用于不同的光谱范围</li></ul><h4 id="光电倍增管"><a href="#光电倍增管" class="headerlink" title="光电倍增管"></a>光电倍增管</h4><p>​    有<strong>放大光电流的作用</strong>，有增益高、灵敏度高、超低噪声、光敏区面积大等特点。<strong>还可以用于微光测量</strong></p><h4 id="二。基于内光电效应的光电元件"><a href="#二。基于内光电效应的光电元件" class="headerlink" title="二。基于内光电效应的光电元件"></a>二。基于内光电效应的光电元件</h4><h4 id="概念-3"><a href="#概念-3" class="headerlink" title="概念"></a>概念</h4><p>​    入射光强改变物质导电率的现象称为光电导效应</p><ul><li>几乎所有高电阻率半导体都有光电导效应</li></ul><h4 id="光敏电阻"><a href="#光敏电阻" class="headerlink" title="光敏电阻"></a>光敏电阻</h4><p>​    几乎都是半导体材料制成，为纯电阻元件。</p><ul><li>当无光照时，光敏电阻具有很高的阻值</li><li>当光敏电阻受到一定波长范围的光照射时，光子的能量大于材料的禁带宽度。光照越强，电阻值越低</li></ul><h4 id="光敏晶体管"><a href="#光敏晶体管" class="headerlink" title="光敏晶体管"></a>光敏晶体管</h4><p>​    当二极管和三极管的PN结受到光照射时，通过PN结的电流将增大。</p><ul><li>光敏二极管结构与一般二极管不同之处在于他的PN结装在透明管壳的顶部，可以直接接收到光的照射</li></ul><h4 id="三。基于光生伏特效应的光电元件"><a href="#三。基于光生伏特效应的光电元件" class="headerlink" title="三。基于光生伏特效应的光电元件"></a>三。基于光生伏特效应的光电元件</h4><h4 id="光电池"><a href="#光电池" class="headerlink" title="光电池"></a>光电池</h4><p>​    在光线照射下，直接将光量转变成电动势的光电元件，实质上是电压源</p><ul><li>实质上时一个大面积的PN结</li></ul><h2 id="11、气敏传感器原理"><a href="#11、气敏传感器原理" class="headerlink" title="11、气敏传感器原理"></a>11、气敏传感器原理</h2><h3 id="概念-4"><a href="#概念-4" class="headerlink" title="概念"></a>概念</h3><blockquote><p> 气体传感器的定义是能够感知环境中某种气体及其浓度的一种敏感器件。将气体种类与其浓度有关的信息转换成电信号</p></blockquote><table><thead><tr><th align="center">类型</th><th>原理</th><th align="center">检测对象</th><th>特点</th></tr></thead><tbody><tr><td align="center">半导体式</td><td>若气体接触到加热的金属氧化物,电阻值会增大或减少</td><td align="center">还原性气体、城市排放气体、丙烷气等</td><td>灵敏度高，构造简单，但输出与气体浓度不成比例</td></tr><tr><td align="center">接触燃烧式</td><td>可燃性气体接触到氧气会燃烧，使得作为气敏材料的铂丝温度升高，电阻值相应增大</td><td align="center">可燃气体</td><td>输出与气体浓度成比例，灵敏度较低</td></tr><tr><td align="center">化学反应式</td><td>利用化学溶剂与气体反应产生的电流、颜色、电导率的增加等</td><td align="center">CO、氢气、甲烷、乙醇、二氧化硫</td><td>气体选择性好，但不能重复使用</td></tr><tr><td align="center">光干涉式</td><td>利用与空气的折射率不同而产生的干涉现象</td><td align="center">与空气折射率不同的气体(二氧化碳等)</td><td>寿命长，但选择性差</td></tr><tr><td align="center">热传导式</td><td>根据热传导率而放热的发热元件的温度降低进行检测</td><td align="center">与空气热传导率不同的气体(氢气等)</td><td>构造简单，灵敏度低、选择性差</td></tr><tr><td align="center">红外线吸收散射式</td><td>根据红外线照射气体分子谐振而产生的吸收或散射进行检测</td><td align="center">一氧化碳、二氧化碳</td><td>能定性检测，但是装置大，价格高</td></tr></tbody></table><h2 id="12-湿敏电阻传感器的基本原理与应用；"><a href="#12-湿敏电阻传感器的基本原理与应用；" class="headerlink" title="12.湿敏电阻传感器的基本原理与应用；"></a>12.湿敏电阻传感器的基本原理与应用；</h2><h3 id="概念-5"><a href="#概念-5" class="headerlink" title="概念"></a>概念</h3><blockquote><p>利用器件电阻值随适度变化的基本原理来进行工作，其感湿特征量为电阻值</p></blockquote><h3 id="电阻式湿敏传感器分类"><a href="#电阻式湿敏传感器分类" class="headerlink" title="电阻式湿敏传感器分类"></a>电阻式湿敏传感器分类</h3><p>​    根据感湿材料的不同而分类</p><h4 id="1-电解质式电阻湿敏传感器"><a href="#1-电解质式电阻湿敏传感器" class="headerlink" title="1.电解质式电阻湿敏传感器"></a>1.<strong>电解质式电阻湿敏传感器</strong></h4><p><strong>原理：</strong></p><p>​    电解质具有强烈的吸水性，且电导率又随其吸水量的多少而发生变化。</p><ul><li>电解质：有些物质的水溶液是能够导电的<ul><li>无机物中的酸、碱、盐绝大部分属于电解质</li><li>导电能力既与电解质本身的性质有关，又与电解质溶液的浓度有关。</li></ul></li><li>用<strong>当量电导</strong>来描述溶液的导电能力<ul><li>当量电导就是溶液中含有一当量电解质时的溶液的导电能力</li></ul></li></ul><p><strong>典型代表：</strong></p><p>​    氯化锂湿敏电阻，利用吸湿性盐类潮解，使离子导电率发生变化而制成</p><ul><li>优点<ul><li>滞后肖，不受测试环境影响</li><li>精度高</li></ul></li><li>缺点<ul><li>耐热性差</li><li>重复性差，寿命短</li><li>不能用于露点一下测量</li></ul></li></ul><h4 id="2-陶瓷式电阻湿敏传感器"><a href="#2-陶瓷式电阻湿敏传感器" class="headerlink" title="2.陶瓷式电阻湿敏传感器"></a>2.<strong>陶瓷式电阻湿敏传感器</strong></h4><p>​    利用陶瓷湿度材料烧结制备时形成的多孔结构，吸附或凝聚水分子用作导电通路，从而改变陶瓷本身的电导率或电容量</p><ul><li>通常由两种以上的金属氧化物混合烧结而成的多孔陶瓷</li></ul><p>优点</p><ul><li>传感器表面与水蒸气的接触面积大，易于水蒸气的吸收与脱离</li><li>陶瓷烧结体能耐高温，物理，化学性质稳定，适合采用加热去污的方法来恢复材料的湿敏特性</li><li>可以通过调节烧结体的表面晶粒、晶粒界和细微气孔的构造，改善传感器湿敏特性</li></ul><h4 id="3-高分子式电阻湿敏传感器"><a href="#3-高分子式电阻湿敏传感器" class="headerlink" title="3.高分子式电阻湿敏传感器"></a>3.<strong>高分子式电阻湿敏传感器</strong></h4><p>​    利用高分子电解质吸湿而导致电阻率发生变化的基本原理进行测量</p><ul><li>通常含强极性基的高分子电解质以及其盐类等高分子材料制成的感湿电阻膜</li><li>随着湿度的增加吸附量增大，吸附水分子凝聚成液态。低湿度下电阻值很高</li></ul><h4 id="4-电容式湿敏传感器"><a href="#4-电容式湿敏传感器" class="headerlink" title="4.电容式湿敏传感器"></a>4.<strong>电容式湿敏传感器</strong></h4><p>​    利用湿敏元件的电容量随湿度变化的特性进行测量</p><ul><li>属于变介电常数电容式传感器</li><li>当湿度变化时，由湿敏材料构成的电介质的介电常数发生改变，相应的电容量也随之发生改变</li></ul><h3 id="应用-3"><a href="#应用-3" class="headerlink" title="应用"></a>应用</h3><ul><li>汽车后窗玻璃的自动祛湿装置</li><li>高湿度显示仪</li></ul><h2 id="13、智能传感器的定义、特点与现场总线分类；"><a href="#13、智能传感器的定义、特点与现场总线分类；" class="headerlink" title="13、智能传感器的定义、特点与现场总线分类；"></a>13、智能传感器的定义、特点与现场总线分类；</h2><h3 id="概念-6"><a href="#概念-6" class="headerlink" title="概念"></a>概念</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>​    将一个或者多个敏感元件和信号处理器集成在同一块硅或者砷化锌芯片上的装置</p><p>​    智能传感器可以对信号进行检测、分析、处理、储存和通信，具备人类的记忆、分析、思考和交流能力，即具备人类的智能，所有称为智能传感器</p><p>​    <strong>智能传感器是一种带有微处理器，兼有信号检测、信号处理、信号记忆、逻辑思维与判断等智能化功能，是传感器和通信技术结合的产物</strong> </p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>​    主要由传感器、微处理器及相关电路组成</p><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ol><li>自校零、自标定、自校正功能</li><li>自动补偿功能</li><li>自动采集数据，并对数据进行预处理</li><li>自动进行校验、自选量程、自寻故障</li><li>数据存储、记忆和信息处理</li><li>双向通信、标准化数字输出或者符号输出功能</li><li>判断、决策处理功能</li></ol><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ol><li>精度高</li><li>高可靠性与高稳定性</li><li>高信噪比与高分辨力</li><li>自适应性强</li><li>性能价格比高</li></ol><h3 id="现场总线分类"><a href="#现场总线分类" class="headerlink" title="现场总线分类"></a>现场总线分类</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><blockquote><p> 现场总线是指连接智能现场设备和自动化系统的数字式、双向传输、多分支结构的通信网络</p></blockquote><p>​    现场总线时近年迅速发展的一种工业数据总线，主要解决现场的智能化仪器仪表、控制器、执行机构等现场设备的数字通信以及这些现场控制设备与高级控制系统之间的信息传递问题。</p><p>​    </p><h4 id="现场通信网络"><a href="#现场通信网络" class="headerlink" title="现场通信网络"></a>现场通信网络</h4><p>​    现场总线是用于过程自动化和制造自动化的现场设备或现场仪表互连的现场通信网络，把通信线一致延伸到生产现场或生产设备</p><h3 id="总线标准"><a href="#总线标准" class="headerlink" title="总线标准"></a>总线标准</h3><ol><li><p>1-Wire总线</p><p>通过单条连接线解决了控制、通信与供电问题</p></li><li><p>IIC总线</p><p>用于器件之间的二线制串行扩展总线</p></li><li><p>SMBus总线</p><p>以IIC总线为基础，面向不同系统组成芯片与系统其他部分间的通信，与IIC类似(通用性不好)</p></li><li><p>SPI总线</p><p>一种同步串行外设接口技术。主要应用与CPU与各种外围器件之间通信</p></li><li><p>USB总线</p><p>由4条线构成，用以传送信号和提供电源</p><p>对地电源电压为4.75~5.25V，设备能吸入的最大电流值为500mA</p></li></ol><h2 id="14、RFID的结构与组成、典型案例；"><a href="#14、RFID的结构与组成、典型案例；" class="headerlink" title="14、RFID的结构与组成、典型案例；"></a>14、RFID的结构与组成、典型案例；</h2><h3 id="概念-7"><a href="#概念-7" class="headerlink" title="概念"></a>概念</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>​         射频识别(RFID)技术是无线电广播技术和雷达技术的结合，又称为电子标签技术。</p><p>​            RFID技术通过<strong>无线射频信号</strong>实现非接触方式下的<strong>双向通信</strong>，完成对目标对象的<strong>自动识别和数据的读写操作</strong>，是物流过程中实施货品跟踪的一种很有效的技术。</p><h4 id="构成：-1"><a href="#构成：-1" class="headerlink" title="构成："></a>构成：</h4><p>​    典型的RFID系统主要由<strong>读写器</strong>、<strong>电子标签</strong>、<strong>应用系统软件</strong>组成。</p><p><strong>读写器</strong></p><p>​    <strong>读写器主要负责与电子标签的双向通信，同时接收来自主机系统的控制指令。</strong>读写器的频率决定了RFID系统工作的频段，其功率决定了射频识别的有效距离。根据结构和技术的不同，读写器可以是读或读写装置，是RFID系统<strong>信息控制和处理中心</strong>。</p><p><strong>电子标签</strong></p><p>​    电子标签(Electronic Tag)也称为智能标签 (Smart Tag) ，是<strong>由IC芯片和无线通信天线组成的超微型的小标签，其内置的射频天线用于和读写器进行通信。</strong>电子标签是RFID系统中真正的<strong>数据载体</strong>。系统工作时读写器发出查询信号，若为无源标签，接收到的查询信号的部分能量被整流为直流电能，供标签内的电路工作；部分能量则被电子标签内保存的数据信息调制后反射回读写器。</p><p><strong>应用系统软件</strong></p><p>​    应用系统软件包括<strong>中间件和应用软件</strong>。应用软件的主要作用是<strong>对阅读器上报的标签数据进行管理</strong>，针对应用需要，<strong>发送指令给阅读器以实现对标签的操作</strong>。在通信过程中，必须保证整体射频系统的通畅，正确和迅速地采集数据，确保数据读取内容的可靠性，以及有效地将数据传送到后端系统。传统的数据采集系统中数据采集与后端应用程序之间的数据分发是通过中间件架构解决，并发展出各种应用服务器软件。</p><p>​    中间件（middleware）是<strong>基础软件的一大类</strong>，属于<strong>可复用软件的范畴</strong>。中间件是一类<strong>连接软件组件和应用程序</strong>的<strong>计算机软件</strong>，它包括一组服务，以便运行在一台或多台机器上的多个软件<strong>通过网络进行交互</strong>。中间件位于客户机/服务器的操作系统之上，管理计算机资源和网络通讯，<strong>连接两个独立应用程序或独立系统的软件</strong>。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是<strong>信息传递</strong>。</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20231126223905376.png" alt="image-20231126223905376"></p><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><h4 id="按频率分类"><a href="#按频率分类" class="headerlink" title="按频率分类"></a>按频率分类</h4><ul><li>低频系统<ul><li>工作频率30~300kHz</li><li>标签的成本较低、标签内保存的数据量较少、阅读距离较短</li><li>门禁考勤管理、动物识别等。</li></ul></li><li>中高频系统<ul><li>工作频率3~30MHz</li><li>电子标签及读写器成本均较高，标签内保存的数据量较大，阅读距离较远</li><li>电子票证、电子身份证、小区物业管理等。</li></ul></li><li>特高频和微波系统<ul><li>300MHz～3GHz或大于3GHz</li><li>铁路车辆自动识别，还可用于公路车辆识别系统中。</li></ul></li></ul><h4 id="按照供电方式分类"><a href="#按照供电方式分类" class="headerlink" title="按照供电方式分类"></a><strong>按照供电方式分类</strong></h4><ul><li>无源供电系统<ul><li>无源系统内标签所需的工作能量需要从<strong>读写器发出的射频波束中获取</strong></li></ul></li><li>有源供电系统<ul><li>有源标签本身带有微型电池，由于不需要射频供电，其识别距离更远，读写器需要的功率较小。</li></ul></li></ul><h4 id="按照工作方式分类"><a href="#按照工作方式分类" class="headerlink" title="按照工作方式分类"></a><strong>按照工作方式分类</strong></h4><ul><li>全双工系统<ul><li>数据在<strong>读写器和电子标签</strong>之间的<strong>双向传输是同时进行的</strong>，并且从读写器到电子标签的能量传输是<strong>连续</strong>的，与传输的方向无关</li></ul></li><li>半双工系统<ul><li>从读写器到电子标签的数据传输和从电子标签到读写器的数据传输是<strong>交替进行</strong>的，并且从读写器到电子标签的能量传输是<strong>连续的</strong>，与传输方向无关</li></ul></li><li>时序系统<ul><li>从电子标签到读写器的数据传输是在电子标签的<strong>能量供应间歇****时进行的，而从读写器到电子标签的能量传输</strong>总是在限定的时间间隔内进行**。</li><li>要求系统必须有足够大容量的<strong>辅助电容器</strong>或<strong>辅助电池</strong>对电子标签进行能量补偿。</li></ul></li></ul><h4 id="按照技术方式分类"><a href="#按照技术方式分类" class="headerlink" title="按照技术方式分类"></a><strong>按照技术方式分类</strong></h4><ul><li><p><strong>主动广播式</strong></p><ul><li><strong>实现起来最简单</strong>。电子标签采用<strong>有源方式</strong>工作，并实时将储存的标识信息向外广播，读写器相当于一个只收不发的接收机。</li></ul><p>优点</p><ul><li>电能充足、工作可靠性高、信号传输距离远</li></ul><p>缺点</p><ul><li>电子标签必须不停地向外发射信息，既费电，又对环境造成电磁污染。</li></ul></li><li><p><strong>被动倍频式</strong></p><ul><li><strong>实现起来有一定难度</strong>。读写器<strong>发出射频查询信号</strong>，电子标签<strong>返回的信号</strong>载频为读写器发出射频的倍频。</li></ul></li><li><p><strong>反射调制式</strong></p><ul><li><strong>实现起来要解决同频收发问题</strong></li><li>读写器发出<strong>微波查询（能量）信号</strong>，电子标签（无源）将部分接收到的微波查询能量信号整流为直流电<strong>供电</strong>子标签内的电路工作，另一部分微波能量信号被电子标签<strong>内保存的数据信号调制（ASK）后反射回读写器</strong>。读写器接收到反射回的幅度调制信号后，从中解析出电子标签所保存的标识数据信息。</li></ul></li></ul><p>考试题型：问答（70分）、计算与分析（15分）、综合论述题（15分）</p>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>传感器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>汇编语言</title>
    <link href="/2023/11/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/"/>
    <url>/2023/11/22/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80/</url>
    
    <content type="html"><![CDATA[<p>一、    选择题（5X2’=10’）<br>二、    填空题（6X2’=12’）<br>三、    简答题（4X7’=28’）</p><ul><li>有哪几种寄存器名</li></ul><p>四、    程序分析与填空题（4X7’=28’）</p><ul><li>给一个程序段，填程序空缺</li><li>简单题类似p22页 习题2.3</li><li>做好课后习题</li></ul><p>五、    程序设计题（2X7’=14’）</p><p>六、    论述题（1X8’=8’）</p><ul><li>开放性</li></ul><p><strong>搞熟例题和习题</strong></p><p>第一章</p><ul><li><p>论述题为什么要学汇编语言</p></li><li><p>进制转换</p></li><li><p>补码</p></li></ul><p>第二章</p><ul><li>背寄存器有哪些2.3</li><li>简单题类似习题2.3</li><li>习题2.5不会考这么难的题</li></ul><p>第三章 </p><ul><li>p31 例3.1  3.2   p42 表3-1(输出字符，缓冲区)</li><li>熟悉汇编语言工作环境，编译过程步骤<ul><li>程序跟踪调试</li></ul></li><li>功能调用命令 36页 37页填空题，用了哪些命令</li><li>DOS命令</li></ul><p>第四章(重点)</p><ul><li>几种寻址方式(填空选择)</li><li>框图</li></ul><p>第五章</p><ul><li>熟悉指令  ：  常用的加法、减法</li><li>69页类型扩展 70页 例5.17/5.18</li><li><strong>BCD码命令</strong></li><li>85页-87 例5.39 5.40搞清楚程序设计需要哪几部分<ul><li>数据段，代码段定义。主程序，关联</li><li>就算主程序写不出来，也要把常规步骤写出来</li></ul></li><li>程序设计涉及到程序转移指令<ul><li>跳转</li></ul></li><li>习题 5.9  5.5  5.17  5.19  5.20</li><li><strong>p78 例题5.29综合性例题</strong></li></ul><p>第六章伪指令</p><ul><li>宏指令不考</li><li>清楚指令和伪指令的定义和应用场景</li><li>伪指令的定义方法和格式</li><li>p103 ~ p107 所有例体<ul><li>(ORZ /$)包括操作符</li></ul></li><li>p107页 例题6.9根据 程序画图例</li><li>习题6.1 6.7</li></ul><p>第七章分支循环</p><ul><li>例题7.2  7.3</li><li>分支向量表概念  </li><li>循环没时间可以不看</li><li>习题7.1   7.2  7.6  </li></ul><p>第八章</p><ul><li>8.1 p136  过程定义与过程结构</li></ul><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20231112153801726.png"/><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-计算机中数据的表示"><a href="#1-计算机中数据的表示" class="headerlink" title="1.计算机中数据的表示"></a>1.计算机中数据的表示</h3><h4 id="1-1-不同进制"><a href="#1-1-不同进制" class="headerlink" title="1.1 不同进制"></a>1.1 不同进制</h4><table><thead><tr><th align="center">进制</th><th align="center">代表</th></tr></thead><tbody><tr><td align="center">二进制</td><td align="center">B</td></tr><tr><td align="center">八进制</td><td align="center">O</td></tr><tr><td align="center">十进制</td><td align="center">D</td></tr><tr><td align="center">十六进制</td><td align="center">H</td></tr></tbody></table><h4 id="1-2-进制转换"><a href="#1-2-进制转换" class="headerlink" title="1.2 进制转换"></a>1.2 进制转换</h4><blockquote><p>十六进制转十进制</p></blockquote><p>$$<br>5FH = 5<em>16^1+15</em>16^0 = 95D<br>$$</p><blockquote><p>二进制转十进制</p></blockquote><p>$$<br>101101.1B = 1<em>2^5+1</em>2^3+1<em>2^2+1</em>2^0+1*2^{-1} = 45.5D<br>$$</p><blockquote><p>十进制转二进制</p></blockquote><p> 8  4 2 1 法凑数</p><h4 id="1-3-带符号数的补码表示"><a href="#1-3-带符号数的补码表示" class="headerlink" title="1.3 带符号数的补码表示"></a>1.3 带符号数的补码表示</h4><blockquote><p>负数用补码表示</p></blockquote><p>方法：</p><ul><li>对正数各位取反，最低位加1</li></ul><p>$$<br>求[-3]_补<br>$$</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1</span><span class="hljs-string">.正数</span> <br><br><span class="hljs-string">​</span><span class="hljs-number">0000 </span><span class="hljs-number">0011</span><br><span class="hljs-number">2</span><span class="hljs-string">.各位取反</span><br><br><span class="hljs-string">​</span><span class="hljs-number">1111 </span><span class="hljs-number">1100</span><br><br><span class="hljs-number">3</span><span class="hljs-string">.最低位加1</span><br><br><span class="hljs-string">​</span><span class="hljs-number">1111 </span><span class="hljs-number">1101</span><br></code></pre></td></tr></table></figure><blockquote><p>补码的加减法</p></blockquote><ul><li>加法</li></ul><p>$$<br>[X+Y]_补 = [X]_补 + [Y]_补<br>$$</p><ul><li>减法</li></ul><p>$$<br>[X-Y]_补 = [X]_补 + [-Y]_补<br>$$</p><h4 id="1-4-无符号数"><a href="#1-4-无符号数" class="headerlink" title="1.4 无符号数"></a>1.4 无符号数</h4><blockquote><p> 数值范围</p></blockquote><p>8位二进制表示无符号数<br>$$<br>0 &lt;= N &lt;= 255<br>$$<br>16位二进制表示无符号数<br>$$<br>0 &lt;= N &lt;= 65525<br>$$</p><h3 id="2-习题"><a href="#2-习题" class="headerlink" title="2.习题"></a>2.习题</h3><ol><li>什么是机器语言：<strong>机器语言就是用二进制编码组成的机器指令的集合和一组使用机器指令的规则。</strong></li><li>什么是汇编语言：<strong>汇编语言是对机器指令中的操作码用英文单词的缩写描述，对操作数用标号、变量、常量描述。</strong></li><li>汇编语言的特点：<ol><li>与机器有关：移植性差，但可直接控制硬件。</li><li>程序效率高。</li><li>局限性：受指令的限制，如考虑存储单元等。</li><li>调试困难。</li></ol></li><li>汇编程序与汇编源程序的区别是什么：<strong>汇编源程序</strong>是指<strong>用汇编语言编写</strong>的程序，而<strong>汇编程序</strong>特指将汇编源程序<strong>汇编成目标文件</strong>的编译程序。</li></ol><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="1-存储器"><a href="#1-存储器" class="headerlink" title="1. 存储器"></a>1. 存储器</h3><h4 id="1-1-16位CPU"><a href="#1-1-16位CPU" class="headerlink" title="1.1 16位CPU"></a>1.1 16位CPU</h4><p>8086是16位结构的CPU ，16位结构的CPU结构特征</p><p>​    (1) 数据总线为16位</p><p>​    (2) 运算器一次最多可以处理16位的数据</p><p>​    (3) 寄存器的最大宽度位16位</p><p>​    (4) 寄存器和运算器之间的通路为16位</p><p>1.2 存储单位</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span>位 = <span class="hljs-number">1</span>个字节<br><span class="hljs-symbol">8 </span>bit = <span class="hljs-number">1</span> Byte<br><span class="hljs-number">2</span>个字节 = <span class="hljs-number">1</span>个字<br><span class="hljs-symbol">2 </span>Byte = <span class="hljs-number">1</span> word<br></code></pre></td></tr></table></figure><h3 id="2-寄存器"><a href="#2-寄存器" class="headerlink" title="2. 寄存器"></a>2. 寄存器</h3><blockquote><p>记住就完了</p><p>8086CPU所有寄存器都是16位，可以存放两个字节(一个字)</p></blockquote><p><strong>通用寄存器</strong></p><ol><li>AX：累加器。16位可分为AH高8位和AL低8位。</li><li>BX：基址寄存器，存放数据和内存的起始偏移地址。BH、BL</li><li>CX：计数寄存器，存放数据和存放重复操作的次数。CH、CL</li><li>DX：数据寄存器，存放数据和存放32位数据的高16位。DH、DL</li></ol><p><strong>地址寄存器</strong></p><ol><li>SP：堆栈指针，存放堆栈栈顶的偏移地址。</li><li>BP：基址指针，存放内存中数据的偏移地址。</li><li>SI：源变址寄存器，存放内存中源数据区的偏移地址；指在某些指令作用下它可以自动地递增或递减其中的值。</li><li>DI：目的变址寄存器，存放内存中目的数据区的偏移地址，并在某些指令作用下自动地递增或递减其中的值。</li></ol><p><strong>段寄存器</strong><br>$$<br>物理地址 = 段地址 * 16 + 偏移地址<br>$$</p><ul><li>分段方式中， 内存并没有分段 ， 段的划分来自于CPU</li><li>段地址和偏移地址都是16位二进制数</li><li>段地址 * 16相当于<strong>二进制向左移动四位</strong></li></ul><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs powershell">段基址位<span class="hljs-number">1896</span><span class="hljs-built_in">H</span>，偏移地址位<span class="hljs-number">1655</span><span class="hljs-built_in">H</span>，其物理地址为<br><br><span class="hljs-number">18960</span><span class="hljs-built_in">H</span> + <span class="hljs-number">1622</span><span class="hljs-built_in">H</span> = <span class="hljs-number">19</span>FB5<span class="hljs-built_in">H</span><br></code></pre></td></tr></table></figure><ol><li><p>CS：<strong>代码段</strong>寄存器，存放当前正在执行的程序段的段基址。</p><ul><li><strong>在编写汇编程序时，必须要有代码段</strong></li></ul></li><li><p>SS：<strong>堆栈段</strong>寄存器，存放堆栈段的段基址。</p></li><li><p>DS：<strong>数据段</strong>寄存器，存放数据段的段基址。</p></li><li><p>ES：<strong>附加段</strong>寄存器，存放另一个数据段的段基址。</p></li></ol><p><strong>指令指针寄存器</strong></p><p>IP：指令指针寄存器，存放即将执行指令的偏移地址。</p><p><strong>标志寄存器</strong></p><ol><li>FLAGS：存放CPU的两类状态。</li><li>状态标志：CF（进位）、PF（奇偶）、AF（辅助进位）、ZF（零）、SF（符号）和OF（溢出）</li><li>控制标志：TF、IF（中断）和DF（方向）</li></ol><table><thead><tr><th align="left">标志名（加粗重点）</th><th align="center">标志为1</th><th align="center">标志为0</th></tr></thead><tbody><tr><td align="left"><strong>OF 溢出（是/否）</strong></td><td align="center">OV</td><td align="center">NV</td></tr><tr><td align="left">DF 方向（减/增）</td><td align="center">DN</td><td align="center">UP</td></tr><tr><td align="left">IF 中断（允许/不允许）</td><td align="center">EI</td><td align="center">DI</td></tr><tr><td align="left"><strong>SF 符号（负/正）</strong></td><td align="center">NG</td><td align="center">PL</td></tr><tr><td align="left"><strong>ZF 零 （是/否）</strong></td><td align="center">ZR</td><td align="center">NZ</td></tr><tr><td align="left">AF 辅助进位（有/无）</td><td align="center">AC</td><td align="center">NA</td></tr><tr><td align="left">PF 奇偶（偶/奇）</td><td align="center">PE</td><td align="center">PO</td></tr><tr><td align="left"><strong>CF 进位（有/无）</strong></td><td align="center">CY</td><td align="center">NC</td></tr></tbody></table><p><strong>OF：溢出标志。</strong></p><p>对<strong>有符号数</strong>有效 (只有正数与正数相加、负数与负数相加才有可能溢出)</p><ul><li>OF=1表示有两个有符号数的运算结果超出了可以表示的范围，结果是错误的；</li><li>OF=0表示没有溢出，结果正确。</li><li>进行无符号数运算时也会产生新的OF标志（CPU不知道处理对象是否为有符号数），此时程序员可以不关心OF标志。// 因为计算机只计算二进制，所谓的有符号和无符号运算都是看程序员自己觉得的，对于有符号数程序员会利用补码定义负数</li></ul><p><strong>SF：符号标志。</strong>SF=1表示<strong>运算结果的最高位</strong>为“1“。</p><ul><li><p>对于<strong>有符号数</strong></p><ul><li>在溢出标志OF=0时，SF=1表示运算结果为负，SF=0表示运算结果非负(SF = 最高位的值)。</li><li><strong>OF=1时，由于结果是错误的，所以符号位也和正确值相反</strong>。例如：两个负数相加产生溢出，此时SF=0。</li></ul></li><li><p><strong>对于无符号数运算，SF无意义（但是可以看出结果的大小规模）。</strong></p></li></ul><p>**ZF：零标志。</p><ul><li>ZF=1表示运算结果为零，<strong>减法运算后</strong>结果为零意味着两个参加运算的数<strong>大小相等</strong>；</li><li>ZF=0，表示运算结果非零。</li></ul><p><strong>CF：进位/借位标志。</strong></p><p>对<strong>无符号数</strong>有效</p><p>无符号数的加减法 = 有符号数补码的加减法</p><ul><li><strong>CF=1</strong> 表示两个无符号数的<strong>加法</strong>运算有<strong>进位</strong>，或者是<strong>减法</strong>运算有<strong>借位</strong>，需要对它们的高位进行补充处理；<ul><li>做减法时，直接观察 (被减数&gt;减数 CF =1)</li><li>做加法时，可以转化为十进制，看是否超过255</li></ul></li><li>CF=0 表示没有产生进位或借位。</li><li>进行有符号数运算时也会产生新的CF标志，此时程序员可以不关心CF标志。</li></ul><p>DF：方向标志。</p><ul><li>DF=0时，每次执行字符串指令后，源或目的地址指针用加法自动修改地址；</li><li>DF=1时用减法来修改地址。它用来控制地址的变化方向。</li></ul><p>IF：终端允许标志。IF=1表示允许处理器响应可屏蔽中断请求信号，称为开中断，IF=0表示不允许处理器响应可屏蔽中断请求信号，称为关中断。</p><p>AF：辅助进位标志。在进行字操作时，低字节向高字节进位时，AF=1，否则为0。一般用于两个BCD数运算后调整结果用，对其他数的运算没有意义。</p><p>PF：奇偶标志 。PF=1表示运算结果的低8位中偶数个”1“；PF=0表示有奇数个”1“。它可以用来进行奇偶校验。</p><h3 id="3-32位80x86CPU的工作模式"><a href="#3-32位80x86CPU的工作模式" class="headerlink" title="3. 32位80x86CPU的工作模式"></a>3. 32位80x86CPU的工作模式</h3><blockquote><p>三种工作模式 ：  实模式、保护模式、虚拟8086模式</p></blockquote><h4 id="1-实模式"><a href="#1-实模式" class="headerlink" title="1.实模式"></a>1.实模式</h4><p>为了兼容16位机的特点</p><ul><li>MS DOS 只能在实模式下运行</li></ul><h4 id="2-保护模式"><a href="#2-保护模式" class="headerlink" title="2.保护模式"></a>2.保护模式</h4><p>主要工作模式</p><ul><li>全部地址线参与寻址</li><li>Windows系统及应用程序在保护模式下运行</li></ul><h4 id="3-虚拟8086模式"><a href="#3-虚拟8086模式" class="headerlink" title="3.虚拟8086模式"></a>3.虚拟8086模式</h4><p>生成多个虚拟8086CPU，以便在运行实模式下的8086程序</p><ul><li>Windows下打开的DOS窗口运行一个DOS应用程序，程序久运行在虚拟8086模式下。</li></ul><h3 id="4-习题"><a href="#4-习题" class="headerlink" title="4.习题"></a>4.习题</h3><ol><li><p>简述计算机系统组成：</p><p>计算机由中央处理器CPU、存储器、输入系统和输出系统组成，由系统总线连接在一起。CPU包括运算器和控制器，运算器执行指令、控制器负责计算机的控制。存储器是计算机的记忆部件，以二进制形式存放程序和数据。输入输出系统包括大容量存储器，如硬盘。以及其他外设，如鼠标、键盘、显示器等。</p></li><li><p>简述16位机的各类寄存器的主要作用：参考本章<strong>2. 寄存器</strong></p></li><li><p>写出每条汇编指令执行后的相关寄存器的值：</p><ol><li>Mov ax, 1345H  ax = <u>1345H</u></li><li>Mov ah, 24H ax = <u>2445H</u></li><li>Mov al, 45H ax = <u>2445H</u></li><li>Mov bx, 3412H bx = <u>3412H</u></li><li>Mov al, bh ax = <u>2434H</u></li><li>Mov ah, bl ax = <u>1234H</u></li></ol></li><li><p>实模式下，写出段地址和偏移地址为1234:2002、1430:0042、FF00:0FFF的物理地址。(物理地址 = 段地址 * 16 + 偏移地址)</p><ol><li>$1234:2002 =&gt; 12340H + 2002H = 14342H$</li><li>$1430:0042 =&gt; 14300H + 0042H = 14342H$</li><li>$FF00:0FFF =&gt; FF000H + 0FFFH = FFFFFH$</li></ol></li><li><p>下列各数均为十进制数，请采用8位二进制补码运算，并回答标志寄存器FLAGS中CF和OF的值，运算结果所代表的十进制数是多少？如果用16位二进制补码运算，其结果所代表的十进制数是多少？FLAGS中CF和OF的值呢？</p><ol><li><p>86+69 // 题目是85+69 我直接将错就错<br>$86=0101\ 0110_2,69=0100\ 0101_2$<br>$86+69=0101\ 0110_2+0100\ 0101_2=1001\ 1011_2$</p><p>补码转换$1001\ 1011_2\ =&gt; -0110\ 0101_2$此时十进制数为$-101$<br><strong>因为溢出OF=1，没有进位CF=0，最高位为1故符号位SF=1，计算结果不为零ZF=0</strong><br>16位下：$005BH$十进制数为$155$<br><strong>没有溢出OF=0，没有进位CF=0，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong></p></li><li><p>86+(-69)<br>$86=0101\ 0110_2,-69=-0100\ 0101_2=1011\ 1011_2$<br>$86+(-69)=0101\ 0110_2+1011\ 1011_2=1\ 0001\ 0001_2$<br>补码转换$0001\ 0001_2=&gt;0001\ 0001_2$此时十进制数为$17$<br><strong>因为没溢出OF=0，有进位CF=1，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong><br>16位下：$0011H$十进制为$17$<br><strong>因为没溢出OF=0，没进位CF=0，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong></p></li><li><p>86-(-69) // 加法看进位，减法看借位</p><p>$86=0101\ 0110_2,-69=-0100\ 0101_2=1011\ 1011_2$<br>$86-(-69)=&gt;（无符号） 86-187=0101\ 0110_2-1011\ 1011_2=0101\ 0110_2 + 0100\ 0101_2=1001\ 1011_2$<br>补码转换$1001\ 1011_2\ =&gt; -0110\ 0101_2$此时十进制数为$-101$<br><strong>因为溢出OF=1，有借位CF=1，最高位为1故符号位SF=1，计算结果不为零ZF=0</strong><br>16位下：$005BH$十进制数为$155$<br><strong>没有溢出OF=0，有借位CF=1，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong></p></li><li><p>86-(69)<br>$86=0101\ 0110_2,69=0100\ 0101_2$<br>$86-69=0101\ 0110_2-0100\ 0101_2=0101\ 0110_2+1011\ 1011_2=1\ 0001\ 0001_2$</p><p>补码转换$0001\ 0001_2=&gt;0001\ 0001_2$此时十进制数为$17$<br><strong>因为没溢出OF=0，无借位CF=0，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong><br>16位下：$0011H$十进制数为$17$<br><strong>没有溢出OF=0，没有借位CF=0，最高位为0故符号位SF=0，计算结果不为零ZF=0</strong></p></li></ol></li><li><p>给定段地址为0001H，仅通过变化偏移地址寻址，CPU的寻址范围从__到__<br>答：偏移地址16位从0000H~FFFFH<br><strong>故寻址从00010H+0000H ~ 00010H+FFFFH 即00010H到1000FH</strong></p></li><li><p>有一数据存放在内存20000H单元中，现给定段地址为SA，若想从偏移地址寻到此单元，则SA应满足的条件是：最小为__，最大为__。<br>答：偏移地址16位从0000H~FFFFH<br>寻址到20000H，最小为(20000H-FFFFH=10001H)<strong>除10H</strong>向上取整得到<strong>1001H</strong>，则最大为(20000H-0000H)除10H向下取整得到<strong>2000H</strong>。</p><ul><li>除10H即除16</li></ul></li><li><p>已知8086系统某存储单元物理地址为：52506H，你认为段基址的最大值、最小是分别是多少？8086微机最多可以有多少个不同的段基址？</p><p>答：同上计算，最大：52506H/10H向下取整得到5250H(偏移地址为0)，最小：(52506H-FFFFH)/10H向上取整得到4251H。<br><strong>段地址16位，故最多有$2^{16}=65536$个段基址。</strong></p></li><li><p>从物理地址为00100H开始到00103H单元中顺序存放的数据为：12H、34H、56H，78H。请画出数据存放示意图，并回答以下问题：<br><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20231112163008184.png" alt="image-20231112163008184"></p><ol><li>写出地址00101H<strong>字节</strong>单元的内容；<br>答：34H</li><li>写出地址00102H<strong>字节</strong>单元的内容<br>答：56H，<strong>若为字单元则7856H（小端：低字节低地址，高字节高地址）</strong></li></ol></li></ol><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="1-立即寻址方式"><a href="#1-立即寻址方式" class="headerlink" title="1.立即寻址方式"></a>1.立即寻址方式</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><ul><li><p><strong>操作数直接写在指令中</strong></p></li><li><p>用途： 用于<strong>直接指定一个常数</strong>送给寄存器</p></li></ul><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>8086中立即数是8位或者16位</li><li>立即寻址原来表示常数</li><li>立即寻址方式只能用于源操作数字段</li><li>立即数的类型必须与目的操作数的类型一致</li></ul><h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span> , <span class="hljs-number">6H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">12AFH</span><br></code></pre></td></tr></table></figure><h3 id="2-寄存器寻址方式"><a href="#2-寄存器寻址方式" class="headerlink" title="2.寄存器寻址方式"></a>2.寄存器寻址方式</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><ul><li><p>操作数就是<strong>寄存器中的值</strong></p><ul><li>指令中给出寄存器名</li></ul></li><li><p>用途： 用于指定2个寄存器作为操作数</p></li></ul><h4 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a><strong>注意</strong></h4><ul><li>指令执行不需要访问内存因而执行速度快</li></ul><h4 id="举例-1"><a href="#举例-1" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">BX</span><br></code></pre></td></tr></table></figure><h3 id="3-直接寻址方式"><a href="#3-直接寻址方式" class="headerlink" title="3.直接寻址方式"></a>3.直接寻址方式</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><ul><li><p>操作数的有效地址EA(偏移地址)就在指令中  <strong>指令中直接给出了操作数的有效地址</strong></p><ul><li><p>由于存储器各个段的段地址已分别由各个段寄存器存放，只要知道偏移地址就能求出其物理地址</p></li><li><p>操作数的段地址为数据段，<strong>由DS指出，即操作数本身存放在数据段中</strong></p></li></ul></li></ul><h4 id="举例-2"><a href="#举例-2" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">DS</span>:[<span class="hljs-number">4050</span>]<br>方括号中的数值作为操作数的偏移地址(有效地址)<br><br>操作数的物理地址 = (<span class="hljs-built_in">DS</span>) * <span class="hljs-number">10H</span> + EA<br></code></pre></td></tr></table></figure><h4 id="注意-2"><a href="#注意-2" class="headerlink" title="注意"></a>注意</h4><ul><li>编写汇编源程序.asm文件时 ， 对于直接寻址方式而言，必须用前缀 “ DS: “中指出该单元在数据段中<ul><li>DS:[2000H]代表一个数据段的存储单元，偏移地址为2000H</li><li>没写前缀DS: ，2000H代表的是立即数</li></ul></li><li>在Debug的A命令输入命令(执行汇编指令)，就不要加上前缀，系统默认为数据段</li></ul><h3 id="4-寄存器间接寻址方式"><a href="#4-寄存器间接寻址方式" class="headerlink" title="4.寄存器间接寻址方式"></a>4.寄存器间接寻址方式</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><ul><li>操作数的有效地址EA就在寄存器中<ul><li>不是把寄存器的内容作为操作数，而是<strong>把寄存器的内容作为操作数的地址，而操作数还在内存中。</strong></li></ul></li><li>用途： 适用于简单的表格处理<ul><li>用寄存器间接指向一个内存单元，寄存器的值不同，指向的内存单元的地址就不同，常用于循环程序中</li></ul></li></ul><h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><ul><li>寄存器间接寻址只允许 <strong>BX BP SI DI</strong> 这四个寄存器作为间接地址寄存器</li></ul><p>SI为源变址寄存器，DI为目的变址寄存器，BP为基址寄存器</p><ul><li>BX BP SI 默认DS作段地址寄存器</li><li>BP 默认 SS作段地址寄存器</li></ul><h4 id="举例-3"><a href="#举例-3" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BX</span>]<br>已知 ( <span class="hljs-built_in">DS</span> ) = <span class="hljs-number">1500H</span> , ( <span class="hljs-built_in">BX</span> ) = <span class="hljs-number">4580H</span><br>则 EA = ( <span class="hljs-built_in">BX</span> ) = <span class="hljs-number">4580H</span><br>物理地址 = <span class="hljs-number">15000H</span> + <span class="hljs-number">4580H</span> = <span class="hljs-number">19580H</span><br>若 (<span class="hljs-number">19580H</span>) = <span class="hljs-number">4580H</span><br>(<span class="hljs-built_in">AX</span>) = <span class="hljs-number">4589H</span><br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">SS</span>:[<span class="hljs-built_in">DI</span>] , <span class="hljs-built_in">AX</span><br>已知(<span class="hljs-built_in">ES</span>) = <span class="hljs-number">2500H</span>, (<span class="hljs-built_in">DI</span>) = <span class="hljs-number">5138H</span><br>则 (EA) = <span class="hljs-number">25000H</span> + <span class="hljs-number">5138H</span> = <span class="hljs-number">2A318H</span><br>若 (<span class="hljs-built_in">AX</span>) = <span class="hljs-number">2468H</span><br>则 (<span class="hljs-number">2A318H</span>) = <span class="hljs-number">68H</span><br>   (<span class="hljs-number">2A319H</span>) = <span class="hljs-number">24H</span><br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BX</span>]/[<span class="hljs-built_in">SI</span>]/[<span class="hljs-built_in">DI</span>]   默认<span class="hljs-built_in">DS</span>寄存器作段地址<br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BP</span>]默认<span class="hljs-built_in">SS</span>寄存器<br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">ES</span>:[<span class="hljs-built_in">DI</span>] , <span class="hljs-built_in">AX</span>指定<span class="hljs-built_in">ES</span>寄存器<br></code></pre></td></tr></table></figure><h3 id="5-寄存器相对寻址方式"><a href="#5-寄存器相对寻址方式" class="headerlink" title="5.寄存器相对寻址方式"></a>5.寄存器相对寻址方式</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><ul><li><p>操作数的有效地址EA是一个<strong>寄存器和位移量</strong>之和(比寄存器间接寻址多一个位移量)</p><ul><li><p><strong>默认搭配是DS段寄存器和BX,SI,DI</strong></p></li><li><p><strong>SS段寄存器和BP</strong></p></li></ul></li><li><p> <strong>操作数物理地址 =  (DS)  * 10H + (BX) + 8位(16)位位移量</strong></p></li><li><p> 用途： 常用于查表操作 用于访问一维数组</p></li></ul><h4 id="举例-4"><a href="#举例-4" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , TOP[<span class="hljs-built_in">SI</span>]<br><br>TOP为位移量<br>已知(<span class="hljs-built_in">DS</span>) = <span class="hljs-number">1500H</span> (<span class="hljs-built_in">SI</span>) = <span class="hljs-number">7310H</span> ,TOP = <span class="hljs-number">25H</span><br>则有效地址EA = TOP + (<span class="hljs-built_in">SI</span>) = <span class="hljs-number">7310H</span> + <span class="hljs-number">25H</span> = <span class="hljs-number">7335H</span><br>物理地址 = (<span class="hljs-built_in">DS</span>) * <span class="hljs-number">10H</span> + EA = <span class="hljs-number">15000H</span> + <span class="hljs-number">7335H</span> = <span class="hljs-number">1C335H</span><br>若 (<span class="hljs-number">1C335H</span>) = <span class="hljs-number">2428H</span><br>则 (<span class="hljs-built_in">AX</span>) = <span class="hljs-number">2428H</span><br></code></pre></td></tr></table></figure><blockquote><p>这三条指令是等效的</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , ARRY[<span class="hljs-built_in">BX</span>]<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [ARRY][<span class="hljs-built_in">BX</span>]<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [ARRY+<span class="hljs-built_in">BX</span>]<br></code></pre></td></tr></table></figure><blockquote><p>这两条指令是等效的</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> [<span class="hljs-built_in">BX</span>].<span class="hljs-number">2623H</span> , <span class="hljs-built_in">AX</span><br><span class="hljs-keyword">MOV</span> [<span class="hljs-built_in">BX</span>+<span class="hljs-number">2623H</span>] , <span class="hljs-built_in">AX</span><br></code></pre></td></tr></table></figure><h3 id="6-基址变址寻址方式"><a href="#6-基址变址寻址方式" class="headerlink" title="6.基址变址寻址方式"></a>6.基址变址寻址方式</h3><h4 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h4><ul><li>操作数的有效地址是一个<strong>基址寄存器和一个变址寄存器</strong>的内容之和</li></ul><h4 id="注意-3"><a href="#注意-3" class="headerlink" title="注意"></a>注意</h4><ul><li>允许使用的基址寄存器为  <strong>BX 和 BP</strong></li><li>允许使用的变址寄存器为  <strong>SI  和  DI</strong></li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">物理地址 = ( <span class="hljs-built_in">DS</span> ) * <span class="hljs-number">10H</span> + ( <span class="hljs-built_in">BX</span> ) + ( <span class="hljs-built_in">DI</span> )<br>物理地址 = ( <span class="hljs-built_in">DS</span> ) * <span class="hljs-number">10H</span> + ( <span class="hljs-built_in">BX</span> ) + ( <span class="hljs-built_in">SI</span> )<br>物理地址 = ( <span class="hljs-built_in">SS</span> ) * <span class="hljs-number">10H</span> + ( <span class="hljs-built_in">BP</span> ) + ( <span class="hljs-built_in">DI</span> )<br>物理地址 = ( <span class="hljs-built_in">SS</span> ) * <span class="hljs-number">10H</span> + ( <span class="hljs-built_in">BP</span> ) + ( <span class="hljs-built_in">SI</span> )<br></code></pre></td></tr></table></figure><h4 id="举例-5"><a href="#举例-5" class="headerlink" title="举例"></a>举例</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">DI</span>]<br>已知 (<span class="hljs-built_in">DS</span>) = <span class="hljs-number">2100H</span>, (<span class="hljs-built_in">BX</span>) = <span class="hljs-number">0158H</span> (<span class="hljs-built_in">DI</span>) = <span class="hljs-number">10A5H</span> (221FD) = <span class="hljs-number">34H</span>, (221FE) = <span class="hljs-number">95H</span> ,(<span class="hljs-built_in">AX</span>) =<span class="hljs-number">0FFFFH</span><br>有效地址EA = (<span class="hljs-built_in">BX</span>) + (<span class="hljs-built_in">DI</span>) = <span class="hljs-number">0158H</span> + <span class="hljs-number">10A5H</span> = <span class="hljs-number">11FDH</span><br>物理地址 = (<span class="hljs-built_in">DS</span>) * <span class="hljs-number">10H</span> + EA = <span class="hljs-number">21000H</span> + <span class="hljs-number">11FDH</span> =<span class="hljs-number">221FDH</span><br>执行后 (<span class="hljs-built_in">AX</span>) = <span class="hljs-number">953AH</span><br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>, [<span class="hljs-built_in">BX</span>][<span class="hljs-built_in">SI</span>]  默认<span class="hljs-built_in">DS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>, [<span class="hljs-built_in">BP</span>][<span class="hljs-built_in">DI</span>]默认<span class="hljs-built_in">SS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>, <span class="hljs-built_in">ES</span>:[<span class="hljs-built_in">BX</span>][<span class="hljs-built_in">DI</span>] 指定<span class="hljs-built_in">ES</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DX</span>, [<span class="hljs-built_in">BP</span>][<span class="hljs-built_in">SI</span>]默认<span class="hljs-built_in">SS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> [<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">DI</span>] , <span class="hljs-built_in">CX</span>默认<span class="hljs-built_in">DS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> [<span class="hljs-built_in">BP</span>+<span class="hljs-built_in">SI</span>] , <span class="hljs-built_in">AL</span>默认<span class="hljs-built_in">SS</span>寄存器作段地址<br></code></pre></td></tr></table></figure><h3 id="7-相对基址变址寻址方式"><a href="#7-相对基址变址寻址方式" class="headerlink" title="7.相对基址变址寻址方式"></a>7.相对基址变址寻址方式</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><ul><li>有效地址是一个<strong>基址寄存器和一个变址寄存器以及一个位移量</strong>之和(比基址变址寻址多一个位移量)</li><li>用途： 可以用于二维数组的处理</li></ul><h4 id="注意-4"><a href="#注意-4" class="headerlink" title="注意"></a>注意</h4><ul><li>允许使用的基址寄存器为BX和BP</li><li>允许使用的变址寄存器为SI和DI</li><li>位移量可以为常量或者符号地址</li></ul><h4 id="举例-6"><a href="#举例-6" class="headerlink" title="举例"></a>举例</h4><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">物理地址 = <span class="hljs-comment">(DS)</span> * <span class="hljs-number">10</span> H + <span class="hljs-comment">(BX)</span> + <span class="hljs-comment">(DI)</span> + <span class="hljs-number">8</span>位<span class="hljs-comment">(16位)</span>位移量<br>物理地址 = <span class="hljs-comment">(DS)</span> * <span class="hljs-number">10</span> H + <span class="hljs-comment">(BX)</span> + <span class="hljs-comment">(SI)</span> + <span class="hljs-number">8</span>位<span class="hljs-comment">(16位)</span>位移量<br>物理地址 = <span class="hljs-comment">(SS)</span> * <span class="hljs-number">10</span> H + <span class="hljs-comment">(BP)</span> + <span class="hljs-comment">(SI)</span> + <span class="hljs-number">8</span>位<span class="hljs-comment">(16位)</span>位移量<br>物理地址 = <span class="hljs-comment">(SS)</span> * <span class="hljs-number">10</span> H + <span class="hljs-comment">(BP)</span> + <span class="hljs-comment">(DI)</span> + <span class="hljs-number">8</span>位<span class="hljs-comment">(16位)</span>位移量<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">以下三种表达方式是等效的 EA = MASK+(<span class="hljs-built_in">BX</span>)+(<span class="hljs-built_in">SI</span>) 物理地址 = (<span class="hljs-built_in">DS</span>) * <span class="hljs-number">10H</span> + EA<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , MASK[<span class="hljs-built_in">BX</span>][<span class="hljs-built_in">SI</span>]默认<span class="hljs-built_in">DS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [MASK+<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">SI</span>]默认<span class="hljs-built_in">DS</span>寄存器作段地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">SI</span>] .MASK  默认<span class="hljs-built_in">DS</span>寄存器作段地址<br></code></pre></td></tr></table></figure><h3 id="8-总结"><a href="#8-总结" class="headerlink" title="8.总结"></a>8.总结</h3><ul><li>不管变量的类型如何， 其有效地址总是16位</li></ul><h4 id="1-错误操作"><a href="#1-错误操作" class="headerlink" title="1)错误操作"></a>1)错误操作</h4><blockquote><p>双操作数指令的两个操作数，长度必须匹配</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">AH</span> <span class="hljs-comment">; AX为16位，AH为8位</span><br></code></pre></td></tr></table></figure><blockquote><p>双操作数指令的两个操作数中，不能两个操作数同为内存单元</p><p>​    因为CPU与内存交换数据，通过地址线选中该内存单元，不能两个操作数同时经过数据线对内存单元进行读出或者写入</p></blockquote><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css">MOV <span class="hljs-selector-tag">B</span> , <span class="hljs-selector-tag">A</span><br>MOV <span class="hljs-selector-attr">[BX]</span> , <span class="hljs-selector-attr">[DI]</span><br></code></pre></td></tr></table></figure><h3 id="9-习题"><a href="#9-习题" class="headerlink" title="9.习题"></a>9.习题</h3><ol><li>指出以下指令的寻址方式，array是变量。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-number">9</span><span class="hljs-comment">;立即数寻址</span><br>(<span class="hljs-number">2</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">BYTE</span> <span class="hljs-built_in">PTR</span>[<span class="hljs-built_in">BX</span>],<span class="hljs-number">9</span><span class="hljs-comment">;寄存器间接</span><br>(<span class="hljs-number">3</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span>,[<span class="hljs-built_in">DI</span>]<span class="hljs-comment">;寄存器寻址</span><br>(<span class="hljs-number">4</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">BX</span><span class="hljs-comment">;寄存器寻址</span><br>(<span class="hljs-number">5</span>)<span class="hljs-keyword">MOV</span>[<span class="hljs-built_in">SI</span>+<span class="hljs-built_in">BX</span>],<span class="hljs-number">9</span><span class="hljs-comment">;基址变址寻址</span><br>(<span class="hljs-number">6</span>)<span class="hljs-keyword">MOV</span>ARRAY[<span class="hljs-built_in">BX</span>],<span class="hljs-built_in">CX</span><span class="hljs-comment">;寄存器相对</span><br>(<span class="hljs-number">7</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,ARRAY+<span class="hljs-number">9</span><span class="hljs-comment">;直接寻址</span><br>(<span class="hljs-number">8</span>)<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,ARRAY[<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">DI</span>]<span class="hljs-comment">;相对基址寻址</span><br></code></pre></td></tr></table></figure><ol start="2"><li>假定(DS)=1200H，(SS)=4400H，(BX)=463DH，(BP)=2006H，(SI)=6A00H，位移量D=4524H，以AX寄存器为目的操作数，试写出以下各种寻址方式下的传送指令，并确定源操作数的有效地址EA和物理地址。</li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">(<span class="hljs-number">1</span>)立即寻址：<span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span>,D  =&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">4524H</span><br>(<span class="hljs-number">2</span>)直接寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">DS</span>:[D]=&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">12000H</span>+<span class="hljs-number">4524H</span> = <span class="hljs-number">16524H</span><br>(<span class="hljs-number">3</span>)使用<span class="hljs-built_in">BX</span>的寄存器寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">BX</span>=&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">463DH</span><br>(<span class="hljs-number">4</span>)使用<span class="hljs-built_in">BX</span>的间接寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BX</span>]=&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">12000H</span>+<span class="hljs-number">463DH</span> = <span class="hljs-number">1663DH</span><br>(<span class="hljs-number">5</span>)使用<span class="hljs-built_in">BP</span>的寄存器相对寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BP</span>+D] =&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">44000H</span>+<span class="hljs-number">2006H</span>+<span class="hljs-number">4524H</span> = <span class="hljs-number">4A52AH</span><br>(<span class="hljs-number">6</span>)基址变址寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">SI</span>]=&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">12000H</span>+<span class="hljs-number">463DH</span>+<span class="hljs-number">6A00H</span> = <span class="hljs-number">1D03DH</span><br>(<span class="hljs-number">7</span>)相对基址变址寻址：<span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BX</span>+<span class="hljs-built_in">SI</span>+D]=&gt; <span class="hljs-built_in">AX</span> = <span class="hljs-number">12000H</span>+<span class="hljs-number">463DH</span>+<span class="hljs-number">6A00H</span>+<span class="hljs-number">4524H</span>=<span class="hljs-number">21561H</span><br></code></pre></td></tr></table></figure><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><h3 id="1-数据传送指令"><a href="#1-数据传送指令" class="headerlink" title="1.数据传送指令"></a>1.数据传送指令</h3><h4 id="1）MOV-传送指令"><a href="#1）MOV-传送指令" class="headerlink" title="1）MOV 传送指令"></a>1）MOV 传送指令</h4><h4 id="规定"><a href="#规定" class="headerlink" title="规定"></a>规定</h4><ul><li>操作数与目的操作数的长度必须  <strong>明确且一致</strong><ul><li>MOV AH , 258</li></ul></li><li>目的操作数与源操作数  <strong>不能同为存储器</strong> ， 不允许在两个存储单元直接直接传送数据<ul><li>MOV [AX] , [DI]</li></ul></li><li>目的操作数不能为 CS 或 IP , 因为CS:IP要指向的是当前要执行的指令所在的地址</li><li>目的操作数不可以是立即数</li></ul><h4 id="注意-5"><a href="#注意-5" class="headerlink" title="注意"></a>注意</h4><blockquote><p>段地址寄存器(DS SS CS ES)必须通过寄存器得到段地址，不能直接由符号地址、段寄存器、立即数得到</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">以下都是错误的<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DS</span> , DATA_SEG符号地址<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DS</span> , <span class="hljs-built_in">ES</span>段寄存器<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DS</span> , <span class="hljs-number">1234</span>立即数<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CS</span> , <span class="hljs-built_in">AX</span> 指令合法，但是代码寄存器不能赋值(一个程序至少要有<span class="hljs-built_in">CS</span>寄存器)<br></code></pre></td></tr></table></figure><h4 id="2）PUSH-进栈指令"><a href="#2）PUSH-进栈指令" class="headerlink" title="2）PUSH 进栈指令"></a>2）PUSH 进栈指令</h4><h4 id="格式"><a href="#格式" class="headerlink" title="格式"></a>格式</h4><ul><li>  PUSH    SRC    将源操作数压入堆栈</li></ul><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><p>SRC为源操作数</p><ul><li>( SP ) &lt;— ( SP ) - 2</li><li>(( SP ) + 1  , (SP)) &lt;— ( SRC )</li></ul><p>指令将源操作数压入堆栈 ， 目的操作数的地址由 SS:SP 指出 ， SP总是指向栈顶(大地址)</p><p>入栈时， 要将栈顶指针 SP 减2(2个字节，16位) ， 来指向新的内存地址接受16位源操作数 ， 并且同时指向新的栈顶</p><h4 id="3）POP-出栈指令"><a href="#3）POP-出栈指令" class="headerlink" title="3）POP 出栈指令"></a>3）POP 出栈指令</h4><h4 id="格式-1"><a href="#格式-1" class="headerlink" title="格式"></a>格式</h4><ul><li>POP    DST</li></ul><h4 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h4><p>DST表示目的操作数</p><ul><li>( DST ) &lt;— (( SP ) + 1 , ( SP ))</li><li>( SP ) &lt;— ( SP ) + 2</li></ul><p>堆栈中源操作数地址由 SS:SP  指出</p><p>源操作数弹出后 ， SP + 2 ，下移一个字， 指向新的栈顶</p><h4 id="举例-7"><a href="#举例-7" class="headerlink" title="举例"></a>举例</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs inform7">PUSH<span class="hljs-comment">[2018]</span>  ;把地址为DS:<span class="hljs-comment">[2018]</span>的字送往栈顶<br>POP<span class="hljs-comment">[2018]</span>；把栈顶的字送往地址为DS:<span class="hljs-comment">[2018]</span>的内存<br></code></pre></td></tr></table></figure><h4 id="4）XCHG-交换指令"><a href="#4）XCHG-交换指令" class="headerlink" title="4）XCHG 交换指令"></a>4）XCHG 交换指令</h4><h4 id="格式-2"><a href="#格式-2" class="headerlink" title="格式"></a>格式</h4><ul><li>XCHG    OPR1 , OPR2</li></ul><h4 id="操作-2"><a href="#操作-2" class="headerlink" title="操作"></a>操作</h4><ul><li>( OPR1 )  &lt;— —&gt; ( OPR2 )</li><li>OPR1 和 OPR2都是目的操作数 ，执行后交换了位置</li><li>不能用立即数寻址</li></ul><h4 id="错误"><a href="#错误" class="headerlink" title="错误"></a>错误</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">XCHG</span><span class="hljs-built_in">AX</span> , <span class="hljs-number">5</span>操作数不能为立即数<br><span class="hljs-keyword">XCHG</span>[<span class="hljs-built_in">BX</span>] , VAR操作数不能同为内存单元<br><span class="hljs-keyword">XCHG</span><span class="hljs-built_in">AX</span> , <span class="hljs-number">BH</span>长度不一致<br></code></pre></td></tr></table></figure><h3 id="2-累加器专用传送指令"><a href="#2-累加器专用传送指令" class="headerlink" title="2.累加器专用传送指令"></a>2.累加器专用传送指令</h3><h4 id="注意-6"><a href="#注意-6" class="headerlink" title="注意"></a>注意</h4><ul><li>这组指令只限于 AX , AL (累加器)</li><li>输入/输出(IO)端口是CPU与外设传送数据的接口，单独编制，不属于内存</li><li>端口地址范围是0000 ~ FFFFH</li></ul><h4 id="1）-IN（input）输入"><a href="#1）-IN（input）输入" class="headerlink" title="1） IN（input）输入"></a>1） IN（input）输入</h4><p>定义</p><ul><li>把端口号PORT或由DX指向的端口的数据输入到累加器，根据端口号的长度，有长格式和短格式两种形式</li></ul><h4 id="长格式"><a href="#长格式" class="headerlink" title="长格式"></a>长格式</h4><p>定义：</p><ul><li>机器指令长度为2个字节 ， 端口号占一个字节</li></ul><p>格式：</p><ul><li>IN    AL , PORT(字节)</li><li>IN    AL , PORT(字)</li></ul><p>PORT为端口号 ， 范围是00 - FFH</p><ul><li>八位二进制 / 两位十六进制</li></ul><h4 id="短格式"><a href="#短格式" class="headerlink" title="短格式"></a>短格式</h4><p>定义：</p><ul><li>端口号范围为 0100H - 0FFFFH</li><li>短格式机器指令长度为1个字节，因为端口号存在DX寄存器中</li></ul><p>格式：</p><ul><li>IN   AL , <strong>DX</strong>(字节)</li><li>IN   AX , **DX(**字)</li></ul><hr><h4 id="2）OUT-output-输出"><a href="#2）OUT-output-输出" class="headerlink" title="2）OUT(output) 输出"></a>2）OUT(output) 输出</h4><h4 id="定义-6"><a href="#定义-6" class="headerlink" title="定义"></a>定义</h4><ul><li>把累加器的数据输出到端口PORT或由DX指向的端口</li></ul><h4 id="长格式："><a href="#长格式：" class="headerlink" title="长格式："></a>长格式：</h4><ul><li>OUT PORT , AL(字节)</li><li>OUT PORT , AX(字节)</li></ul><h4 id="短格式："><a href="#短格式：" class="headerlink" title="短格式："></a>短格式：</h4><ul><li>OUT DX , AX(字节)</li><li>OUT DX , AL(字节)</li></ul><hr><h4 id="3）XLAT-translate-换码"><a href="#3）XLAT-translate-换码" class="headerlink" title="3）XLAT(translate) 换码"></a>3）XLAT(translate) 换码</h4><h4 id="定义：-1"><a href="#定义：-1" class="headerlink" title="定义："></a>定义：</h4><ul><li>把BX+AL的值作为以后小地址，取出其中一个字节送到AL</li></ul><h4 id="格式："><a href="#格式：" class="headerlink" title="格式："></a>格式：</h4><ul><li>XLAT</li></ul><h4 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h4><ul><li>AL  &lt;—  ( BX+AL )</li></ul><hr><h3 id="3-地址传送指令"><a href="#3-地址传送指令" class="headerlink" title="3.地址传送指令"></a>3.地址传送指令</h3><ul><li>LEA  有效地址送寄存器</li><li>LSD  指针送寄存器和DS</li><li>LES  指针送寄存器和ES</li></ul><h4 id="1）LEA-有效地址送寄存器指令"><a href="#1）LEA-有效地址送寄存器指令" class="headerlink" title="1）LEA 有效地址送寄存器指令"></a>1）LEA 有效地址送寄存器指令</h4><h4 id="格式-3"><a href="#格式-3" class="headerlink" title="格式"></a>格式</h4><ul><li>LEA  REG , SRC</li></ul><h4 id="操作-3"><a href="#操作-3" class="headerlink" title="操作"></a>操作</h4><ul><li>REG   &lt;—  SRC</li></ul><h4 id="定义：-2"><a href="#定义：-2" class="headerlink" title="定义："></a>定义：</h4><ul><li>把源操作数的<strong>有效地址EA</strong>(偏移地址)送到指定寄存器</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">LEA</span><span class="hljs-built_in">BX</span> , TABLE  <span class="hljs-comment">;MOV BX , OFFSET [2016H]</span><br>指令执行后， <span class="hljs-built_in">BX</span> = <span class="hljs-number">2016H</span><br></code></pre></td></tr></table></figure><h4 id="2-LDS-指针送寄存器和DS指令"><a href="#2-LDS-指针送寄存器和DS指令" class="headerlink" title="2) LDS 指针送寄存器和DS指令"></a>2) LDS 指针送寄存器和DS指令</h4><h4 id="格式：-1"><a href="#格式：-1" class="headerlink" title="格式："></a>格式：</h4><ul><li>LDS REG ,  SRC</li></ul><h4 id="操作-4"><a href="#操作-4" class="headerlink" title="操作"></a>操作</h4><ul><li>REG  &lt;— ( SRC )</li><li>DS  &lt;—  ( SRC + 2 )</li></ul><h4 id="定义：-3"><a href="#定义：-3" class="headerlink" title="定义："></a>定义：</h4><ul><li>把<strong>源操作数SRC</strong>所指向的内存单元中的<strong>两个字</strong>送到指定的寄存器REG和DS</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">LDS</span>  <span class="hljs-built_in">SI</span> , [ <span class="hljs-built_in">BX</span> ]<br>执行前 ， 如果 <span class="hljs-built_in">DS</span> = <span class="hljs-number">2000H</span> , <span class="hljs-built_in">BX</span> = <span class="hljs-number">0400H</span>, (<span class="hljs-number">2000</span>:<span class="hljs-number">0400</span>) = <span class="hljs-number">1234H</span> , (<span class="hljs-number">2000</span>:<span class="hljs-number">0402</span>) = <span class="hljs-number">5678H</span><br>执行后 ， <span class="hljs-built_in">SI</span> = <span class="hljs-number">1234H</span> , <span class="hljs-built_in">DS</span> = <span class="hljs-number">5678H</span>  (<span class="hljs-built_in">BX</span>寄存器默认的段寄存器是<span class="hljs-built_in">DS</span>)<br></code></pre></td></tr></table></figure><h4 id="3-LES-指针送寄存器和ES指令"><a href="#3-LES-指针送寄存器和ES指令" class="headerlink" title="3) LES 指针送寄存器和ES指令"></a>3) LES 指针送寄存器和ES指令</h4><h4 id="格式：-2"><a href="#格式：-2" class="headerlink" title="格式："></a>格式：</h4><ul><li>LDS SI , [BX]</li></ul><h4 id="操作-5"><a href="#操作-5" class="headerlink" title="操作"></a>操作</h4><ul><li>REG  &lt; — ( SRC )</li><li>ES  &lt; —  ( SRC+2 )</li></ul><h3 id="4-标志寄存器传送指令"><a href="#4-标志寄存器传送指令" class="headerlink" title="4.标志寄存器传送指令"></a>4.标志寄存器传送指令</h3><ul><li>LAHF        标志送AH寄存器</li><li>SAHF        AH送标志寄存器</li><li>PUSHF     标志入栈</li><li>POPF        标志出栈</li></ul><p>四条指令的格式相同，只有操作码部分，操作数为固定默认值，传送类指令(除SAHF\POPF)均不影响标志位</p><h3 id="5-算术运算指令"><a href="#5-算术运算指令" class="headerlink" title="5.算术运算指令"></a>5.算术运算指令</h3><blockquote><p>重要！！！</p></blockquote><h4 id="1）类型扩展指令"><a href="#1）类型扩展指令" class="headerlink" title="1）类型扩展指令"></a>1）类型扩展指令</h4><ul><li>CBW    字节扩展成字</li><li>CWD    字扩展成双字</li></ul><p>这两条指令的格式相同，只有操作码部分，没有操作数部分。</p><p>操作数默认是累加器，无需在指令中给出</p><p>CBW :</p><ul><li>当执行CBW时，默认将AL寄存器的内容扩展到AX寄存器中，扩展方法为符号扩展<ul><li>符号扩展即如果<strong>AL的最高位为1(负数)</strong> ， 则CBW指令扩展时使 <strong>AH = FFH</strong></li><li>如果<strong>AL的最高位为0</strong> ， 则CBW指令扩展时使 <strong>AH = 00H</strong>。</li></ul></li></ul><p>CWD：</p><ul><li>执行CWD时，默认将AX寄存器的内容扩展到(DX,AX)中<ul><li>DX存放双字中的<strong>高位</strong></li><li>AX存放双字中的<strong>低位</strong></li></ul></li><li>如果<strong>AX最高位为1</strong>，CWD指令扩展时使 <strong>DX = FFFFH</strong></li><li>如果<strong>AX最高位为0</strong>，CWD指令扩展时使 <strong>DX = 0000H</strong></li></ul><h4 id="举例-8"><a href="#举例-8" class="headerlink" title="举例"></a>举例</h4><p>正数扩展</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-number">AH</span> , <span class="hljs-number">11H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DX</span> , <span class="hljs-number">1111H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span> , <span class="hljs-number">52H</span><br><span class="hljs-keyword">CBW</span>指令执行后 ， <span class="hljs-built_in">AX</span> = <span class="hljs-number">0052H</span><br><span class="hljs-keyword">CWD</span>指令执行后 ， <span class="hljs-built_in">DX</span> = <span class="hljs-number">0000H</span> (<span class="hljs-built_in">AX</span>最高位为<span class="hljs-number">0</span>), <span class="hljs-built_in">AX</span> =<span class="hljs-number">0052H</span>(存放<span class="hljs-built_in">AX</span>中低位)<br></code></pre></td></tr></table></figure><h4 id="负数扩展"><a href="#负数扩展" class="headerlink" title="负数扩展"></a>负数扩展</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-number">AH</span> , <span class="hljs-number">11H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DX</span> , <span class="hljs-number">1111H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span> , <span class="hljs-number">88H</span> <span class="hljs-comment">;88H最高位为1</span><br><span class="hljs-keyword">CBW</span>指令执行后 ， <span class="hljs-built_in">AX</span> = <span class="hljs-number">FF88H</span><br><span class="hljs-keyword">CWD</span>指令执行后 ， <span class="hljs-built_in">DX</span> = <span class="hljs-number">FFFFH</span> , <span class="hljs-built_in">AX</span> = <span class="hljs-number">FF88H</span><br></code></pre></td></tr></table></figure><h4 id="2-加法指令"><a href="#2-加法指令" class="headerlink" title="2)加法指令"></a>2)加法指令</h4><ul><li>ADD    加法</li><li>ADC    带进位加法</li><li>INC     加1</li></ul><blockquote><p>加减运算必考 ADC SBB , CF , OF</p></blockquote><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD:"></a>ADD:</h4><p>格式：</p><ul><li>AADD DST ,  SRC</li></ul><p>操作：</p><ul><li>( DST )  &lt;— ( DST ) + ( SRC )</li></ul><p><strong>注意：</strong></p><ul><li>加法指令执行后会影响标志寄存器中的CF和OF标志位</li></ul><p><strong>举例</strong></p><p>无符号为数的溢出标志位CF</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AL</span> , <span class="hljs-number">72H</span><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AL</span> , <span class="hljs-number">93H</span><br><span class="hljs-number">1</span>.当<span class="hljs-number">93H</span>和<span class="hljs-number">72H</span>被视为无符号数时<br>执行后<span class="hljs-built_in">AL</span>=<span class="hljs-number">05H</span>  ，<span class="hljs-built_in">AL</span>只能存放<span class="hljs-number">8</span>位二进制，最高位的<span class="hljs-number">1</span>被送进了标志寄存器的CF位，即产生了进位，也叫无符号位的溢出<br>无符号数加法，如果CF=<span class="hljs-number">0</span>,表示结果是正确的。如果CF=<span class="hljs-number">1</span>，表示结果是错误的<br><br><span class="hljs-number">2</span>.当<span class="hljs-number">93H</span>和<span class="hljs-number">72H</span>被视为有符号数时<br><span class="hljs-number">72H</span> = <span class="hljs-number">01110010B</span> = <span class="hljs-number">114D</span> = [<span class="hljs-number">114D</span>]补<br><span class="hljs-number">93H</span> = <span class="hljs-number">10010011B</span> = [-<span class="hljs-number">109D</span>]补<br>等同于 <span class="hljs-number">114</span>+(-<span class="hljs-number">109</span>) = <span class="hljs-number">5</span><br>有符号数加法，不需要考虑CF的结果<br></code></pre></td></tr></table></figure><p>有符号数的溢出标志位OF</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AL</span> , <span class="hljs-number">92H</span><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AL</span> , <span class="hljs-number">93H</span><br><br><span class="hljs-number">92H</span>和<span class="hljs-number">93H</span>均为有符号数时<br><span class="hljs-number">92H</span> = <span class="hljs-number">10010010B</span> = [-<span class="hljs-number">110D</span>]补<br><span class="hljs-number">93H</span> = <span class="hljs-number">10010011B</span> = [-<span class="hljs-number">109D</span>]补<br>加法运算结果应该是(-<span class="hljs-number">219</span>)超过了<span class="hljs-built_in">AL</span>范围，所有结果移除了,OF置为一<br><br>只有相同符号的数才有可能溢出<br></code></pre></td></tr></table></figure><h4 id="ADC"><a href="#ADC" class="headerlink" title="ADC:"></a>ADC:</h4><p><strong>格式：</strong></p><ul><li>ADD    DST , SRC</li></ul><p><strong>操作：</strong></p><ul><li>(DST)   &lt;—   (SRC) + (DST) + CF</li></ul><p>CF即为标志位的值，无符号数加法考虑</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">设数A存放在<span class="hljs-built_in">DX</span>和<span class="hljs-built_in">AX</span> , <span class="hljs-built_in">DX</span>中存放高位字。数B存放在<span class="hljs-built_in">BX</span>和<span class="hljs-built_in">CX</span> ， <span class="hljs-built_in">BX</span>存放高位字<br><span class="hljs-built_in">DX</span> = <span class="hljs-number">2000H</span> , <span class="hljs-built_in">AX</span> = <span class="hljs-number">8000H</span><br><span class="hljs-built_in">BX</span> = <span class="hljs-number">4000H</span> , <span class="hljs-built_in">CX</span> = <span class="hljs-number">9000H</span><br><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AX</span> , <span class="hljs-built_in">CX</span><br><span class="hljs-keyword">ADC</span> <span class="hljs-built_in">DX</span> , <span class="hljs-built_in">BX</span><br><br><span class="hljs-keyword">ADD</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">CX</span>执行后，<span class="hljs-built_in">AX</span> = <span class="hljs-number">1000H</span> , CF = <span class="hljs-number">1</span>, OF = <span class="hljs-number">0</span> 有进位<br><span class="hljs-keyword">ADC</span> <span class="hljs-built_in">DX</span> , <span class="hljs-built_in">BX</span>执行后，<span class="hljs-built_in">DX</span> = <span class="hljs-number">6001H</span> , CF = <span class="hljs-number">0</span>, OF = <span class="hljs-number">0</span> 加上了CF中的<span class="hljs-number">1</span><br><br>无论无符号数还是有符号数，低位字相加无需考虑溢出，只有高位字相加产生的CF位和OF位才是判断是否溢出的依据<br><br></code></pre></td></tr></table></figure><h4 id="3）减法指令"><a href="#3）减法指令" class="headerlink" title="3）减法指令"></a>3）减法指令</h4><ul><li>SUB    减法</li><li>SBB    带借位减法</li><li>DEC    减1</li><li>NEG   求补</li><li>CMP   比较</li></ul><h4 id="SUB减法指令"><a href="#SUB减法指令" class="headerlink" title="SUB减法指令"></a>SUB减法指令</h4><p>格式：</p><ul><li>SUB    DST , SRT</li></ul><p>操作：</p><ul><li>(DST)  &lt;— (DST) - (SRC)</li></ul><h4 id="SBB带借位减法指令"><a href="#SBB带借位减法指令" class="headerlink" title="SBB带借位减法指令"></a>SBB带借位减法指令</h4><p>格式：</p><ul><li>SBB    DST , SRC</li></ul><p>操作：</p><ul><li>(DST)  &lt;—  (DST) - (SRC) - CF</li></ul><h4 id="DEC减1指令"><a href="#DEC减1指令" class="headerlink" title="DEC减1指令"></a>DEC减1指令</h4><p>格式：</p><ul><li>DEC    OPR</li></ul><p>操作：</p><ul><li>(OPR)  &lt;— (OPR) - 1</li></ul><p>该指令不影响CF标志位</p><h4 id="NEG求补指令-求相反数"><a href="#NEG求补指令-求相反数" class="headerlink" title="NEG求补指令(求相反数)"></a>NEG求补指令(求相反数)</h4><p>格式：</p><ul><li>NEG    OPR</li></ul><p>操作：</p><ul><li>(OPR)  &lt;—  -(OPR)</li></ul><h4 id="CMP比较指令"><a href="#CMP比较指令" class="headerlink" title="CMP比较指令"></a>CMP比较指令</h4><p>格式：</p><ul><li>CMP    OPR1 , OPR2</li></ul><p>操作：</p><ul><li>(OPR1) - (OPR2)</li></ul><blockquote><p>CF 标志位指明无符号的溢出</p><p>OF标志位指令有符号数溢出</p></blockquote><p><strong>举例</strong>：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AL</span> , <span class="hljs-number">72H</span><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">AL</span> , <span class="hljs-number">94H</span><br><br><span class="hljs-number">1</span>.对于无符号数减法时。计算机允许被减数向高位借位，体现在CF标志位。需要借位时，将CF标志位置<span class="hljs-number">1</span>.<br>  相当于运算<span class="hljs-number">172H</span> - <span class="hljs-number">93H</span> = <span class="hljs-number">DFH</span><br>  <br><span class="hljs-number">2</span>.对于有符号数减法时。被减数<span class="hljs-number">72H</span>是正数(符号位为<span class="hljs-number">0</span>)，减数<span class="hljs-number">93H</span>是负数(符号位为<span class="hljs-number">1</span>)。运算结果<span class="hljs-number">DFH</span>(符号位为<span class="hljs-number">1</span>，是个负数)。此时OF置<span class="hljs-number">1</span>，表示溢出<br>  <span class="hljs-number">72H</span>-<span class="hljs-number">93H</span> = (<span class="hljs-number">114D</span>) - (-<span class="hljs-number">109D</span>) = <span class="hljs-number">223D</span> ,超出了<span class="hljs-number">9</span>位表示范围，溢出了<br></code></pre></td></tr></table></figure><blockquote><p>当两个有符号数的符号相同时，结果是不会发生溢出的。只有符号数的符号相反才有可能发生溢出，需要通过OF标志位判断</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">DX</span> = <span class="hljs-number">2001H</span> , <span class="hljs-built_in">AX</span> = <span class="hljs-number">8000H</span><br><span class="hljs-built_in">BX</span> = <span class="hljs-number">2000H</span> , <span class="hljs-built_in">CX</span> = <span class="hljs-number">9000H</span><br><br><span class="hljs-number">1.</span><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">CX</span><br><span class="hljs-number">2.</span><span class="hljs-keyword">SBB</span> <span class="hljs-built_in">DX</span> , <span class="hljs-built_in">BX</span><br><br><span class="hljs-number">1</span>.执行后 CF = <span class="hljs-number">1</span> ,相当于<span class="hljs-number">18000H</span>-<span class="hljs-number">9000H</span> = <span class="hljs-number">F000H</span><br>此时 CF = <span class="hljs-number">1</span> ,OF = <span class="hljs-number">0</span> , ZF = <span class="hljs-number">0</span> , SF = <span class="hljs-number">1</span><br><span class="hljs-number">2</span>.执行后 <span class="hljs-built_in">DX</span> = <span class="hljs-number">0000H</span> ,相当于<span class="hljs-built_in">DX</span> = <span class="hljs-built_in">DX</span> - <span class="hljs-built_in">BX</span> - CF = <span class="hljs-number">2001H</span> - <span class="hljs-number">2000H</span> - <span class="hljs-number">1</span> = <span class="hljs-number">0000H</span><br></code></pre></td></tr></table></figure><hr><h4 id="4）乘法指令"><a href="#4）乘法指令" class="headerlink" title="4）乘法指令"></a>4）乘法指令</h4><ul><li>MUL    无符号数乘法</li><li>IMUL   有符号数乘法</li></ul><h4 id="MUL"><a href="#MUL" class="headerlink" title="MUL:"></a><strong>MUL:</strong></h4><p>格式：</p><ul><li>MUL    SRC</li></ul><p>操作：</p><ul><li>当操作数为字节时，    (AX)   &lt;—  (AL) * (SRC)</li><li>当操作数为字时， (DX , AX)  &lt;—  (AX) *  (SRC)</li></ul><p><strong>注意：</strong></p><ul><li><p>IMUL格式和操作与MUL相同。</p></li><li><p>乘法指令中 ， 目的操作数默认认为累加器AX</p></li><li><p>两个相乘数必须长度相同，根据SRC长度而定是AL或者AX。SRC可以是寄存器或者变量，<strong>不能是立即数(立即数长度不确定)</strong></p></li><li><p>运算结果长度是乘数的两倍，不会出现溢出情况</p></li></ul><p><strong>举例：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AL</span> , OF1H<br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BL</span> , <span class="hljs-built_in">AL</span><br><span class="hljs-keyword">MUL</span><span class="hljs-built_in">BL</span><br><span class="hljs-keyword">IMUL</span>  <span class="hljs-built_in">BL</span><br><br>作为无符号数相乘 ， 执行后 AE = <span class="hljs-number">E2E1H</span><span class="hljs-number">F1H</span> * <span class="hljs-number">F1H</span> = E2E1<br>作为有符号数相乘 ， 执行后 AE = OOE1H(表示两个负数相乘，结果是正数)  OFH * OFH = <span class="hljs-number">00E1H</span><br></code></pre></td></tr></table></figure><hr><h4 id="5）除法指令"><a href="#5）除法指令" class="headerlink" title="5）除法指令"></a>5）<strong>除法指令</strong></h4><ul><li>DIV    无符号数除法</li><li>IDIV   有符号数除法</li></ul><h4 id="DIV"><a href="#DIV" class="headerlink" title="DIV"></a><strong>DIV</strong></h4><p>格式：</p><ul><li>DIV    SRC</li></ul><p>操作：</p><ul><li>SRC为字节时，(AL) &lt;— (AX)/(SRC)的<strong>商</strong>， （AH) &lt;— (AX)/(SRC)的<strong>余数</strong></li><li>SRC为字时，(AX) &lt;— (DX,AX)/(SRC)的<strong>商</strong>， （DX) &lt;— (DX,AX)/(SRC)的<strong>余数</strong></li></ul><h4 id="IDIV"><a href="#IDIV" class="headerlink" title="IDIV"></a>IDIV</h4><ul><li>IDIV指令格式和操作与DIV相同</li><li>IDIV中：最终商的符号应该是<strong>两个操作数符号的异或</strong>，而余数的符号和<strong>被除数符号一致</strong></li></ul><p><strong>注意：</strong></p><ul><li>除法指令中，目的操作数必须是<strong>累加器AX和DX</strong>(乘法只能是AX)</li><li><strong>被除数长度应为除数长度的两倍</strong>，余数放在目的操作数的<strong>高位</strong>，商放在目的操作数的<strong>低位</strong>。</li><li>SRC不能是立即数</li><li>在除法中，<strong>会产生溢出现象</strong><ul><li>除数是字节类型时，<strong>除法指令要求商为8位。</strong><ul><li>如果被除数的高8位绝对值 &gt; = 除数的绝对值。商会产生溢出</li></ul></li><li>除数是字类型时，除法指令要求商为16位。<ul><li>如果被除数的高16位绝对值 &gt; = 除数的绝对值。商会产生溢出</li></ul></li></ul></li></ul><p><strong>举例</strong></p><p>作字节除法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">3000H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BL</span> , <span class="hljs-number">2</span><br><span class="hljs-keyword">DIV</span> <span class="hljs-built_in">BL</span><br><br>操作是- (<span class="hljs-built_in">AL</span>) &lt;--- (<span class="hljs-built_in">AX</span>)/(SRC)的商， （<span class="hljs-number">AH</span>) &lt;--- (<span class="hljs-built_in">AX</span>)/(SRC)的余数<br>但是此时被除数的高八位(<span class="hljs-number">AH</span> = <span class="hljs-number">3H</span>)的绝对值 &gt; <span class="hljs-built_in">BL</span>，产生了溢出<br>相当于<span class="hljs-number">300H</span>/<span class="hljs-number">2H</span> = <span class="hljs-number">768</span>/<span class="hljs-number">2</span> = <span class="hljs-number">384</span> ，显然超过了<span class="hljs-built_in">AL</span>的<span class="hljs-number">8</span>位<br></code></pre></td></tr></table></figure><p>作字除法</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span> , <span class="hljs-number">300H</span><br><span class="hljs-keyword">CWD</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span> , <span class="hljs-number">2</span><br><span class="hljs-keyword">DIV</span><span class="hljs-built_in">BX</span><br><br>执行<span class="hljs-keyword">CWD</span>后，因为<span class="hljs-built_in">AX</span>最高位为<span class="hljs-number">0</span>，<span class="hljs-built_in">DX</span> = <span class="hljs-number">0000H</span> , <span class="hljs-built_in">AX</span> = <span class="hljs-number">0000H</span><br>被除数的高<span class="hljs-number">16</span>位为<span class="hljs-number">0</span>，所以不会溢出<br></code></pre></td></tr></table></figure><hr><p>6）BCD码(8421)的<strong>十进制</strong>调整指令</p><ul><li>DAA    加法的十进制调整指令</li><li>DAS    减法的十进制调整指令</li></ul><h4 id="DAA"><a href="#DAA" class="headerlink" title="DAA:"></a><strong>DAA:</strong></h4><p>格式：</p><ul><li>DAA</li></ul><p><strong>操作：</strong></p><ul><li>加法指令中，以AL为目的操作数，当加法运算结束后，用DAA把AL中的和调整为正确的BCD码格式</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">如果<span class="hljs-built_in">AL</span>低<span class="hljs-number">4</span>位 &gt; <span class="hljs-number">9</span> ,或AF = <span class="hljs-number">1</span>, 则<span class="hljs-built_in">AL</span> = <span class="hljs-built_in">AL</span> +<span class="hljs-number">6</span><br>如果<span class="hljs-built_in">AL</span>高<span class="hljs-number">4</span>位 &gt; <span class="hljs-number">9</span> ,或CF = <span class="hljs-number">1</span>, 则<span class="hljs-built_in">AL</span> = <span class="hljs-built_in">AL</span> + <span class="hljs-number">60H</span> ,CF = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>举例：</strong></p><blockquote><p>AF辅助进位标志</p><p>8位运算或16位运算时如果有进位或借位CF就等于1，而4位运算时如果有进位或借位AF就等于1。</p><p>AF是为了在BCD码运算时，要用到的，因为BCD码是以4位表示的。</p></blockquote><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">如<span class="hljs-built_in">AL</span> = <span class="hljs-number">28H</span> = <span class="hljs-number">28</span>(BCD) <span class="hljs-built_in">BL</span> = <span class="hljs-number">65H</span> = <span class="hljs-number">65</span>(BCD)<br><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AL</span> , <span class="hljs-built_in">BL</span>执行后， <span class="hljs-built_in">AL</span> = <span class="hljs-number">8DH</span><br><span class="hljs-keyword">DAA</span>执行后， <span class="hljs-built_in">AL</span> = <span class="hljs-built_in">AL</span> + <span class="hljs-number">6H</span> = <span class="hljs-number">8DH</span> + <span class="hljs-number">6H</span> = <span class="hljs-number">93</span>(BCD)<br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">如果<span class="hljs-built_in">AX</span> = <span class="hljs-number">88H</span> = <span class="hljs-number">88</span>(BCD) , <span class="hljs-built_in">BX</span> = <span class="hljs-number">65H</span> = <span class="hljs-number">65</span>(BCD)<br><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AL</span> , <span class="hljs-built_in">BL</span><span class="hljs-comment">;AL = 88+65 = 11H , AF = 1, CF = 1</span><br><span class="hljs-keyword">DAA</span><span class="hljs-comment">;因为CF = 1,AF = 1 。所有AL = 11H + 66H = 77H = 77(BCD) , CF = 1</span><br><span class="hljs-keyword">ADC</span><span class="hljs-number">AH</span> , <span class="hljs-number">0</span><span class="hljs-comment">;因为CF = 1 。所有AX = 177H = 177(BCD)</span><br></code></pre></td></tr></table></figure><h4 id="DAS"><a href="#DAS" class="headerlink" title="DAS:"></a>DAS:</h4><p><strong>格式</strong>：</p><ul><li>DAS</li></ul><p><strong>操作</strong>：</p><ul><li>减法指令中，以AL为目的操作数，减法运算结束后，用DAS把差调整为BCD码</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">如果<span class="hljs-built_in">AL</span>低<span class="hljs-number">4</span>位 &gt; <span class="hljs-number">9</span> ,或AF = <span class="hljs-number">1</span>, 则<span class="hljs-built_in">AL</span> = <span class="hljs-built_in">AL</span> - <span class="hljs-number">6</span><br>如果<span class="hljs-built_in">AL</span>高<span class="hljs-number">4</span>位 &gt; <span class="hljs-number">9</span> ,或CF = <span class="hljs-number">1</span>, 则<span class="hljs-built_in">AL</span> = <span class="hljs-built_in">AL</span> - <span class="hljs-number">60H</span> ,CF = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p><strong>举例：</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">如果<span class="hljs-built_in">AL</span> = <span class="hljs-number">93H</span> = <span class="hljs-number">93</span>(BCD) , <span class="hljs-built_in">BL</span> = <span class="hljs-number">65H</span> = <span class="hljs-number">65</span>(BCD)<br><br><span class="hljs-keyword">SUB</span> <span class="hljs-built_in">AL</span> , <span class="hljs-built_in">BL</span><span class="hljs-comment">;AL = 93H - 65H = 2EH</span><br><span class="hljs-keyword">DAS</span><span class="hljs-comment">;AL = 2EH + 2EH - 6H = 28(BCD)</span><br></code></pre></td></tr></table></figure><hr><h3 id="6-逻辑与位移指令"><a href="#6-逻辑与位移指令" class="headerlink" title="6.逻辑与位移指令"></a>6.逻辑与位移指令</h3><ul><li>AND</li><li>OR</li><li>NOT</li><li>XOR       异或</li><li>TEST     测试</li></ul><blockquote><p>逻辑指令按<strong>二进制位</strong>进行操作，操作数可以看成二进制位串。双操作数指令中，<strong>至少有一个操作数必须存放在寄存器中</strong>，另外一个操作数可以使用任意寻址方式</p></blockquote><p><strong>注意</strong>：</p><ul><li>逻辑运算指令只会对部分标志位产生影响</li><li><strong>NOT指令不影响任何标志位</strong></li><li>其他指令将使CF 和 OF为0，AF位无定义</li></ul><h4 id="AND"><a href="#AND" class="headerlink" title="AND"></a>AND</h4><p><strong>格式</strong>：</p><ul><li>AND    DST , SRC</li></ul><p><strong>操作：</strong></p><ul><li>(DST)  &lt;— (DST)^ (SRC)</li></ul><h4 id="OR"><a href="#OR" class="headerlink" title="OR"></a>OR</h4><p><strong>格式：</strong></p><ul><li>OR    DST , SRC</li></ul><h4 id="NOT"><a href="#NOT" class="headerlink" title="NOT"></a>NOT</h4><p><strong>格式：</strong></p><ul><li>NOT    DST , SRC</li></ul><h4 id="XOR"><a href="#XOR" class="headerlink" title="XOR"></a>XOR</h4><p><strong>格式：</strong></p><ul><li>XOR    DST , SRC</li></ul><h4 id="TEST"><a href="#TEST" class="headerlink" title="TEST"></a>TEST</h4><p><strong>格式：</strong></p><ul><li>TEST    OPR1 , OPR2</li></ul><p><strong>操作：</strong></p><ul><li>(OPR1) ^ (OPR2)</li><li>test指令的两个操作数相与的结果不保存，只根据结果置标志位</li></ul><h3 id="7-移位指令"><a href="#7-移位指令" class="headerlink" title="7.移位指令"></a>7.移位指令</h3><ul><li>SHL    循环左移</li><li>SAL        算术左移</li><li>SHR     循环右移</li><li>SAR      算术右移</li><li>ROL      循环左移</li><li>ROR      循环右移</li><li>RCL       带进位循环左移</li><li>RCR       带进位循环右移</li></ul><blockquote><p>移位指令均是双操作数指令，指令格式相同</p></blockquote><p><strong>SHL</strong>： 逻辑左移</p><p><strong>格式</strong>：</p><ul><li>SHL    OPR , 1</li><li>SHL     OPR, CL (其中CL寄存器的值大于1)</li></ul><p><strong>注意：</strong>     </p><ul><li>其中OPR为<strong>寄存器</strong>或者<strong>内存单元</strong> ， 移位次数可以是1或<strong>CL寄存器</strong></li><li>如果移位次数大于1，则可以在该移位指令前把移位次数送到CL寄存器中</li></ul><p><strong>左移：</strong></p><ul><li><p><strong>算术左移和逻辑左移，操作结果相同，均是最低位补0。移出的最高位送CF标志位</strong></p></li><li><p>ROL循环左移时，OPR整体向左移一位，最高位移出，同时送CF标志位和最低位</p></li><li><p>RCL带进位循环左移时，OPR整体左移一位，此时最高位移出送CF标志位，<strong>而CF标志位原始的数值送OPR最低位</strong></p></li></ul><p><strong>右移：</strong></p><ul><li>逻辑右移时，最高位补0 ， <strong>移出的最低位送CF标志位。</strong></li><li>算术右移时，<strong>OPR被认为是有符号数，最高位补符号位自身</strong>， <strong>移出的最低位送CF标志位。</strong></li><li>ROR循环右移时，OPR整体向右移一位，最低位移出，同时送CF标志和最高位。</li><li>RCR带进位循环右移，OPR整体右移一位，此时最低位移出送CF标志位，<strong>CF标志位原始的数值送OPR最高位</strong></li></ul><p><strong>举例：</strong></p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">AX</span> = <span class="hljs-number">13</span>H = <span class="hljs-number">00010011</span>B , CF = <span class="hljs-number">1</span><br><span class="hljs-attribute">SHL</span>AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">SHR</span>AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">SAR</span>AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">ROL</span> AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">ROR</span> AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">RCL</span> AX , <span class="hljs-number">1</span><br><span class="hljs-attribute">RCR</span> AX , <span class="hljs-number">1</span><br><br><span class="hljs-attribute">SHL</span>: <span class="hljs-number">00010011</span>B左移一位，得到<span class="hljs-number">00100110</span>B = <span class="hljs-number">26</span>H CF = <span class="hljs-number">0</span>，相当于AX内容乘以<span class="hljs-number">2</span>，<br><span class="hljs-attribute">SHR</span>: <span class="hljs-number">00010011</span>B右移一位，得到<span class="hljs-number">00001001</span>B = <span class="hljs-number">09</span>H CF = <span class="hljs-number">1</span><br><span class="hljs-attribute">SAR</span>: <span class="hljs-number">00010011</span>B整体右移，最低位<span class="hljs-number">1</span>送入CF标志位，最高位补符号位本身，即<span class="hljs-number">0</span>,结果是<span class="hljs-number">00001001</span>B = <span class="hljs-number">26</span>H,CF = <span class="hljs-number">1</span><br><span class="hljs-attribute">ROL</span>: <span class="hljs-number">00010011</span>B整体左移，最高位<span class="hljs-number">0</span>同时送入CF和最低位，结果是<span class="hljs-number">00100110</span> = <span class="hljs-number">26</span>H ，CF = <span class="hljs-number">0</span><br><span class="hljs-attribute">ROR</span>: <span class="hljs-number">00010011</span>B整体右移，最低位<span class="hljs-number">1</span>同时送入CF和最高位，结果是<span class="hljs-number">10001001</span> = <span class="hljs-number">89</span>H ，CF = <span class="hljs-number">1</span><br><span class="hljs-attribute">RCL</span>: <span class="hljs-number">00010011</span>B整体左移，最高位<span class="hljs-number">0</span>送CF，CF原始值<span class="hljs-number">1</span>送最低位，结果是<span class="hljs-number">00100111</span> = <span class="hljs-number">27</span>H ， CF = <span class="hljs-number">0</span><br><span class="hljs-attribute">RCR</span>: <span class="hljs-number">00010011</span>B整体右移，最低位<span class="hljs-number">1</span>送CF，CF原始值<span class="hljs-number">0</span>送最高位，结果是<span class="hljs-number">00001001</span> = <span class="hljs-number">09</span>H , CF = <span class="hljs-number">1</span><br><br></code></pre></td></tr></table></figure><h3 id="8-串操作指令"><a href="#8-串操作指令" class="headerlink" title="8.串操作指令"></a>8.串操作指令</h3><h3 id="9-程序转移指令"><a href="#9-程序转移指令" class="headerlink" title="9.程序转移指令"></a>9.程序转移指令</h3><ul><li>无条件转移指令</li><li>条件转移指令</li><li>循环指令</li><li>子程序调用指令</li><li>中断调用指令</li></ul><h4 id="无条件转移指令"><a href="#无条件转移指令" class="headerlink" title="无条件转移指令"></a>无条件转移指令</h4><ul><li>JMP ： 无条件转移到指令指定的地址去执行程序。指令中必须指定转移的目标地址<ul><li>根据目标地址，可以将无条件转移指令分为段内转移和段间转移</li></ul></li></ul><p>段内转移：</p><ul><li>转移的目标地址和本条跳转指令在同一个代码段。跳转后，CS寄存器的值没有发生转变只有IP寄存器有了改变</li></ul><p>段间转移：</p><ul><li>转移的目标地址和本条跳转指令不在同一个代码段。跳转后，CS寄存器的值发生了改变</li></ul><hr><h4 id="循环指令"><a href="#循环指令" class="headerlink" title="循环指令"></a>循环指令</h4><ul><li>LOOP    循环</li><li>LOOPZ/LOOPE  当为0/相等时循环   ZF = 1</li><li>LOOPNZ/LOOPNE  当不为0/不相等时循环  ZF = 0</li></ul><blockquote><p>循环指令的操作均是    首先<strong>执行CX寄存器减1</strong>，然后根据测试条件决定是否转移</p><p>1.(CX )=( CX )- 1</p><p>2.判断cx中的值</p><p>​    不为0转到标号处执行程序</p><p>​    为0则向下执行</p></blockquote><hr><h3 id="习题5"><a href="#习题5" class="headerlink" title="习题5"></a>习题5</h3><ol><li><p>设V是变量，指出下列错误的指令，说出错误原因并修改。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">DX</span>]<span class="hljs-comment">;DX不能做内存指针，寄存器间接寻址方式有：BX、SI、DI、BP可以</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">DS</span>,DATA<span class="hljs-comment">;段不能直接送DS，需要先送AX，再由AX送DS</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">CS</span>,<span class="hljs-built_in">AX</span><span class="hljs-comment">;CS不能修改</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">DL</span><span class="hljs-comment">;数据类型不一致</span><br><span class="hljs-keyword">PUSH</span><span class="hljs-built_in">AL</span><span class="hljs-comment">;必须为16位，应改成AX 不能WORD PTR AL</span><br><span class="hljs-keyword">ADD</span>[<span class="hljs-built_in">BX</span>],[<span class="hljs-built_in">DI</span>]<span class="hljs-comment">;不能同问内存</span><br><span class="hljs-keyword">LEA</span>[<span class="hljs-built_in">BX</span>],V<span class="hljs-comment">;不能对内存直接写立即数 要改成BX</span><br><span class="hljs-keyword">MOV</span>[<span class="hljs-built_in">DX</span>],OFFSETV<span class="hljs-comment">;DX不能做内存指针，去掉方括号</span><br><span class="hljs-keyword">MOV</span>[<span class="hljs-built_in">SI</span>],<span class="hljs-number">2</span><span class="hljs-comment">;立即数位数不确定，需要加PTR运算符</span><br><span class="hljs-keyword">MUL</span><span class="hljs-built_in">BX</span>,<span class="hljs-built_in">CX</span><span class="hljs-comment">;MUL 为单操作数默认目的寄存器为AX、DX 或 AX</span><br><span class="hljs-keyword">DIV</span><span class="hljs-number">5</span><span class="hljs-comment">;立即数不能作为除数，需要先存入另一寄存器</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BYTE</span>[<span class="hljs-built_in">SI</span>],<span class="hljs-built_in">AX</span><span class="hljs-comment">;类型不一致或用了保留字做标识符</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">SI</span>+<span class="hljs-built_in">DI</span>]<span class="hljs-comment">;只能基址变址，需要将SI、DI其中一个改为BP/BX</span><br><span class="hljs-keyword">SHR</span><span class="hljs-built_in">AX</span>,<span class="hljs-number">4</span><span class="hljs-comment">;移位次数非1时，只能用CL计数</span><br><span class="hljs-keyword">CMP</span><span class="hljs-number">6</span>,<span class="hljs-built_in">AX</span><span class="hljs-comment">;立即数不能出现在目的地址</span><br><span class="hljs-keyword">MOV</span>[FFFF],<span class="hljs-built_in">AX</span><span class="hljs-comment">;FFFF会被当做标识符，需要加前缀0或后缀H</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">BX</span> + <span class="hljs-number">4</span><span class="hljs-comment">;如果相对基址，加方括号</span><br><span class="hljs-keyword">JMP</span><span class="hljs-built_in">FAR</span>PRO<span class="hljs-comment">;需加PTR运算符</span><br></code></pre></td></tr></table></figure></li><li><p>在数据段定义了ARRAY数组，其中依次存储了4个字数据，根据以下要求把第4个字送AX寄存器。</p><ol><li><p>直接寻址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,ARRAY+<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li><li><p>使用BX的间接寻址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span>,OFFSET [ARRAY+<span class="hljs-number">6</span>]<br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BX</span>]<br></code></pre></td></tr></table></figure></li><li><p>使用BX和ARRAY的寄存器相对寻址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span>,<span class="hljs-number">0006H</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,ARRAY[<span class="hljs-built_in">BX</span>]<br></code></pre></td></tr></table></figure></li><li><p>基址变址寻址</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">MOV</span><span class="hljs-built_in">SI</span>,<span class="hljs-number">0006H</span><br><span class="hljs-keyword">LEA</span><span class="hljs-built_in">BX</span>,ARRAY<br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,[<span class="hljs-built_in">BX</span>][<span class="hljs-built_in">SI</span>]<br></code></pre></td></tr></table></figure></li><li><p>MOV以外的其他指令</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">SUB</span><span class="hljs-built_in">AX</span>,<span class="hljs-built_in">AX</span><br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AX</span>,ARRAY+<span class="hljs-number">6</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>溢出标志位OF与进位标志位CF有何作用和区别</p></li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stata">处理器对两个操作数进行运算时，按照无符号数求得结果，并相应设置进位标志<span class="hljs-keyword">CF</span>；同时，根据是否超出有符号数的范围设置溢出标志OF。应该利用哪个标志，则由程序员来决定。也就是说，如果将参加运算的操作数认为是无符号数，就应该关心进位；认为是有符号数，则要注意是否溢出。<br></code></pre></td></tr></table></figure><ul><li>无符号数关心CF</li><li>有符号数关心OF</li></ul><h2 id="第六章-伪指令"><a href="#第六章-伪指令" class="headerlink" title="第六章 伪指令"></a>第六章 伪指令</h2><h3 id="1-伪指令"><a href="#1-伪指令" class="headerlink" title="1.伪指令"></a>1.伪指令</h3><h4 id="定义-7"><a href="#定义-7" class="headerlink" title="定义"></a><strong>定义</strong></h4><ul><li>在汇编程序对源程序进行汇编期间<strong>由汇编程序处理的操作</strong>。</li><li>指令是在程序运行期间由<strong>CPU执行</strong>的</li></ul><h4 id="1-段定义伪指令"><a href="#1-段定义伪指令" class="headerlink" title="1)段定义伪指令"></a>1)<strong>段定义伪指令</strong></h4><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf">segment_name SEGMENT<span class="hljs-comment">; 段名</span><br>... <span class="hljs-comment">; 段定义的内容</span><br>segment_name ENDS<br></code></pre></td></tr></table></figure><h4 id="2）数据定义域存储器单元分配伪指令"><a href="#2）数据定义域存储器单元分配伪指令" class="headerlink" title="2）数据定义域存储器单元分配伪指令"></a>2）数据定义域存储器单元分配伪指令</h4><p>数据定义：[变量名]     操作码     N个操作数     [;注释]           // N个操作数字节大小全和操作码规定一样</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">// 重点<br><span class="hljs-built_in">DB</span><span class="hljs-comment">; 伪操作定义字节 8位BYTE</span><br><span class="hljs-built_in">DW</span><span class="hljs-comment">;伪操作定义字16位 WORD</span><br>// 没那么重要<br><span class="hljs-built_in">DD</span><span class="hljs-comment">;双字32位DWORD</span><br>DF<span class="hljs-comment">;6字节的字48位  FWORD</span><br><span class="hljs-built_in">DQ</span><span class="hljs-comment">;4字64位 QWORD</span><br><span class="hljs-built_in">DT</span><span class="hljs-comment">;10字节的字80位  TBTYE</span><br>如：<br>D_BYTE<span class="hljs-built_in">DB</span><span class="hljs-number">10</span>, <span class="hljs-number">10H</span><span class="hljs-comment">; 内存情况为 0A 10</span><br>D_WORD<span class="hljs-built_in">DW</span><span class="hljs-number">14</span>,<span class="hljs-number">100H</span>,-<span class="hljs-number">5</span>,<span class="hljs-number">0ABCDH</span><span class="hljs-comment">;0E 00 00 01 FB FF CD AB</span><br>D_DWORD<span class="hljs-built_in">DD</span><span class="hljs-number">4</span>*<span class="hljs-number">8</span><span class="hljs-comment">;20 00 00 00</span><br></code></pre></td></tr></table></figure><p>操作数为字符串。问号‘?’仅预留空间。</p><figure class="highlight tp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs tp">MESSAGE <span class="hljs-keyword">DB</span> <span class="hljs-string">&#x27;HELLO?&#x27;</span>,?;问号?通常被系统置<span class="hljs-number">0</span><br><span class="hljs-keyword">DB</span><span class="hljs-string">&#x27;AB&#x27;</span>,?<br>DW<span class="hljs-string">&#x27;AB&#x27;</span><br>内存情况：<br><span class="hljs-string">&#x27;H&#x27;</span> <span class="hljs-string">&#x27;E&#x27;</span> <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-string">&#x27;L&#x27;</span> <span class="hljs-string">&#x27;O&#x27;</span> <span class="hljs-string">&#x27;?&#x27;</span> -- <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-string">&#x27;B&#x27;</span> -- <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-string">&#x27;B&#x27;</span><br></code></pre></td></tr></table></figure><p>用操作符复制操作数</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">ARRAY DB<span class="hljs-number"> 2 </span>DUP(1,3,2 DUP(4,5)) ; 循环2份DUP1的内容，DUP1内首先是1<span class="hljs-number"> 3 </span>，然后循环两遍4 5<br>;即1<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>4<span class="hljs-number"> 5 </span>1<span class="hljs-number"> 3 </span>4<span class="hljs-number"> 5 </span>4 5<br></code></pre></td></tr></table></figure><h4 id="2）类型属性操作符"><a href="#2）类型属性操作符" class="headerlink" title="2）类型属性操作符"></a>2）类型属性操作符</h4><p>访问内存变量要指定地址，同时指定访问长度进行匹配，为避免出现两个长度不匹配的操作数使用类型属性操作符，进行访问。</p><p>WORD PTR ; 字类型</p><p>BYTE PTR ; 字节类型</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">OPER1</span> DB <span class="hljs-number">3</span>, <span class="hljs-number">4</span> ; <span class="hljs-number">03</span> <span class="hljs-number">04</span><br><span class="hljs-attribute">OPER2</span> DW <span class="hljs-number">5678</span>H, <span class="hljs-number">9</span> ; <span class="hljs-number">78</span> <span class="hljs-number">56</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span><br><br><span class="hljs-attribute">MOV</span> AX, WORD PTR OPER1 ; 从OPER1取<span class="hljs-number">1</span>个字 即 AX = <span class="hljs-number">0403</span>H<br><span class="hljs-attribute">MOV</span> BL, BYTE PTR OPER2 ; 从OPER2取<span class="hljs-number">1</span>个字节 即 BL = <span class="hljs-number">78</span>H<br><span class="hljs-attribute">MOV</span>BYTE PTR[DI], <span class="hljs-number">0</span> ; 将常数<span class="hljs-number">0</span>送到DS:[DI]一个字节单元<br></code></pre></td></tr></table></figure><h4 id="3）THIS操作符和LABEL伪操作"><a href="#3）THIS操作符和LABEL伪操作" class="headerlink" title="3）THIS操作符和LABEL伪操作"></a>3）THIS操作符和LABEL伪操作</h4><p>一个变量可以定义成不同的访问类型（比如word byte）方便访问，为此引入了THIS和LABEL。</p><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs delphi">[<span class="hljs-keyword">name</span>=]THIS <span class="hljs-keyword">type</span> ; buf = THIS WORD<br><span class="hljs-keyword">name</span> <span class="hljs-keyword">LABEL</span> <span class="hljs-keyword">type</span>; VALUE <span class="hljs-keyword">LABEL</span> BYTE<br>两者只是指定一个<span class="hljs-keyword">type</span> 长度的访问方式，地址和下一个存储单元地址相同。<br></code></pre></td></tr></table></figure><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">BUF</span> = THIS WORD<br><span class="hljs-attribute">DAT</span> DB <span class="hljs-number">8</span>,<span class="hljs-number">9</span> ; (BUF,DAT)<span class="hljs-number">08</span> <span class="hljs-number">09</span> // 只是BUF访问的是用WORD<br><span class="hljs-attribute">OPR_B</span> LABEL BYTE<br><span class="hljs-attribute">OPR_W</span> DW <span class="hljs-number">4</span> DUP(<span class="hljs-number">2</span>) ; (OPR_B,OPR_W)<span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> <span class="hljs-number">02</span> <span class="hljs-number">00</span> // OPR_B访问这组数据的时候是用byte访问的<br></code></pre></td></tr></table></figure><h4 id="4）表达式赋值伪指令“EQU”和“-”"><a href="#4）表达式赋值伪指令“EQU”和“-”" class="headerlink" title="4）表达式赋值伪指令“EQU”和“=”"></a>4）表达式赋值伪指令“EQU”和“=”</h4><p>可以用赋值伪操作给表达式赋予一个常量或名字</p><ul><li><p>格式：①表达式名 EQU 表达式②表达式名 = 表达式</p></li><li><p>```<br>VALUE EQU 4<br>DATA EQU VALUE + 5<br>ADDR EQU [BP+VALUE]</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><br>- <span class="hljs-meta">EQU</span>和=区别，前者不能重复定义变量名，**后者可以重复定义**<br><br>- ```<br>  VALUE = <span class="hljs-number">54</span><br>  VALUE = VALUE + <span class="hljs-number">89</span><br>  但是不能<br>  VALUE <span class="hljs-meta">EQU</span> <span class="hljs-number">54</span><br>  VALUE <span class="hljs-meta">EQU</span> VALUE + <span class="hljs-number">54</span><br></code></pre></td></tr></table></figure></li></ul><h4 id="5）汇编地址计数器-与定位伪指令"><a href="#5）汇编地址计数器-与定位伪指令" class="headerlink" title="5）汇编地址计数器$与定位伪指令"></a>5）汇编地址计数器$与定位伪指令</h4><ol><li><p>地址计数器$</p><p>$表示<strong>当前正在汇编的指令的偏移地址</strong>。</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs powershell">ORG <span class="hljs-number">0</span><span class="hljs-built_in">H</span><br>ARRAY DW <span class="hljs-number">3</span>,<span class="hljs-variable">$</span>+<span class="hljs-number">7</span>,<span class="hljs-number">7</span>  ;<span class="hljs-variable">$</span>当前为<span class="hljs-number">2</span><br>COU = <span class="hljs-variable">$</span>;<span class="hljs-variable">$</span>当前为<span class="hljs-number">6</span><br>NEW DW COU<br>;内存模型为：<span class="hljs-number">03</span> <span class="hljs-number">00</span> <span class="hljs-number">09</span> <span class="hljs-number">00</span> <span class="hljs-number">07</span> <span class="hljs-number">00</span> <span class="hljs-number">06</span> <span class="hljs-number">00</span> (COU = <span class="hljs-number">6</span>，符号变量不占存储，NEW占了存储)<br></code></pre></td></tr></table></figure></li><li><p>ORG 伪操作</p><p>ORG用来设置当前地址计数器$的值（理解为定位了一个开始地址）</p><figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs brainfuck"><span class="hljs-comment">ORG 0H;代表$ = 0 ，同时当前开始存储的地址为0H</span><br><span class="hljs-comment">DB 3;</span><br><span class="hljs-comment">ORG4</span><br><span class="hljs-comment">BUFFDB6</span><br><span class="hljs-comment">ORG$</span> <span class="hljs-literal">+</span> <span class="hljs-comment">6</span><br><span class="hljs-comment">VALDB9</span><br><span class="hljs-comment">;内存模型为：03</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-comment">06</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-literal">--</span> <span class="hljs-comment">09</span><br></code></pre></td></tr></table></figure></li><li><p>EVEN伪操作</p><p>使下一个变量或指令<strong>开始于偶数地址</strong>。（方便16位）</p></li><li><p>ALIGN伪操作</p><p>使下一个变量的地址<strong>从4的倍数开始。</strong>（方便多字）</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ALSI</span> <span class="hljs-number">8</span> ; <span class="hljs-number">8</span>字节对齐<br></code></pre></td></tr></table></figure></li><li><p>基数控制</p><ol><li>二进制：0101 0101B</li><li>十进制：默认数字均为十进制，23D</li><li>十六进制：0ABCD 9876H，<strong>同时要求第一个字符必须是0~9，若为A~F则补0。</strong> 如0FFFFH</li></ol></li></ol><h4 id="6）过程定义伪指令"><a href="#6）过程定义伪指令" class="headerlink" title="6）过程定义伪指令"></a>6）过程定义伪指令</h4><ol><li><p><strong>子程序又称过程</strong>，可以把一个程序写成一个过程或多个过程。</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">procedure_name</span><span class="hljs-meta">PROC</span>Attribute<br><br><span class="hljs-symbol">procedure_name</span><span class="hljs-meta">ENDP</span><br></code></pre></td></tr></table></figure><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">程序名PROC类型属性(<span class="hljs-built_in">NEAR</span>或<span class="hljs-built_in">FAR</span>)<span class="hljs-comment">; NEAR 和 FAR 好像没要求很多 随便用吧</span><br>程序名 ENDP<br><span class="hljs-comment">;;</span><br>DATA <span class="hljs-meta">SEGMENT</span><br>STRING <span class="hljs-built_in">DB</span> <span class="hljs-string">&#x27;HELLO,WORLD$&#x27;</span><br>DATA ENDS<br><br>CODE <span class="hljs-meta">SEGMENT</span><br><span class="hljs-meta">ASSUME</span><span class="hljs-built_in">CS</span>:CODE,<span class="hljs-built_in">DS</span>:DATA<br>MAIN PROC <span class="hljs-built_in">FAR</span><br>  <span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,DATA<br>  <span class="hljs-keyword">MOV</span><span class="hljs-built_in">DS</span>,<span class="hljs-built_in">AX</span><br>  <span class="hljs-keyword">LEA</span><span class="hljs-built_in">DX</span>,STRING<br>  <span class="hljs-keyword">MOV</span><span class="hljs-number">AH</span>,<span class="hljs-number">9</span><br>  <span class="hljs-keyword">INT</span><span class="hljs-number">21H</span><br>  <span class="hljs-keyword">MOV</span><span class="hljs-number">AH</span>,<span class="hljs-number">4CH</span><br>  <span class="hljs-keyword">INT</span><span class="hljs-number">21H</span><br>MAIN ENDP<br>CODE ENDS<br>END MAIN<span class="hljs-comment">;设置程序起点MAIN</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-语句格式"><a href="#2-语句格式" class="headerlink" title="2.语句格式"></a>2.语句格式</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs css">指令和有关数据定义的伪指令<br><span class="hljs-selector-attr">[name]</span> operation operand <span class="hljs-selector-attr">[; comment]</span><br><span class="hljs-selector-attr">[名字]</span>操作  操作数<span class="hljs-selector-attr">[;注释]</span><br></code></pre></td></tr></table></figure><p>下面各项只能符号变量或常数直接计算，不能寄存器直接运算需要用对应的指令。</p><ol><li><p>名字项</p><ul><li>字母：A~Z</li><li>数字：0~9</li><li>专用字符：? . @ - $</li></ul></li><li><p>算术操作符：+ - * / MOD</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">ORG<span class="hljs-number">0</span><br>VAL = <span class="hljs-number">4</span><br>DA1 <span class="hljs-built_in">DW</span> <span class="hljs-number">6</span>,<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">3</span><br>DA2 <span class="hljs-built_in">DW</span> <span class="hljs-number">15</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span><br>COU = $ - DA2<br><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , DA1*<span class="hljs-number">4</span><span class="hljs-comment">;地址乘除没有意义</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , DA1*DA2；  地址乘除没有意义<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , DA1+DA2；  地址加减没有意义 <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">BX</span>+VAL；  <span class="hljs-built_in">BX</span>+VAL需用指令实现<br>----------------------------------------------<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [<span class="hljs-built_in">BX</span>+VAL]  <span class="hljs-comment">;   MOV AX , [BX + 4]</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , DA1+VAL   <span class="hljs-comment">;   MOV AX , [4]</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [DA1+VAL] <span class="hljs-comment">;   MOV AX , [4]</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , VAL*<span class="hljs-number">4</span>/<span class="hljs-number">2</span>   <span class="hljs-comment">;   MOV AX , 8</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , [VAL*A/<span class="hljs-number">2</span>] <span class="hljs-comment">;   MOV AX , 8</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span> , (DA2-DA1)/<span class="hljs-number">2</span> <span class="hljs-comment">; MOV CX , 4  取到DA1区数据个数</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BX</span> , COU   <span class="hljs-comment">;   MOV BX , 6  取到DA2区的字节数</span><br><br><br></code></pre></td></tr></table></figure></li><li><p>逻辑与逻辑位移操作符</p><p>逻辑操作符 AND , OR , XOR , NOT</p><p>位移操作符SHL , SHR</p><p>都是按位操作符</p><p><strong>格式：</strong></p><ul><li>expression    操作符    number</li></ul><p><strong>逻辑操作符的使用</strong>：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">ARY<span class="hljs-built_in">DW</span><span class="hljs-number">8</span><br>VAL = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">BX</span> <span class="hljs-keyword">AND</span> <span class="hljs-number">0FFH</span><span class="hljs-comment">;BX AND VAL须要指令实现</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , ARY <span class="hljs-keyword">AND</span> <span class="hljs-number">0FFH</span><span class="hljs-comment">;ARY AND VAL须要指令实现</span><br>-----------------------------------------------------------<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , VAL <span class="hljs-keyword">AND</span> <span class="hljs-number">0F0H</span><span class="hljs-comment">;MOV AX , 0</span><br><span class="hljs-keyword">AND</span> <span class="hljs-built_in">AX</span> , VAL <span class="hljs-keyword">OR</span> 0FOH<span class="hljs-comment">;MOV AX , 0F4H</span><br></code></pre></td></tr></table></figure><p><strong>移位操作符的使用</strong></p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">ARY <span class="hljs-built_in">DW</span> <span class="hljs-number">8</span><br>VAL = <span class="hljs-number">4</span><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">BX</span> <span class="hljs-keyword">SHL</span> <span class="hljs-number">2</span><span class="hljs-comment">; BX左移需用指令实现</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , ARY <span class="hljs-keyword">SHL</span> <span class="hljs-number">2</span>；ARY左移需用指令实现<br>-----------------------------------<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , VAL <span class="hljs-keyword">SHL</span> <span class="hljs-number">2</span><span class="hljs-comment">;MOV AX , 10H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">8</span> <span class="hljs-keyword">SHL</span> <span class="hljs-number">2</span><span class="hljs-comment">;MOV AX , 20H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , VAL <span class="hljs-keyword">SHL</span> <span class="hljs-number">15</span><span class="hljs-comment">;MOV AX , 00H</span><br></code></pre></td></tr></table></figure></li><li><p>关系操作符</p><p>用于对两个操作数的大小关系作出判断。</p><p>为真则FFFFH,为假则0H</p><ul><li>EQ相等</li><li>NE不等</li><li>LT小于</li><li>GT大于</li><li>LE小于等于</li><li>GE大于等于</li></ul><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">VAL = <span class="hljs-number">4</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-built_in">BX</span> GT <span class="hljs-number">2</span> <span class="hljs-comment">; BX是否大于2须要用指令实现</span><br>-----------------------------------------------------<br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,VALGE<span class="hljs-number">2</span>；  <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">FFFFH</span><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span>,<span class="hljs-number">8</span>LEVAL；  <span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> , <span class="hljs-number">0H</span>  <br></code></pre></td></tr></table></figure></li><li><p><strong>数值回送操作符</strong></p><ol><li><p>TYPE：</p><p><strong>格式：</strong></p><ul><li>TYPE expression(表达式)<ul><li>如果该表达式是变量，则汇编程序将回送该变量的<strong>以字节数表述的类型</strong>：<ul><li>DB为1，DW为2，DD为4，DF为6，DQ为8，DT为10。</li><li>DB 定义字节，DW定义字，DD定义双字，DF定义6个字节的字，DQ定义4个字，DT定义10个字节</li></ul></li><li>如果表达式是标号，则汇编程序将回送代表<strong>标号类型的数值:</strong><ul><li>NEAR为-1，FAR为-2。如果表达式为常数则回送0。</li></ul></li></ul></li></ul></li><li><p>LENGTH：</p><p><strong>格式：</strong></p><ul><li>LENGTH 变量<ul><li><strong>变量用DUP复制的</strong>，则回送<strong>总变量数</strong></li><li>不是DUP复制的为1，<strong>但嵌套的DUP不计</strong>。</li><li>对于使用嵌套的DUP复制的数据不能据此得到正确的总变量数。</li></ul></li></ul></li><li><p>SIZE：<br><strong>格式:</strong></p></li></ol><ul><li><p>SIZE 变量</p><ul><li><strong>变量用DUP复制的</strong>，则回送<strong>总字节数</strong>，</li><li><strong>其他为单个变量的字节数</strong>，<strong>但嵌套的DUP不计</strong>。所以，对于使用嵌套的DUP复制的数据不能据此得到正确的总字节数。</li></ul></li></ul><ol start="4"><li><p>OFFSET：OFFSET 变量或标号</p><ul><li>回送变量或标量的<strong>偏移地址</strong>。</li></ul></li><li><p>SEG：SEG 变量或标号</p><ul><li>回送变量或标号的<strong>段地址</strong></li></ul></li></ol></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">数据定义<br>ORG <span class="hljs-number">0</span><br>VAL = <span class="hljs-number">4</span><br>ARR <span class="hljs-built_in">DW</span> <span class="hljs-number">4</span> DUP(<span class="hljs-number">3</span>)<br>BUF <span class="hljs-built_in">DW</span> <span class="hljs-number">4</span> DUP(<span class="hljs-number">4</span> DUP(<span class="hljs-number">3</span>))<br>DAT <span class="hljs-built_in">DW</span> <span class="hljs-number">15</span>,<span class="hljs-number">17</span>,<span class="hljs-number">24</span><br><span class="hljs-keyword">STR</span> <span class="hljs-built_in">DB</span> <span class="hljs-string">&#x27;ABCDEF&#x27;</span><br><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,TYPE ARR<span class="hljs-comment">;MOVAX,2(DW 2)</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,LENGTH ARR       <span class="hljs-comment">;      MOV  AX,4</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,LENGTH BUF       <span class="hljs-comment">;      MOV  AX,4</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,LENGTH DAT      <span class="hljs-comment">;     MOV  AX,1</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,SIZE ARR<span class="hljs-comment">; MOV  AX,8</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,SIZE BUF<span class="hljs-comment">; MOV  AX,8</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,SIZE DAT<span class="hljs-comment">; MOV  AX,2(单个变量的字节数)</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AL</span> ,SIZE <span class="hljs-keyword">STR</span><span class="hljs-comment">;  MOV  AL,1</span><br>------------------------------------------------------------------------<br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">AX</span> ,OFFSET ARR      <span class="hljs-comment">;      不完整机器指令</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BX</span> ,<span class="hljs-built_in">SEG</span> ARR     <span class="hljs-comment">;     不完整机器指令</span><br></code></pre></td></tr></table></figure><h3 id="3-习题"><a href="#3-习题" class="headerlink" title="3.习题"></a>3.习题</h3><ol><li></li></ol><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">画图说明下列数据定义语句所示内存空间的数据，并回答寄存器的值<br>ORG<span class="hljs-number">0</span><br><span class="hljs-symbol">ARRAYLABEL</span><span class="hljs-built_in">BYTE</span><br>DA1<span class="hljs-built_in">DW</span><span class="hljs-number">2</span>,<span class="hljs-number">9</span>,<span class="hljs-number">14</span>,<span class="hljs-number">3</span>,<span class="hljs-number">315H</span>,-<span class="hljs-number">6</span><br>DA2<span class="hljs-built_in">DB</span> <span class="hljs-number">7</span>,<span class="hljs-string">&#x27;ABCDEFG&#x27;</span><br>LEN= $ - DA2<br>ORG<span class="hljs-number">100H</span><br>DA3<span class="hljs-built_in">DW</span>DA4<br>DA4<span class="hljs-built_in">DB</span><span class="hljs-number">4</span>DUP(<span class="hljs-number">2</span>DUP(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>),<span class="hljs-number">4</span>)<br>.........<br><br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AL</span> , ARRAY + <span class="hljs-number">2</span>(<span class="hljs-built_in">AL</span>) = <br><span class="hljs-keyword">ADD</span><span class="hljs-built_in">AL</span> , DA2 + <span class="hljs-number">1</span>(<span class="hljs-built_in">AL</span>) = <br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span> , DA2 - DA1 (<span class="hljs-built_in">AX</span>) = <br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BL</span> , LEN(<span class="hljs-built_in">BL</span>) = <br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">AX</span> , DA3(<span class="hljs-built_in">AX</span>) = <br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span> , TYPE DA4(<span class="hljs-built_in">BX</span>) = <br><span class="hljs-keyword">MOV</span><span class="hljs-built_in">BX</span> , OFFSET DA4(<span class="hljs-built_in">BX</span>) = <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">CX</span> , SIZE DA4(<span class="hljs-built_in">CX</span>) = <br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">DX</span>, LENGTH   (<span class="hljs-built_in">DX</span>) = <span class="hljs-number">0004H</span><br><span class="hljs-keyword">MOV</span> <span class="hljs-built_in">BX</span>,<span class="hljs-built_in">WORD</span> <span class="hljs-built_in">PTR</span> DA4(<span class="hljs-built_in">BX</span>) = <br></code></pre></td></tr></table></figure><ol start="2"><li></li></ol><p>定义数据段满足如下要求<br>（1）array为字符串变量：’inspire a generation!’<br>（2）data1为十六进制数：0FEDCBAH<br>（3）data2为二进制数：10101010B<br>（4）data3为100个为0的字节变量：<br>（5）分配500个字的空间待用</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs smali">DATASEGMENT<br><span class="hljs-built_in">array</span>db&#x27;inspire a generation!&#x27;<br>data1df    0FEDCBAH<br>data2db10101010B<br>data3db100 DUP(0)<br>dw500DUP(?)<br>DATAENDS<br></code></pre></td></tr></table></figure><h2 id="第七章-分支与循环程序设计"><a href="#第七章-分支与循环程序设计" class="headerlink" title="第七章 分支与循环程序设计"></a>第七章 分支与循环程序设计</h2><h3 id="1-分支程序设计"><a href="#1-分支程序设计" class="headerlink" title="1.分支程序设计"></a>1.分支程序设计</h3><h4 id="1）分支程序结构"><a href="#1）分支程序结构" class="headerlink" title="1）分支程序结构"></a>1）分支程序结构</h4><ul><li>IF-THEN-ELSE结构</li></ul><h4 id="2）单分支程序"><a href="#2）单分支程序" class="headerlink" title="2）单分支程序"></a>2）单分支程序</h4><ul><li>IF-THEN</li></ul><h4 id="3）复合分支程序"><a href="#3）复合分支程序" class="headerlink" title="3）复合分支程序"></a>3）复合分支程序</h4><ul><li>处理分段函数</li></ul><h4 id="4）多分支程序"><a href="#4）多分支程序" class="headerlink" title="4）多分支程序"></a>4）多分支程序</h4><ul><li>通过JMP    brach[BX]指令间接寻址方式转向对应分支</li></ul><h3 id="2-循环程序设计"><a href="#2-循环程序设计" class="headerlink" title="2.循环程序设计"></a>2.循环程序设计</h3><h4 id="1）循环程序结构"><a href="#1）循环程序结构" class="headerlink" title="1）循环程序结构"></a>1）循环程序结构</h4><ul><li><p>DO - WHILE结构</p><ul><li>把循环控制条件放在循环的入口，先判断控制条件是否成立，再决定是否进入循环</li></ul></li><li><p>DO - UNTIL结构(至少执行一次)</p><ul><li><strong>先执行循环体</strong>，然后判断控制条件是否成立，再决定是否进入循环</li></ul></li></ul><h2 id="第八章-子程序设计"><a href="#第八章-子程序设计" class="headerlink" title="第八章 子程序设计"></a>第八章 子程序设计</h2><h3 id="1-子程序结构"><a href="#1-子程序结构" class="headerlink" title="1.子程序结构"></a>1.子程序结构</h3><p><strong>定义</strong>：</p><ul><li>把一段完成相对独立功能的程序设计成子程序，供主程序调用</li></ul><p><strong>操作：</strong></p><ul><li>主程序通过<strong>指令CALL</strong>启动子程序执行</li><li>指令执行时，先把它下一条指令的地址压入堆栈保存</li><li>再把子程序的入口地址置入IP(CS)寄存器，以便实现转移</li><li>子程序执行完毕后，用放回指令(RET)回到主程序，放回指令把堆栈里保存的返回地址送回IP(CS)寄存器，实现程序的返回</li><li>子程序执行之后，返回到主程序接着执行</li></ul><h4 id="CALL指令"><a href="#CALL指令" class="headerlink" title="CALL指令"></a>CALL指令</h4><p><strong>格式：</strong></p><ul><li>CALL    DST</li></ul><p><strong>注意：</strong></p><ul><li>与JMP指令不同，先向堆栈保存放回地址，再实现程序转移</li><li>对于段内调用，只向堆栈保存IP寄存器的值</li><li>对于段间调用，先向堆栈保存CS寄存器的值，再保存IP寄存器的值</li></ul><hr><h4 id="RET指令"><a href="#RET指令" class="headerlink" title="RET指令"></a>RET<strong>指令</strong></h4><p><strong>格式</strong>：</p><ul><li>RET</li><li>RET EXP<ul><li>EXP为表达式，为一个常数。除了完成RET指令的操作外，还让SO再加上这个常数，修改SP寄存器的值</li></ul></li></ul><h4 id="过程定义与过程结构"><a href="#过程定义与过程结构" class="headerlink" title="过程定义与过程结构"></a>过程定义与过程结构</h4><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-symbol">procedure_name</span><span class="hljs-meta">PROC</span>Attribute<br><span class="hljs-symbol">.....</span><br><span class="hljs-symbol">procedure_name</span><span class="hljs-meta">ENDP</span><br><br><span class="hljs-symbol">procedure_name</span>为标识符，也是子程序入口的符号地址。Attribute为属性，可以是NEAR或者FAR<br></code></pre></td></tr></table></figure><p><strong>确定属性</strong></p><ul><li>如果调用程序和该过程<strong>在同一个代码段</strong>，则用NEAR属性</li><li>如果调用程序和该过程不在同一个代码段，则用FAR属性</li></ul><h4 id="保护和恢复现场寄存器"><a href="#保护和恢复现场寄存器" class="headerlink" title="保护和恢复现场寄存器"></a>保护和恢复现场寄存器</h4><p><strong>定义：</strong></p><ul><li><strong>再进入子程序后，先保存寄存器的值，在子程序退出前恢复这些寄存器的值</strong></li></ul><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs armasm"><span class="hljs-keyword">subr</span><span class="hljs-meta">proc</span>far<br><span class="hljs-keyword">push</span>ax<br><span class="hljs-keyword">push</span><span class="hljs-keyword">bx</span><br><span class="hljs-symbol">....</span><br><span class="hljs-keyword">pop</span><span class="hljs-keyword">bx</span><br><span class="hljs-keyword">pop</span>ax<br><span class="hljs-symbol">ret</span><br><span class="hljs-keyword">subr</span><span class="hljs-meta">endp</span><br></code></pre></td></tr></table></figure><h3 id="2。子程序的参数传递"><a href="#2。子程序的参数传递" class="headerlink" title="2。子程序的参数传递"></a>2。子程序的参数传递</h3><p><strong>定义：</strong></p><ul><li>主程序调用子程序时，要传递参数给子程序，这个参数称为入口参数</li><li>子程序执行完毕后，返回参数给主程序，这个参数叫出口参数</li></ul><p><strong>类型</strong></p><ul><li>值传递    <ul><li>把参数的值放在约定的寄存器或内存单元<ul><li>寄存器有限，不能传递很多参数</li></ul></li></ul></li><li>地址传递<ul><li>把参数的地址传递给子程序<ul><li>参数较多时使用</li></ul></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>考试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender修改器</title>
    <link href="/2023/08/02/Blender%E4%BF%AE%E6%94%B9%E5%99%A8/"/>
    <url>/2023/08/02/Blender%E4%BF%AE%E6%94%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="修改器"><a href="#修改器" class="headerlink" title="修改器"></a>修改器</h1><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726235356547.png" alt="image-20230726235356547"></p><h2 id="一。表面细分修改器"><a href="#一。表面细分修改器" class="headerlink" title="一。表面细分修改器"></a>一。表面细分修改器</h2><ul><li>将网格的面分割成更小的面，使其看起来更平滑</li></ul><h2 id="二。实体化修改器"><a href="#二。实体化修改器" class="headerlink" title="二。实体化修改器"></a>二。实体化修改器</h2><ul><li>获取任意网格的表面，然后为之添加深度，使其变厚</li></ul><h2 id="三。倒角修改器"><a href="#三。倒角修改器" class="headerlink" title="三。倒角修改器"></a>三。倒角修改器</h2><ul><li>修改倒角</li></ul><h2 id="四。布尔修改器"><a href="#四。布尔修改器" class="headerlink" title="四。布尔修改器"></a>四。布尔修改器</h2><ul><li><p>可以对两个物体进行 交集、差集 、 并集运算</p></li><li><p>偶尔会有奇怪问题</p></li><li><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230727000513670.png" alt="image-20230727000513670"></p></li><li><p>对需要修改的物体增加布尔修改器</p></li><li><p>选择进行运算的物体</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230727000607697.png" alt="image-20230727000607697"></p></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230727000616866.png" alt="image-20230727000616866"></p>]]></content>
    
    
    <categories>
      
      <category>Blender</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender十大建模操作</title>
    <link href="/2023/08/02/Blender%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/"/>
    <url>/2023/08/02/Blender%E5%8D%81%E5%A4%A7%E5%BB%BA%E6%A8%A1%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726150829706.png" alt="image-20230726150829706"></p><h2 id="一。常用操作"><a href="#一。常用操作" class="headerlink" title="一。常用操作"></a>一。常用操作</h2><h3 id="1）挤出"><a href="#1）挤出" class="headerlink" title="1）挤出"></a>1）挤出</h3><ul><li>快捷键： E</li><li>点挤出线 线挤出面 面挤出体</li></ul><h3 id="2）内插-向内挤出"><a href="#2）内插-向内挤出" class="headerlink" title="2）内插(向内挤出)"></a>2）内插(向内挤出)</h3><ul><li>快捷键：I</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726152306557.png" alt="image-20230726152306557"></li></ul><h3 id="3）循环切割"><a href="#3）循环切割" class="headerlink" title="3）循环切割"></a>3）循环切割</h3><ul><li>快捷键： CTRL + R</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726152609795.png" alt="image-20230726152609795"></li></ul><h3 id="4-倒角"><a href="#4-倒角" class="headerlink" title="4)   倒角"></a>4)   倒角</h3><ul><li>快捷键 ： CTRL + B</li><li>滑动滚轮可以修改倒角细分面</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726152319225.png" alt="image-20230726152319225"></li></ul><h3 id="5-合并"><a href="#5-合并" class="headerlink" title="5)  合并"></a>5)  合并</h3><ul><li>快捷键： M</li></ul><h3 id="6-断开"><a href="#6-断开" class="headerlink" title="6) 断开"></a>6) 断开</h3><ul><li>快捷键： V</li><li>只有一个点连接着3个面时 ， 才能将这个点与面断开</li></ul><h3 id="7）填充"><a href="#7）填充" class="headerlink" title="7）填充"></a>7）填充</h3><ul><li>快捷键： F</li><li>填充一个面</li></ul><h3 id="8-切刀工具"><a href="#8-切刀工具" class="headerlink" title="8) 切刀工具"></a>8) 切刀工具</h3><ul><li>快捷键 ：  K</li><li>切割痕迹会沿着物体表面</li></ul><h3 id="9）桥接工具"><a href="#9）桥接工具" class="headerlink" title="9）桥接工具"></a>9）桥接工具</h3><ul><li>快捷键： CTRL + E</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726154625546.png" alt="image-20230726154625546"></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230726154639869.png" alt="image-20230726154639869"></p><h3 id="10-分离"><a href="#10-分离" class="headerlink" title="10) 分离"></a>10) 分离</h3><ul><li>快捷键： P</li></ul>]]></content>
    
    
    <categories>
      
      <category>Blender</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>宝塔部署</title>
    <link href="/2023/08/02/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2/"/>
    <url>/2023/08/02/%E5%AE%9D%E5%A1%94%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h2 id="一。软件安装"><a href="#一。软件安装" class="headerlink" title="一。软件安装"></a>一。软件安装</h2><p>​    安装好</p><ul><li>mysql</li><li>redis</li><li>Nginx等等配置环境</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230802230534011.png" alt="image-20230802230534011"></p><h2 id="二。软件配置"><a href="#二。软件配置" class="headerlink" title="二。软件配置"></a>二。软件配置</h2><h3 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h3><ul><li>host</li><li>密码</li><li>端口</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230802231105676.png" alt="image-20230802231105676"></p><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><p>添加数据库：名字密码同文件中配置</p></li><li><p>添加sql文件</p></li></ul><h3 id="三。文件打包"><a href="#三。文件打包" class="headerlink" title="三。文件打包"></a>三。文件打包</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230802231443960.png" alt="image-20230802231443960"></p><ul><li><p>生成jar文件</p></li><li><p>配置文件上传目录</p></li><li><p>上传jar文件</p></li></ul><h3 id="四。添加java项目"><a href="#四。添加java项目" class="headerlink" title="四。添加java项目"></a>四。添加java项目</h3>]]></content>
    
    
    
    <tags>
      
      <tag>服务器</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Blender快捷键</title>
    <link href="/2023/07/21/Blender%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <url>/2023/07/21/Blender%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="视角切换"><a href="#视角切换" class="headerlink" title="视角切换"></a>视角切换</h2><ul><li>位移： Shift + 鼠标中键</li><li>旋转： 鼠标中键</li><li>缩放： 滑轮</li><li>单独显示一个图像 ： “ /  ” 键</li></ul><h2 id="视图切换"><a href="#视图切换" class="headerlink" title="视图切换"></a>视图切换</h2><ul><li>小键盘 <ul><li>1： 正视图</li><li>3 ： 侧视图</li><li>5 ： 透视图</li><li>7 ： 顶视图</li></ul></li><li>ALT + 中键滑动</li><li>~键： 可选择切换任意视角</li></ul><h2 id="图形"><a href="#图形" class="headerlink" title="图形"></a>图形</h2><ul><li>移动 ： G键<ul><li>加 x / y /z可以指定 x轴或者y轴 z轴移动</li></ul></li><li>缩放 ： S键</li><li>旋转 ： R键</li><li>倒角： CTRL + B<ul><li>创建立方体： SHIFT + A    </li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Blender</category>
      
    </categories>
    
    
    <tags>
      
      <tag>建模</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mmap函数</title>
    <link href="/2023/04/24/mmap%E5%87%BD%E6%95%B0/"/>
    <url>/2023/04/24/mmap%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="1-内存映射方式来修改文件中的记录"><a href="#1-内存映射方式来修改文件中的记录" class="headerlink" title="1.内存映射方式来修改文件中的记录"></a>1.内存映射方式来修改文件中的记录</h2><h3 id="1-解释部分"><a href="#1-解释部分" class="headerlink" title="1)解释部分"></a>1)解释部分</h3><p>这段代码主要演示了如何使用内存映射方式来修改文件中的记录。具体来说，它的实现过程如下：</p><ol><li>定义了一个存放记录的结构体 <code>RECORD</code>，其中包含了记录的编号和内容。</li><li>创建了一个文件 <code>records.dat</code>，并在其中写入测试数据。这些数据包含了50条记录，每条记录都有一个编号和内容，编号从0到49，内容为 <code>No.0</code> 到 <code>No.49</code>。</li><li>使用传统的方式来修改文件中的记录。具体来说，先打开文件，并将文件指针定位到第10条记录的位置。然后从文件中读取该记录的内容，修改它的编号和内容，并将修改后的内容写回到文件中。最后关闭文件。</li><li>使用内存映射方式来修改文件中的记录。具体来说，先打开文件，并使用 <code>mmap</code> 函数将文件映射到内存中。然后直接在内存中修改第10条记录的内容，并使用 <code>msync</code> 函数将修改后的内容异步写回到文件中。最后使用 <code>munmap</code> 函数释放映射的内存段，并关闭文件。</li></ol><p>需要注意的是，内存映射方式的修改过程相对来说更加高效，因为它不需要频繁地进行文件读写操作，而是直接在内存中修改数据。此外，由于内存映射方式可以将文件映射到多个进程的内存空间中，因此多个进程可以同时访问同一个文件，从而实现进程间的通信。</p><h3 id="2-代码区"><a href="#2-代码区" class="headerlink" title="2)代码区"></a>2)代码区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-comment">//定义存放记录的结构体</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span></span><br><span class="hljs-class">&#123;</span><br>    <span class="hljs-type">int</span> index; <span class="hljs-comment">//编号</span><br><br>    <span class="hljs-type">char</span> text[<span class="hljs-number">10</span>]; <span class="hljs-comment">//内容</span><br><br>&#125; RECORD;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> SIZE (50)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> EDIT_INDEX (10)</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>     RECORD record, *p_mapped_memory_addr;<br>    <span class="hljs-type">int</span> i, fd;<br>    FILE *fp;<br><br>    <span class="hljs-comment">//创建文件并写入测试数据</span><br><br>     fp = fopen(<span class="hljs-string">&quot;records.dat&quot;</span>, <span class="hljs-string">&quot;w+&quot;</span>);<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; SIZE; i++)<br>    &#123;<br>         record.index = i;<br>        <span class="hljs-built_in">sprintf</span>(record.text, <span class="hljs-string">&quot;No.%d&quot;</span>, i);<br>        fwrite(&amp;record, <span class="hljs-keyword">sizeof</span>(record), <span class="hljs-number">1</span>, fp);<span class="hljs-comment">//因为字节序对齐，在32位机上，sizeof(record)＝16，并不是14。</span><br><br>    &#125;<br>    fclose(fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ok, write %d records to the file: records.dat ./n&quot;</span>, SIZE);<br><br>    <span class="hljs-comment">//将第一30条记录编号修改为300，并相应地修改其内容。</span><br><br>    <span class="hljs-comment">//采用传统方式</span><br><br>     fp = fopen(<span class="hljs-string">&quot;records.dat&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>);<br>    fseek(fp, EDIT_INDEX * <span class="hljs-keyword">sizeof</span>(record), SEEK_SET);<br>    fread(&amp;record, <span class="hljs-keyword">sizeof</span>(record), <span class="hljs-number">1</span>, fp);<br><br>     record.index = EDIT_INDEX*<span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">sprintf</span>(record.text, <span class="hljs-string">&quot;No.%d&quot;</span>, record.index);<br><br>    fseek(fp, EDIT_INDEX * <span class="hljs-keyword">sizeof</span>(record), SEEK_SET);<br>    fwrite(&amp;record, <span class="hljs-keyword">sizeof</span>(record), <span class="hljs-number">1</span>, fp);<br>    fclose(fp);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ok, edit the file of records.dat using traditional method./n&quot;</span>);<br><br>    <span class="hljs-comment">//同样的修改，这次使用内存映射方式。</span><br><br>    <span class="hljs-comment">//将记录映射到内存中</span><br><br>     fd = open(<span class="hljs-string">&quot;records.dat&quot;</span>, O_RDWR);<br>     p_mapped_memory_addr = (RECORD *)mmap(<span class="hljs-number">0</span>, SIZE * <span class="hljs-keyword">sizeof</span>(record), PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br>    <span class="hljs-comment">//修改数据</span><br><br>     p_mapped_memory_addr[EDIT_INDEX].index = EDIT_INDEX*<span class="hljs-number">10</span>;<br>    <span class="hljs-built_in">sprintf</span>(p_mapped_memory_addr[EDIT_INDEX].text, <span class="hljs-string">&quot;No.%d&quot;</span>,<br>             p_mapped_memory_addr[EDIT_INDEX].index);<br><br>    <span class="hljs-comment">/* Synchronize the region starting at ADDR and extending LEN bytes with the</span><br><span class="hljs-comment">     file it maps. Filesystem operations on a file being mapped are</span><br><span class="hljs-comment">     unpredictable before this is done. Flags are from the MS_* set.</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">     This function is a cancellation point and therefore not marked with</span><br><span class="hljs-comment">     __THROW. extern int msync (void *__addr, size_t __len, int __flags);</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//将修改写回映射文件中(采用异步写方式)</span><br><br>     msync((<span class="hljs-type">void</span> *)p_mapped_memory_addr, SIZE * <span class="hljs-keyword">sizeof</span>(record), MS_ASYNC);<br>    <span class="hljs-comment">/* Deallocate any mapping for the region starting at ADDR and extending LEN</span><br><span class="hljs-comment">     bytes. Returns 0 if successful, -1 for errors (and sets errno).</span><br><span class="hljs-comment">     extern int munmap (void *__addr, size_t __len) __THROW;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-comment">//释放内存段</span><br><br>     munmap((<span class="hljs-type">void</span> *)p_mapped_memory_addr, SIZE * <span class="hljs-keyword">sizeof</span>(record));<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Ok, edit the file of records.dat using mmap method./n&quot;</span>);<br><br>    <span class="hljs-comment">//关闭文件</span><br>    close(fd); <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-运行结果"><a href="#3-运行结果" class="headerlink" title="3)运行结果"></a>3)运行结果</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230424152151058.png" alt="image-20230424152151058"></p><hr><h2 id="2-使用内存映射的方式来操作一个文件"><a href="#2-使用内存映射的方式来操作一个文件" class="headerlink" title="2.使用内存映射的方式来操作一个文件"></a>2.使用内存映射的方式来操作一个文件</h2><h3 id="1-解释部分-1"><a href="#1-解释部分-1" class="headerlink" title="1)解释部分"></a>1)解释部分</h3><p>这段代码主要演示了如何使用内存映射的方式来操作一个文件，将文件映射到内存中，然后读取或写入数据。</p><p>map_normalfile1.c:</p><ol><li>定义了一个结构体 <code>people</code>，它包含一个名字和一个年龄。</li><li>打开一个文件，使用 <code>lseek</code> 函数将文件大小扩展到 <code>people</code> 结构体的大小的 5 倍，然后将指针移到文件末尾，写入一个空字符，这样就创建了一个大小为 <code>people</code> 结构体大小的 5 倍的文件。</li><li>使用 <code>mmap</code> 函数将该文件映射到内存中，映射的大小为 <code>people</code> 结构体大小的 10 倍。</li><li>使用 <code>memcpy</code> 函数将每个 <code>people</code> 结构体的名字设置为一个字母，然后将年龄依次设置为 20 到 29。</li><li>程序等待 10 秒钟，然后使用 <code>munmap</code> 函数释放内存映射，并输出提示信息。</li></ol><p>map_normalfile2.c:</p><ol><li>定义了一个结构体 <code>people</code>，它包含一个名字和一个年龄。</li><li>打开一个文件，使用 <code>mmap</code> 函数将该文件映射到内存中，映射的大小为 <code>people</code> 结构体大小的 10 倍。</li><li>循环遍历每个 <code>people</code> 结构体，输出它的名字和年龄。</li><li>使用 <code>munmap</code> 函数释放内存映射。</li></ol><p>这两段代码可以一起使用，先运行 map_normalfile1.c 将数据写入文件并映射到内存中，然后运行 map_normalfile2.c 从内存中读取数据并输出。通过这种方式，可以实现进程间的数据共享和通信。</p><h3 id="2-代码区-1"><a href="#2-代码区-1" class="headerlink" title="2)代码区"></a>2)代码区</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/*-------------map_normalfile1.c-----------*/</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-type">char</span> name[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; people;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    people *p_map;<br>    <span class="hljs-type">char</span> temp;<br>    p_map = (people*) <span class="hljs-built_in">mmap</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-built_in">sizeof</span>(people)*<span class="hljs-number">10</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (fork() == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child read: the %d people&#x27;s age is %d\n&quot;</span>, i + <span class="hljs-number">1</span>, (*(p_map + i)).age);<br>        &#125;<br>        (*p_map).age = <span class="hljs-number">100</span>;<br>        <span class="hljs-built_in">munmap</span>(p_map, <span class="hljs-built_in">sizeof</span>(people)*<span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    temp = <span class="hljs-string">&#x27;a&#x27;</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        temp += <span class="hljs-number">1</span>;<br>        <span class="hljs-built_in">memcpy</span>((*(p_map + i)).name, &amp;temp, <span class="hljs-number">1</span>);<br>        (*(p_map + i)).age = <span class="hljs-number">20</span> + i;<br>    &#125;<br><br>    <span class="hljs-built_in">sleep</span>(<span class="hljs-number">5</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent read: the first people&#x27;s age is %d\n&quot;</span>, (*p_map).age);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unmap\n&quot;</span>);<br>    <span class="hljs-built_in">munmap</span>(p_map, <span class="hljs-built_in">sizeof</span>(people)*<span class="hljs-number">10</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;unmap ok\n&quot;</span>);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">/-------------map_normalfile2.c-----------/<br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  <span class="hljs-comment">// Added for printf()</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> age;  <span class="hljs-comment">// Added missing type specifier</span><br>&#125; people;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-type">int</span> fd, i;<br>    people *p_map;<br><br>    fd = open(argv[<span class="hljs-number">1</span>], O_CREAT | O_RDWR, <span class="hljs-number">00777</span>);<br>    p_map = (people*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(people) * <span class="hljs-number">10</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, <span class="hljs-number">0</span>);<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;  <span class="hljs-comment">// Fixed loop condition</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s age %d;\n&quot;</span>, (*(p_map+i)).name, (*(p_map+i)).age);<br>    &#125;<br><br>    munmap(p_map, <span class="hljs-keyword">sizeof</span>(people) * <span class="hljs-number">10</span>);  <span class="hljs-comment">// Fixed munmap() call</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h3 id="3-运行结果-1"><a href="#3-运行结果-1" class="headerlink" title="3)运行结果"></a>3)运行结果</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230424152237008.png" alt="image-20230424152237008"></p><hr><h2 id="3-父子进程通过匿名映射实现共享内存"><a href="#3-父子进程通过匿名映射实现共享内存" class="headerlink" title="3.父子进程通过匿名映射实现共享内存"></a>3.父子进程通过匿名映射实现共享内存</h2><h3 id="1-解释部分-2"><a href="#1-解释部分-2" class="headerlink" title="1)解释部分"></a>1)解释部分</h3><p>这段代码演示了如何使用内存映射实现进程间通信，父进程和子进程可以通过共享内存来交换数据。</p><ol><li>定义了一个结构体 <code>people</code>，它包含一个名字和一个年龄。</li><li>使用 <code>mmap</code> 函数将一块共享内存映射到进程的地址空间中。这个共享内存的大小为 <code>people</code> 结构体大小的 10 倍，标识为 <code>MAP_SHARED | MAP_ANONYMOUS</code>，表示该内存区域是可共享的，并且没有关联到任何文件。</li><li>创建一个子进程，子进程在两秒钟后读取共享内存中的前五个 <code>people</code> 结构体数据，并更新第一个 <code>people</code> 结构体的年龄。然后释放共享内存并退出子进程。</li><li>父进程循环遍历前五个 <code>people</code> 结构体，将每个 <code>people</code> 的名字设置为递增的字母，并将年龄设置为 20 到 24。然后等待 5 秒钟后读取共享内存中的第一个 <code>people</code> 结构体，并输出它的年龄。最后释放共享内存并退出父进程。</li></ol><p>通过共享内存来传递数据，可以避免复制数据的开销，提高程序的效率。但需要注意的是，在共享内存中操作数据时需要考虑同步和互斥，否则可能会发生数据竞争和死锁等问题。</p><h3 id="2-代码区-2"><a href="#2-代码区-2" class="headerlink" title="2)代码区"></a>2)代码区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span>  <span class="hljs-comment">// Added for printf()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span> <span class="hljs-comment">// Added for exit()</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span> <span class="hljs-comment">// Added for memcpy()</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; people;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-type">int</span> i;<br>    people *p_map;<br>    <span class="hljs-type">char</span> temp = <span class="hljs-string">&#x27;a&#x27;</span>;<br><br>    p_map = (people*) mmap(<span class="hljs-literal">NULL</span>, <span class="hljs-keyword">sizeof</span>(people) * <span class="hljs-number">10</span>, PROT_READ | PROT_WRITE, MAP_SHARED | MAP_ANONYMOUS, <span class="hljs-number">-1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (p_map == MAP_FAILED) &#123;<br>        perror(<span class="hljs-string">&quot;mmap&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125;<br><br>    <span class="hljs-type">pid_t</span> pid = fork();<br>    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>) &#123;<br>        perror(<span class="hljs-string">&quot;fork&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_FAILURE);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// child process</span><br>        sleep(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child read: the %d people&#x27;s age is %d\n&quot;</span>, i + <span class="hljs-number">1</span>, (*(p_map + i)).age);<br>        &#125;<br>        (*p_map).age = <span class="hljs-number">100</span>;<br>        munmap(p_map, <span class="hljs-keyword">sizeof</span>(people) * <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// parent process</span><br>        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>            temp++;<br>            <span class="hljs-built_in">memcpy</span>((*(p_map + i)).name, &amp;temp, <span class="hljs-number">1</span>);<br>            (*(p_map + i)).age = <span class="hljs-number">20</span> + i;<br>        &#125;<br>        sleep(<span class="hljs-number">5</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parent read: the first people&#x27;s age is %d\n&quot;</span>, (*p_map).age);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;umap\n&quot;</span>);<br>        munmap(p_map, <span class="hljs-keyword">sizeof</span>(people) * <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;umap ok\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(EXIT_SUCCESS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-运行结果-2"><a href="#3-运行结果-2" class="headerlink" title="3)运行结果"></a>3)运行结果</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230424152029852.png" alt="image-20230424152029852"></p><h2 id="4-对mmap返回地址访问"><a href="#4-对mmap返回地址访问" class="headerlink" title="4.对mmap返回地址访问"></a>4.对mmap返回地址访问</h2><h3 id="1-解释部分-3"><a href="#1-解释部分-3" class="headerlink" title="1)解释部分"></a>1)解释部分</h3><p>这段代码演示了如何使用 <code>mmap()</code> 函数创建一个映射文件，并在其中进行页级别的内存操作。</p><ol><li>定义了一个结构体 <code>people</code>，它包含一个名字和一个年龄。</li><li>使用 <code>sysconf()</code> 函数获取操作系统的页面大小，并输出。</li><li>使用 <code>open()</code> 函数创建一个新的文件，设置 <code>O_CREAT</code> 标志表示如果文件不存在就创建它，设置 <code>O_RDWR</code> 标志表示文件可读可写，设置 <code>O_TRUNC</code> 标志表示清空文件内容。</li><li>使用 <code>lseek()</code> 函数设置文件偏移量为两页大小减去 100，然后使用 <code>write()</code> 函数写入一个字节的空字符，以扩展文件大小为两页。</li><li>将 <code>off</code> 的值设置为一个页大小，表示将映射文件的第一个页保留不使用，而将后面的两页用于内存映射。</li><li>使用 <code>mmap()</code> 函数将映射文件的第二个页和第三个页映射到当前进程的地址空间中，并返回一个指向 <code>people</code> 结构体数组的指针 <code>p_map</code>。设置 <code>MAP_SHARED</code> 标志表示这是一个共享映射，即多个进程可以共同访问该映射区域。</li><li>在一个循环中，对于每两个页，分别访问该页的倒数第二个元素、倒数第一个元素和下一个页的第一个元素，并将它们的年龄设置为 100。在访问每个元素之后，程序会输出一条提示信息。</li><li>最后，使用 <code>munmap()</code> 函数释放映射内存，并关闭文件句柄。</li></ol><p>该程序展示了如何使用 <code>mmap()</code> 函数将一个文件映射到内存中，并对映射内存进行操作。在这个例子中，程序通过映射文件的第二个页和第三个页，实现了页级别的内存操作，可以方便地进行内存分页相关的实验和研究。</p><h3 id="2-代码区-3"><a href="#2-代码区-3" class="headerlink" title="2)代码区"></a>2)代码区</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/mman.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/types.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;fcntl.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    <span class="hljs-type">char</span> name[<span class="hljs-number">4</span>];<br>    <span class="hljs-type">int</span> age;<br>&#125; people;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> &#123;<br>    <span class="hljs-type">int</span> fd, i, pagesize, off;<br>    people *p_map;<br><br>    pagesize = sysconf(_SC_PAGESIZE);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;pagesize is %d\n&quot;</span>, pagesize);<br><br>    fd = open(argv[<span class="hljs-number">1</span>], O_CREAT | O_RDWR | O_TRUNC, <span class="hljs-number">00777</span>);<br>    lseek(fd, pagesize * <span class="hljs-number">2</span> - <span class="hljs-number">100</span>, SEEK_SET);<br>    write(fd, <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-number">1</span>);<br>    off = pagesize; <span class="hljs-comment">// 将 off 的值设置为 pagesize，使其指向第二个页的开始位置，即第一个页的末尾</span><br><br>    p_map = (people*) mmap(<span class="hljs-literal">NULL</span>, pagesize * <span class="hljs-number">3</span>, PROT_READ | PROT_WRITE, MAP_SHARED, fd, off);<br>    close(fd);<br><br> <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">9</span>; i += <span class="hljs-number">2</span>) &#123;<br>    <span class="hljs-type">int</span> index1 = (pagesize / <span class="hljs-keyword">sizeof</span>(people)) * i + pagesize / <span class="hljs-keyword">sizeof</span>(people) - <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> index2 = (pagesize / <span class="hljs-keyword">sizeof</span>(people)) * i + pagesize / <span class="hljs-keyword">sizeof</span>(people) - <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> index3 = (pagesize / <span class="hljs-keyword">sizeof</span>(people)) * (i + <span class="hljs-number">1</span>);<br>    p_map[index1].age = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;access page %d over\n&quot;</span>, i + <span class="hljs-number">1</span>);<br>    p_map[index2].age = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;access page %d edge over, now begin to access page %d\n&quot;</span>, i + <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span>);<br>    p_map[index3].age = <span class="hljs-number">100</span>;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;access page %d over\n&quot;</span>, i + <span class="hljs-number">2</span>);<br>&#125;<br><br>    munmap(p_map, pagesize * <span class="hljs-number">3</span> / <span class="hljs-keyword">sizeof</span>(people));<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式软件基础</title>
    <link href="/2023/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/"/>
    <url>/2023/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E8%BD%AF%E4%BB%B6%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h2 id="一。嵌入式软件的特点"><a href="#一。嵌入式软件的特点" class="headerlink" title="一。嵌入式软件的特点"></a>一。嵌入式软件的特点</h2><ul><li>规模较小</li><li>开发难度大<ul><li>硬件资源有限</li><li>一般涉及到底层软件的开发，需要软硬件基础</li><li>开发环境与运行环境不同</li></ul></li><li>实时性和可靠性要求高</li><li>要求固化存储 </li></ul><h2 id="二。嵌入式软件"><a href="#二。嵌入式软件" class="headerlink" title="二。嵌入式软件"></a>二。嵌入式软件</h2><h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1.分类"></a>1.分类</h3><ul><li>系统软件：控制和管理嵌入式系统资源，如嵌入式操作系统、驱动程序、中间件等</li><li>支撑软件：辅助软件开发的工具软件</li><li>应用软件：定义嵌入式设备的主要功能和用途，负责与用户进行交互</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405220914250.png" alt="image-20230405220914250"></p><h3 id="2-软件体系结构"><a href="#2-软件体系结构" class="headerlink" title="2.软件体系结构"></a>2.软件体系结构</h3><h4 id="1-无操作系统阶段"><a href="#1-无操作系统阶段" class="headerlink" title="1)无操作系统阶段"></a>1)无操作系统阶段</h4><ul><li>硬件配置较低，系统应用主要集中在控制领域</li><li>嵌入式软件的设计以应用为核心，应用软件直接建立在硬件上</li></ul><p>两种实现方式</p><ul><li>循环轮转</li><li>前后台系统(在循环轮转基础上增加了中断处理功能)</li></ul><h5 id="循环轮转"><a href="#循环轮转" class="headerlink" title="循环轮转"></a>循环轮转</h5><ul><li>把系统分解成若干不同任务，包含在死循环的for语句中，按顺序逐一执行    </li></ul><p>​            优点：</p><ul><li>简答，直观，开销少</li></ul><p>​            缺点：</p><ul><li> 所有代码按顺序执行，无法处理异步事件，缺乏并行处理能力</li></ul><h5 id="前后台系统"><a href="#前后台系统" class="headerlink" title="前后台系统"></a>前后台系统</h5><ul><li>前台程序(事件处理级)：中断服务程序。负责处理异步事件</li><li>后台程序(任务级)：一个无限循环，负责资源分配、管理和系统调度<ul><li>系统运行时，后台程序会检查每个任务是否具有运行条件，对实时性要求严格的操作通用由中断完成</li></ul></li></ul><p>​            注意：</p><ul><li>前后台系统认为所有的任务具有相同优先级，任务执行时通过队列排队</li><li>实时性较差</li></ul><h4 id="2-有操作系统阶段"><a href="#2-有操作系统阶段" class="headerlink" title="2)有操作系统阶段"></a>2)有操作系统阶段</h4><ul><li>开发应用在操作系统的基础上编写</li></ul><h5 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h5><ul><li>提高系统可靠性</li><li>提高系统开发效率，降低成本，缩短开发周期<ul><li>可以按软件工程的思想，分解程序为多个任务模块，对每个任务模块调试</li><li>商业软件提供了良好的多任务调试环境</li></ul></li><li>有利于系统的扩展和移植</li></ul><h5 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h5><ul><li>硬件层(最底层)</li><li>设备驱动层(BSP)<ul><li>包含了嵌入式系统中所有与硬件相关的代码</li><li>它负责直接与硬件打交道，对硬件进行管理和控制，为上层软件提供所需的驱动支持(类似与BIOS和驱动)</li></ul></li><li>操作系统层</li><li>中间件层</li><li>应用软件层</li></ul><h5 id="1-设备驱动层"><a href="#1-设备驱动层" class="headerlink" title="1)设备驱动层"></a>1)设备驱动层</h5><p>BSP(板级支持包 Board Support Package)</p><ul><li>把嵌入式系统与具体的硬件平台隔离开来</li><li>BSP中，所有与硬件相关的代码都封装起来，向上提供一个虚拟的硬件平台，供操作系统运行</li><li>操作系统用一组定义好的编程接口与BSP交互，通过BSP访问真正的硬件</li></ul><p>BSP包含两个方面内容</p><ul><li>引导加载程序Boot Loader(类似与BIOS)<ul><li>嵌入式系统加电后运行的第一段软件代码，是在操作系统内核运行前运行的一段小程序<ul><li>初始化硬件设备、建立内存空间的映射图</li><li>将系统的软硬件设置到一个合适的状态，为调用操作系统内核做准备</li></ul></li></ul></li><li>设备驱动程序<ul><li>是一组库函数，用来对硬件进行初始化和管理，并向上层软件提供良好的访问接口</li><li>基本功能：启动、关闭、停用、启用、读操作、写操作</li></ul></li></ul><p>Boot Loader的基本功能</p><ul><li>片级初始化<ul><li>完成微处理器的初始化</li><li>包括设置微处理器的核心寄存器和控制寄存器、微处理器的核心工作模式、局部总线模式等</li><li>把微处理器从上电的默认状态设置成系统要求的工作状态。</li><li>纯硬件初始化过程</li></ul></li><li>板级初始化<ul><li>设置各种硬件寄存器来完成微处理器以外的其他硬件设备的初始化</li><li>设置某些软件的数据结构和参数</li><li>同时有软件和硬件的初始化过程</li></ul></li><li>加载内核<ul><li>将操作系统和应用程序的映象从Flsh存储器复制到系统内存中，</li><li>然后跳转到系统内核的第一条指令处继续执行。</li></ul></li></ul><p>设备驱动程序的组织结构</p><ul><li>分层结构<ul><li>把设备驱动程序中的函数分为硬件接口函数喝调用接口函数</li><li><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230408144401204.png" alt="image-20230408144401204"><ul><li>上层接口不直接与硬件打交道</li></ul></li><li>优点：<ul><li>与硬件相关的细节都封装在硬件接口中，硬件需要升级时，只需要改硬件接口中的函数即可</li></ul></li></ul></li><li>混合结构<ul><li>没有明确层级关系</li><li><h2 id="上层接口和硬件接口函数混在一起、相互调用"><a href="#上层接口和硬件接口函数混在一起、相互调用" class="headerlink" title="上层接口和硬件接口函数混在一起、相互调用"></a>上层接口和硬件接口函数混在一起、相互调用</h2></li></ul></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230408144735814.png" alt="image-20230408144735814"></p><hr><h5 id="2）中间件"><a href="#2）中间件" class="headerlink" title="2）中间件"></a>2）中间件</h5><p>定义：操作系统内核、设备驱动程序和应用软件之外的所有系统软件</p><p>特点：</p><ul><li>可以有效实现软件的可重用，减低应用软件的复杂性、提高系统的开发效率、缩短开发周期，节约开发成本和维护费用，提高系统的高伸缩性、易升级性、稳定性</li><li>缺点：带来额外的开销</li></ul><p>分类</p><ul><li>消息中间件 RM2</li><li>对象中间件 CORBA</li><li>远程过程调用、数据库访问中间件</li><li>安全中间件</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230408145816566.png" alt="image-20230408145816566"></p>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>嵌入式工程师</title>
    <link href="/2023/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E7%A8%8B%E5%B8%88/"/>
    <url>/2023/04/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E5%B7%A5%E7%A8%8B%E5%B8%88/</url>
    
    <content type="html"><![CDATA[<h1 id="嵌入式工程师基础知识部分"><a href="#嵌入式工程师基础知识部分" class="headerlink" title="嵌入式工程师基础知识部分"></a>嵌入式工程师基础知识部分</h1><h2 id="一。进制转换"><a href="#一。进制转换" class="headerlink" title="一。进制转换"></a>一。进制转换</h2><h3 id="1-R进制转十进制"><a href="#1-R进制转十进制" class="headerlink" title="1)R进制转十进制"></a>1)R进制转十进制</h3><p>方法： 按权展开</p><ul><li>二进制转十进制</li></ul><p>$$<br>10100.01 = 1×2^4+1×2^2+1×2¯²<br>$$</p><ul><li>八进制转十进制</li></ul><p>$$<br>604 = 6×8^2+4×8^0<br>$$</p><h3 id="2-十进制转R进制"><a href="#2-十进制转R进制" class="headerlink" title="2)十进制转R进制"></a>2)十进制转R进制</h3><p>方法：短除法</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230402113705985.png" alt="image-20230402113705985"></p><h2 id="二。数据的存储单位"><a href="#二。数据的存储单位" class="headerlink" title="二。数据的存储单位"></a>二。数据的存储单位</h2><ul><li>位 b (bit比特)</li><li>字节 B (Byte)</li></ul><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>B = <span class="hljs-number">8</span> bit<br><span class="hljs-symbol">1 </span>KB = <span class="hljs-number">1024</span> B = <span class="hljs-number">2</span>^<span class="hljs-number">10</span>B<br></code></pre></td></tr></table></figure><p><img src="D:/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%8B%E8%BD%BD/MicrosoftEdgeDropFiles/Notes_230402_162146.jpg" alt="Notes_230402_162146"></p><h2 id="三。数的表示"><a href="#三。数的表示" class="headerlink" title="三。数的表示"></a>三。数的表示</h2><p>原码</p><p>反码：正数同原码，负数符号位不变，按位取反</p><p>补码：负数，符号位不变，原码从右往左第一个1后所有位取反</p><p>移码：补码符号位取反，其他不变</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230402164538360.png" alt="image-20230402164538360"></p><ul><li>原码和反码表示范围比补码少一个</li></ul><p>定点数和浮点数</p><p>1)定点数</p><p>​            小数点的位置固定不变</p><ul><li>定点整数 ： 用来表示整数(小数点位置在数字最低为后)<ul><li>30 ——–&gt;  0001110.</li></ul></li><li>定点小数 ： 用来表示纯小数(小数点在符号位和数值位之间)<ul><li>0.875————&gt;   0.1110000</li></ul></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/Notes_230402_172614%20(1).jpg" alt="Notes_230402_172614 (1)"></p><ul><li>浮点数运算<ul><li>对阶</li><li>尾数计算</li><li>结果格式化</li></ul></li></ul><h2 id="四。计算机的基本组成"><a href="#四。计算机的基本组成" class="headerlink" title="四。计算机的基本组成"></a>四。计算机的基本组成</h2><h3 id="1-输入设备-外设"><a href="#1-输入设备-外设" class="headerlink" title="1)输入设备(外设)"></a>1)输入设备(外设)</h3><h3 id="2-存储器"><a href="#2-存储器" class="headerlink" title="2)存储器"></a>2)存储器</h3><ul><li><h4 id="主存储器-主机"><a href="#主存储器-主机" class="headerlink" title="主存储器(主机)"></a>主存储器(主机)</h4></li><li><h4 id="辅助存储器-外设"><a href="#辅助存储器-外设" class="headerlink" title="辅助存储器(外设)"></a>辅助存储器(外设)</h4></li></ul><h3 id="3-运算器-主机"><a href="#3-运算器-主机" class="headerlink" title="3)运算器(主机)"></a>3)运算器(主机)</h3><ul><li><h4 id="算数逻辑单位ALU："><a href="#算数逻辑单位ALU：" class="headerlink" title="算数逻辑单位ALU："></a>算数逻辑单位ALU：</h4><ul><li>数据的算术运算和逻辑运算</li></ul></li><li><h4 id="累加寄存器AC："><a href="#累加寄存器AC：" class="headerlink" title="累加寄存器AC："></a>累加寄存器AC：</h4><ul><li>通用寄存器组成，为ALU提供一个工作区，用于暂存数据</li></ul></li><li><h4 id="数据缓冲寄存器DR"><a href="#数据缓冲寄存器DR" class="headerlink" title="数据缓冲寄存器DR"></a>数据缓冲寄存器DR</h4><ul><li>读写内存时，暂存指令或数据</li></ul></li><li><h4 id="状态条件寄存器PSW"><a href="#状态条件寄存器PSW" class="headerlink" title="状态条件寄存器PSW"></a>状态条件寄存器PSW</h4><ul><li>存状态标志(如溢出标志)与控制标志</li></ul></li></ul><h3 id="4-控制器-五大部件的控制协调，早期核心-主机"><a href="#4-控制器-五大部件的控制协调，早期核心-主机" class="headerlink" title="4)控制器(五大部件的控制协调，早期核心)(主机)"></a>4)控制器(五大部件的控制协调，早期核心)(主机)</h3><ul><li><h4 id="程序计数器PC"><a href="#程序计数器PC" class="headerlink" title="程序计数器PC"></a>程序计数器PC</h4><ul><li>存储下一条要执行指令的地址(指针)</li></ul></li><li><h4 id="指令寄存器IR"><a href="#指令寄存器IR" class="headerlink" title="指令寄存器IR"></a>指令寄存器IR</h4><ul><li>存储即将执行的指令</li></ul></li><li><h4 id="指令译码器ID"><a href="#指令译码器ID" class="headerlink" title="指令译码器ID"></a>指令译码器ID</h4><ul><li>对指令进行分析解释(解释出操作码)</li></ul></li><li><h4 id="时序部件"><a href="#时序部件" class="headerlink" title="时序部件"></a>时序部件</h4><ul><li>提供时序控制信号指令中的操作码字段</li></ul></li></ul><h3 id="5-输出设备-外设"><a href="#5-输出设备-外设" class="headerlink" title="5)输出设备(外设)"></a>5)输出设备(外设)</h3><ul><li>CPU： 运算器和控制器组成</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230403150752689.png" alt="image-20230403150752689"></p><hr><h3 id="CPU性能指标"><a href="#CPU性能指标" class="headerlink" title="CPU性能指标"></a><strong>CPU性能指标</strong></h3><ul><li>主频</li><li>字长(32位,64位)</li><li>CPU缓存</li><li>核心数量</li></ul><h3 id="总线的分类"><a href="#总线的分类" class="headerlink" title="总线的分类"></a><strong>总线的分类</strong></h3><p>一条总线同时只允许一个设备发送，但允许多个设备接受</p><ul><li><h4 id="数据总线-双向传输-CPU—-gt-主存-主存—–-gt-CPU"><a href="#数据总线-双向传输-CPU—-gt-主存-主存—–-gt-CPU" class="headerlink" title="数据总线(双向传输  CPU—&gt;主存/主存—–&gt;CPU)"></a>数据总线(双向传输  CPU—&gt;主存/主存—–&gt;CPU)</h4><ul><li>在CPU与RAM之间来回传送需要处理或者需要存储的数据</li></ul></li><li><h4 id="地址总线-单向"><a href="#地址总线-单向" class="headerlink" title="地址总线(单向)"></a>地址总线(单向)</h4><ul><li>用来指定在RAM之中存储的数据的地址</li></ul></li><li><h4 id="控制总线-双向"><a href="#控制总线-双向" class="headerlink" title="控制总线(双向)"></a>控制总线(双向)</h4><ul><li>将微处理器控制单元的信号传送到周边设备</li></ul></li></ul><h3 id="总线的性能指标"><a href="#总线的性能指标" class="headerlink" title="总线的性能指标"></a><strong>总线的性能指标</strong></h3><ul><li><h4 id="带宽-单位时间能处理数据的-数据量-位数-单位B-s"><a href="#带宽-单位时间能处理数据的-数据量-位数-单位B-s" class="headerlink" title="带宽 :    单位时间能处理数据的(数据量)位数    单位B/s"></a>带宽 :    单位时间能处理数据的(数据量)位数    单位B/s</h4></li><li><h4 id="位宽-：-数据总线的宽度-单位-bit"><a href="#位宽-：-数据总线的宽度-单位-bit" class="headerlink" title="位宽 ： 数据总线的宽度   单位 bit"></a>位宽 ： 数据总线的宽度   单位 bit</h4></li><li><h4 id="工作频率-单位Hz-1-s"><a href="#工作频率-单位Hz-1-s" class="headerlink" title="工作频率 :    单位Hz(1/s)"></a>工作频率 :    单位Hz(1/s)</h4></li></ul><h5 id="带宽-位宽-×-工作频率-数据总量-总时间"><a href="#带宽-位宽-×-工作频率-数据总量-总时间" class="headerlink" title="带宽    =    位宽    ×    工作频率    (数据总量/总时间)"></a>带宽    =    位宽    ×    工作频率    (数据总量/总时间)</h5><ul><li>处理机由处理器、存储器和总线组成</li></ul><h3 id="BIOS-CMOS"><a href="#BIOS-CMOS" class="headerlink" title="BIOS/CMOS"></a><strong>BIOS/CMOS</strong></h3><ul><li>CMOS:     芯片(电池供电，保存计算机配置信息)    RAM(可读写)</li><li>BIOS：    程序(将配置信息进行修改写入CMOS)  ROM</li></ul><h3 id="系统性能评测方法"><a href="#系统性能评测方法" class="headerlink" title="系统性能评测方法"></a><strong>系统性能评测方法</strong></h3><ul><li>时钟频率</li><li>指令执行</li><li>等效指令速度法</li><li>数据处理速度PDR</li><li>核心程序法</li><li>基准测试程序</li></ul><hr><h3 id="指令系统"><a href="#指令系统" class="headerlink" title="指令系统"></a>指令系统</h3><h4 id="1-定义"><a href="#1-定义" class="headerlink" title="1)定义"></a>1)定义</h4><p>指令： 一条指令就是机器语言的一个语句</p><p>​             是一组有意义的二进制代码</p><h4 id="2-构成"><a href="#2-构成" class="headerlink" title="2)构成"></a>2)构成</h4><pre><code class="hljs">         操作码OP +  地址码字段A</code></pre><ul><li>操作码 ： 指出计算机要执行什么性质的操作</li><li>地址码 :    包含各操作数的地址及操作结果的存放地址等</li></ul><p>累加寄存器AC 程序计数器PC</p><p>4地址:  A1 OP A2—&gt;A3  A4—–&gt;下一条指令地址</p><p>3地址: A1 OP A2—-&gt;A3 PC—–&gt;下一条</p><p>2地址: A1 OP A2—–&gt;AC  PC—-&gt;下一条</p><p>1地址： AC OP A2 —-&gt; AC</p><p>0地址： 出栈入栈 pop push</p><h4 id="3-寻址方式"><a href="#3-寻址方式" class="headerlink" title="3)寻址方式"></a>3)寻址方式</h4><p>作用:  </p><ul><li>扩大寻址空间</li><li>提高编程灵活性</li></ul><p>方式</p><ul><li>立即寻址方式<ul><li>操作数直接在指令中，速度快，灵活性差</li></ul></li><li>直接寻址方式<ul><li>指令中存放的是操作数的地址</li></ul></li><li>间接寻址方式<ul><li>指令中存放了一个地址，这个地址对应的内容是操作数的地址</li></ul></li><li>寄存器寻址方式<ul><li>寄存器存放操作数</li></ul></li><li>寄存器间接寻址方式<ul><li>寄存器内存放的操作数的地址</li></ul></li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230404153144046.png" alt="image-20230404153144046"></p><h2 id="五。流水线"><a href="#五。流水线" class="headerlink" title="五。流水线"></a>五。流水线</h2><h4 id="1-定义-1"><a href="#1-定义-1" class="headerlink" title="1)定义"></a>1)定义</h4><p>​                多条指令重叠进行操作的一种准并行处理实现技术</p><h4 id="2-指令执行的过程"><a href="#2-指令执行的过程" class="headerlink" title="2)指令执行的过程"></a>2)指令执行的过程</h4><p>​                取值    ———&gt;    分析    ————-&gt;    执行</p><h4 id="3-流水线周期"><a href="#3-流水线周期" class="headerlink" title="3)流水线周期"></a>3)流水线周期</h4><h5 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h5><p>​                执行时间最长的一段Δt</p><h5 id="计算公式："><a href="#计算公式：" class="headerlink" title="计算公式："></a>计算公式：</h5><p>​                TK = 一条指令执行时间+ (指令条数-1)*流水线周期</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230404155238695.png" alt="image-20230404155238695"></p><h5 id="流水线吞吐率"><a href="#流水线吞吐率" class="headerlink" title="流水线吞吐率"></a>流水线吞吐率</h5><p>​<br>$$<br>TP = n/T_k<br>$$</p><ul><li>单位时间内完成指令的条数</li><li>最大吞吐率，即为流水线周期的倒数  1/Δt</li></ul><h4 id="4-例题"><a href="#4-例题" class="headerlink" title="4)例题"></a>4)例题</h4><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230404160213989.png" alt="image-20230404160213989"></p><p>流水线周期：执行时间最长的一段即为2ns</p><p>总时间：<br>$$<br>(2+2+1)+(100-1)*2=203ns<br>$$</p><h2 id="六。多级存储器结构"><a href="#六。多级存储器结构" class="headerlink" title="六。多级存储器结构"></a>六。多级存储器结构</h2><h4 id="1-层级结构"><a href="#1-层级结构" class="headerlink" title="1)层级结构"></a>1)层级结构</h4><p>​        自上而下，组成6个层次结构，依次变慢，访问效率更低，容量更大，价格更低</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/ddaa497b1717420b8e0c3ddc994081e2.png" alt="img"></p><h4 id="2-Cache"><a href="#2-Cache" class="headerlink" title="2)Cache"></a>2)Cache</h4><ul><li><p>功能：提高CPU数据输入输出的速率</p></li><li><p>速度：计算机存储系统体系中，Cache是访问速度较快的层次</p></li><li><p>原理：局部性原理</p><ul><li>空间局部性：一个内存位置被引用了一次，那么程序很可能在不远的将来引用其<strong>附近的一个内存位置</strong>。</li><li>时间局部性：被引用过一次的内存位置<strong>很可能在不远的将来再被多次引用</strong>。</li></ul></li><li><p>组成：控制部分和Cache存储器部分</p></li><li><p>位置：介于CPU与内存之间</p></li><li><p>平均系统周期时间<br>$$<br>t_3=h*t_1+(1-h)*t_2<br>$$</p><ul><li>h：Cache访问命中率</li><li>t1:  访问Cache周期时间</li><li>t2:  访问主存储器周期时间</li><li>t3:  系统平均周期</li></ul></li></ul><h4 id="3-地址映像"><a href="#3-地址映像" class="headerlink" title="3)地址映像"></a>3)地址映像</h4><h5 id="1-直接映像"><a href="#1-直接映像" class="headerlink" title="1.直接映像"></a>1.直接映像</h5><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405115132244.png" alt="image-20230405115132244"></p><ul><li>主存储器中一块只能映像到cache中一个特点的块中</li><li>主存与缓存分成相同大小的数据块</li><li>主存空间按缓存容量分成区，每一区的块数与缓存的总块数相等</li><li>主存中某区的一块存入缓存时只能存入缓存中块号相同的位置</li></ul><p>特点</p><ul><li>地址变换电路简单，访问速度快</li><li>空间利用率低，冲突概率高</li><li>对页面置换算法依赖度较高，且Cache空间利用率较低，命中率较低</li></ul><h5 id="2-全相联映像"><a href="#2-全相联映像" class="headerlink" title="2.全相联映像"></a>2.全相联映像</h5><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405120641938.png" alt="image-20230405120641938"></p><ul><li>主存中任意一块可以映像到cache中任意一块的位置上</li><li>主存和缓存分成相同大小的数据块</li><li>主存的某一数据块可以装入缓存的任意块空间中</li></ul><p>特点</p><ul><li>空间利用率高，命中率较高</li><li>冲突概率低</li><li>实现复杂，速度慢，适合小容量cache</li></ul><h5 id="3-组相联映像"><a href="#3-组相联映像" class="headerlink" title="3.组相联映像"></a>3.组相联映像</h5><ul><li>主存和cache按相同大小分块</li><li>cache分为若干组，如两块一组，主存按cache组数分区</li><li><strong>每个组间采用直接映像方式</strong></li><li><strong>组内块采用全相联映像</strong></li></ul><p>特点</p><ul><li>折中方法</li><li>实现难度和成本比直接映像高</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405120926693.png" alt="image-20230405120926693"></p><h2 id="七。-I-O控制"><a href="#七。-I-O控制" class="headerlink" title="七。 I/O控制"></a>七。 I/O控制</h2><h5 id="直接程序控制："><a href="#直接程序控制：" class="headerlink" title="直接程序控制："></a>直接程序控制：</h5><ul><li>无条件传送方式</li><li>程序查询方式</li></ul><p>中断方式</p><ul><li>释放CPU，提高执行效率</li></ul><p>直接存储器存取方式(DMA)</p><ul><li>在传送数据块的过程中不需要CPU的干涉</li><li>是IO与主存之间传送数据的方式，数据不经过CPU</li></ul><p>输入输出处理机(IOP)</p><ul><li>有独立处理功能(用于大型处理机)</li></ul><h2 id="八。可靠性、检验码"><a href="#八。可靠性、检验码" class="headerlink" title="八。可靠性、检验码"></a>八。可靠性、检验码</h2><h5 id="可靠度计算"><a href="#可靠度计算" class="headerlink" title="可靠度计算"></a>可靠度计算</h5><p>​                                失效率 = 1- 可靠度</p><ul><li>串联系统</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405150512667.png" alt="image-20230405150512667"></p><ul><li>并联系统</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405150614584.png" alt="image-20230405150614584"></p><ul><li>混合系统</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230405150815450.png" alt="image-20230405150815450"></p><h5 id="校验码"><a href="#校验码" class="headerlink" title="校验码"></a>校验码</h5><ul><li><p>码距</p><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gcode">一个编码系统的码距就是整个编码系统中任意两个码字<span class="hljs-comment">(合法编码)</span>的最小距离<br></code></pre></td></tr></table></figure></li><li><p>奇偶校验码</p><ul><li>可检测1位错</li></ul></li><li><p>CRC(循环冗余码)</p><ul><li>利用生成多项式为k个数据位产生r个校验位来进行编码(编码长度:k+r)</li><li>可检测多位错</li><li>模2运算</li></ul></li><li><p>海明码</p><ul><li>可纠正一位错</li><li>在数据位之间插入K个校验位，通过扩大码距来实现检查和纠错</li><li>数据位n位,校验位k位</li></ul></li></ul><p>$$<br>2^k -1 &gt;= n+k<br>$$</p><h2 id=""><a href="#" class="headerlink" title=""></a></h2>]]></content>
    
    
    
    <tags>
      
      <tag>嵌入式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客网站搭建</title>
    <link href="/2023/04/01/hexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/"/>
    <url>/2023/04/01/hexo%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="Hexo简介"><a href="#Hexo简介" class="headerlink" title="Hexo简介"></a>Hexo简介</h1><p>​    Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><h1 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h1><p>​    在安装Hexo之前需要安装以下应用</p><ul><li>Node.js</li><li>Git</li><li>markdown语法编辑器(这里推荐typora)</li></ul><p>可以通过在cmd中以下命令查看主机中是否安装了node.js和npm</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node --version    <span class="hljs-comment">#检查是否安装了node.js</span><br>npm --version     <span class="hljs-comment">#检查是否安装了npm</span><br></code></pre></td></tr></table></figure><h1 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h1><p>​    通过在cmd中输入以下命令使用npm安装Hexo</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>​    安装完成后输入以下命令，查看hexo版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo -v<br></code></pre></td></tr></table></figure><h1 id="配置Hexo"><a href="#配置Hexo" class="headerlink" title="配置Hexo"></a>配置Hexo</h1><h2 id="1-新建文件夹"><a href="#1-新建文件夹" class="headerlink" title="1)新建文件夹"></a>1)新建文件夹</h2><p>​        此文件夹用于存放hexo所有代码、配置文件。放在自己能记住的地方就行</p><hr><h2 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2)初始化"></a>2)初始化</h2><p>​        进入新建的文件夹，右键打开Git Bash Here，输入以下命令进行初始化</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><p>​    初始化完成后会出现以下的文件目录结构</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/Snipaste_2023-04-01_17-04-20.png" alt="Snipaste_2023-04-01_17-04-20"></p><ul><li>public     .github目录在后面步骤中才会出现</li></ul><hr><h2 id="3-新建md文档"><a href="#3-新建md文档" class="headerlink" title="3)新建md文档"></a>3)新建md文档</h2><p>​        在当前目录，右键打开Git Bash Here，输入以下命令新建md文档</p><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs actionscript">hexo <span class="hljs-keyword">new</span> <span class="hljs-string">&quot;md文档名&quot;</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401171034750.png" alt="image-20230401171034750"></p><ul><li>新建的md文档存放在<code>source\_posts</code>目录下</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401171140753.png" alt="image-20230401171140753"></p><ul><li>新建的md文档中会自带一些文档信息，可以根据需求填写。不同主题中，头部信息的种类也有所不同。</li></ul><hr><h2 id="4-网站生成和预览"><a href="#4-网站生成和预览" class="headerlink" title="4)网站生成和预览"></a>4)网站生成和预览</h2><p>​            首先执行下列命令生成相应的静态网页，生成的静态网页以及相关资源都会在<code>public</code>目录下</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br></code></pre></td></tr></table></figure><p>​            然后输入下面命令可以开启本地网页预览服务</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo s</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401202831699.png" alt="image-20230401202831699"></p><p>​            访问<a href="https://link.zhihu.com/?target=http://localhost:4000/">http://localhost:4000</a>即可看到博客内容</p><hr><h2 id="5-更换博客网站主题"><a href="#5-更换博客网站主题" class="headerlink" title="5)更换博客网站主题"></a>5)更换博客网站主题</h2><p>​            在<a href="https://hexo.io/themes/">Hexo官网</a>中提供了大量优质的主题，你可以任意挑选你喜欢的主题</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401212906423.png" alt="image-20230401212906423"></p><p>​            在主题介绍中往往有安装方法，一般以git clone和npm安装两种方法为主</p><pre><code class="hljs">         主题文件将存放在themes文件夹中</code></pre><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401213202224.png" alt="image-20230401213202224"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401213255894.png" alt="image-20230401213255894"></p><p>​            在_config.yml文件中你可以个性化配置你的主题</p><p>​            然后在hexo头目录的_config.yml(注意不是themes中的_config.yml)文件中将<code>theme:</code>处填写上你下载的主题文件名，然后重新输入<code>hexo g   </code>        <code>hexo s</code> 查看修改效果</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401213448689.png" alt="image-20230401213448689"></p><hr><h2 id="6-将博客网站部署到Github"><a href="#6-将博客网站部署到Github" class="headerlink" title="6)将博客网站部署到Github"></a>6)将博客网站部署到Github</h2><p>​            上面生成的网站只是部署在本地的静态网站，想要别人也能访问你的网站，需要使用GitHub Actions部署到GitHub Pages</p><h3 id="1-注册GitHub账户"><a href="#1-注册GitHub账户" class="headerlink" title="1)注册GitHub账户"></a>1)注册GitHub账户</h3><p>​            你可以在<a href="https://github.com/">GitHub</a>官网中注册账户，国内访问可能加载会比较慢</p><h3 id="2-新建仓库用于存放网站文件"><a href="#2-新建仓库用于存放网站文件" class="headerlink" title="2)新建仓库用于存放网站文件"></a>2)新建仓库用于存放网站文件</h3><p>​        <img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401203801784.png" alt="image-20230401203801784"></p><p>​            这里仓库名的名字必须为”你的用户名.github.io”</p><p>​            然后默认设置为公开模式，创建仓库即可</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401204210666.png" alt="image-20230401204210666"></p><h3 id="3-生成SSH添加到GitHub"><a href="#3-生成SSH添加到GitHub" class="headerlink" title="3)生成SSH添加到GitHub"></a>3)生成SSH添加到GitHub</h3><p>​                在网站文件目录中，右键打开Git Bash Here</p><p>​                1.通过git config命令获取并设置存储库或全局选项。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;yourname&quot;</span><br>git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><ul><li>yourname处填写你GitHub用户名</li><li>yourmail处填写你GitHub注册所用邮箱</li></ul><p>​                可以通过下面两条指令，检查你刚输入的信息</p><p>​        </p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">git config <span class="hljs-keyword">user</span>.name<br>git config <span class="hljs-keyword">user</span>.email<br></code></pre></td></tr></table></figure><p>​                确实信息正确后，可以输入下面的指令创建SSH</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs excel">ssh-keygen -<span class="hljs-built_in">t</span> rsa -C <span class="hljs-string">&quot;youremail&quot;</span><br></code></pre></td></tr></table></figure><ul><li>yourmail处与上面填写的一致</li><li>途中会询问你是否创建SSH，输入y回车即可</li></ul><p>​                创建SSH成功后，你可以在Git Bash中输入以下指令找到你生成的SSH</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401210046613.png" alt="image-20230401210046613"></p><p>​                你也可以在<code>C:\Users\用户名\.ssh</code>目录下找到id_rsa.pub文件</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401210158682.png" alt="image-20230401210158682"></p><p>​                 复制文件内所有内容待用</p><ul><li>git中复制快捷键为CTRL+Ins  粘贴为Shift+Ins</li></ul><p>​                然后回到GitHub中进入Settings中找到SSH and GPG keys新建SSH key</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401210601584.png" alt="image-20230401210601584"></p><p>​                将你刚复制的SSH填入创建SSH key                <img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401210659767.png" alt="image-20230401210659767"></p><p>​                然后在git bash中查看是否连接成功</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">ssh</span> -T git<span class="hljs-variable">@github</span>.com<br></code></pre></td></tr></table></figure><p>​                <img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401210909207.png" alt="image-20230401210909207"></p><p>​                出现successfully即代表连接成功</p><h3 id="4-将Hexo部署到GitHub"><a href="#4-将Hexo部署到GitHub" class="headerlink" title="4)将Hexo部署到GitHub"></a>4)将Hexo部署到GitHub</h3><p>​                首先安装deploy-git部署命令</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>​                然后进入_config.yml文件，在配置文件最底下进行修改</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401211142823.png" alt="image-20230401211142823"></p><p>​                </p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">deploy:</span> <br><span class="hljs-symbol">  type:</span> git<br><span class="hljs-symbol">  repo:</span> git@github.com:ahaostillcoding/ahaostillcoding.github.io.git<br><span class="hljs-symbol">  branch:</span> main<br></code></pre></td></tr></table></figure><p>​                    repo和branch处按你创建的仓库信息进行填写，如图所示<img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401211608778.png" alt="image-20230401211608778"></p><p>​                然后通过以下命令，实现部署</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">hexo g</span><br><span class="hljs-attribute">hexo d</span><br></code></pre></td></tr></table></figure><ul><li><p>hexo d即hexo deploy部署文件</p></li><li><p>hexo g即为前文中提到的生成静态文件</p></li><li><p>另有hexo clean命令用于清楚你之前生成的文件</p><p>部署成功后你可以在Actions看到部署进度，当部署完成后，你可以通过访问</p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401212407612.png" alt="image-20230401212407612"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230401212309733.png" alt="image-20230401212309733"></p></li></ul><hr><p>到处为止，你的个人博客网站就搭建完成啦，愉快的写博客吧</p>]]></content>
    
    
    
    <tags>
      
      <tag>hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ubuntu硬盘扩容</title>
    <link href="/2023/04/01/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9(vm%EF%BC%89/"/>
    <url>/2023/04/01/Ubuntu%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A1%AC%E7%9B%98%E6%89%A9%E5%AE%B9(vm%EF%BC%89/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux Ubuntu</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux文件解压和压缩</title>
    <link href="/2023/03/22/Linux%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9/"/>
    <url>/2023/03/22/Linux%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<h1 id="压缩和解压"><a href="#压缩和解压" class="headerlink" title="压缩和解压"></a>压缩和解压</h1><h2 id="压缩格式"><a href="#压缩格式" class="headerlink" title="压缩格式"></a>压缩格式</h2><p>Linux,MacOS常用</p><ul><li><p>tar</p></li><li><p>gzip</p></li><li><p>zip</p></li></ul><hr><h2 id="tar命令解压、压缩"><a href="#tar命令解压、压缩" class="headerlink" title="tar命令解压、压缩"></a>tar命令解压、压缩</h2><h3 id="格式-：-tar-c-v-x-f-z-C-参数1-参数N"><a href="#格式-：-tar-c-v-x-f-z-C-参数1-参数N" class="headerlink" title="格式 ： tar     [-c     -v    -x    -f    -z    -C]    参数1    参数N"></a>格式 ： tar     [-c     -v    -x    -f    -z    -C]    参数1    参数N</h3><ul><li>-c : 创建压缩文件</li><li>-v : 显示压缩、解压过程</li><li>-x : 解压模式</li><li>-f : 要创建的文件，或者要解压的文件，-f必须放在选项中最后一个</li><li>-z : gzip模式，默认是tarball格式(gzip模式压缩文件体积更小)</li><li>-C ： 选择解压路径，用于解压模式</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230304180246541.png" alt="image-20230304180246541"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>-z： 需要处于选项第一个</li><li>-f :    需要处于选项最后一个</li><li>-C :   单独使用，和解压所需的其他参数分开</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230305150230553.png" alt="image-20230305150230553"></p><hr><h2 id="zip命令压缩文件"><a href="#zip命令压缩文件" class="headerlink" title="zip命令压缩文件"></a>zip命令压缩文件</h2><h3 id="格式-：-zip-r-压缩包名-被压缩文件1····被压缩文件N"><a href="#格式-：-zip-r-压缩包名-被压缩文件1····被压缩文件N" class="headerlink" title="格式    ： zip    [-r]    压缩包名 被压缩文件1····被压缩文件N"></a>格式    ： zip    [-r]    压缩包名 被压缩文件1····被压缩文件N</h3><ul><li>-r :    被压缩的包含文件夹</li></ul><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230305150606894.png" alt="image-20230305150606894"></p><hr><h2 id="unzip解压文件"><a href="#unzip解压文件" class="headerlink" title="unzip解压文件"></a>unzip解压文件</h2><h3 id="格式：-unzip-d-参数"><a href="#格式：-unzip-d-参数" class="headerlink" title="格式： unzip    [-d]    参数"></a>格式： unzip    [-d]    参数</h3><ul><li> -d :     指定要解压去的位置，同tar的-C</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JSP</title>
    <link href="/2023/03/22/JSP/"/>
    <url>/2023/03/22/JSP/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>地址映射</title>
    <link href="/2023/03/14/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/"/>
    <url>/2023/03/14/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>您好，这是必应。组相联映射是一种主存储器与高速缓存之间的一种地址映射关系²，它是直接映射和全相联映射的折中方案¹。它将主存储器和高速缓存按同样大小分组，组内再分成同样大小的块，组间采用直接映射，组内的块之间采用全相联映射²。这样可以提高高速缓存的命中率和访问效率³。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Guangzhou</title>
    <link href="/2023/03/11/Guangzhou/"/>
    <url>/2023/03/11/Guangzhou/</url>
    
    <content type="html"><![CDATA[<h1 id="广州之旅"><a href="#广州之旅" class="headerlink" title="广州之旅"></a>广州之旅</h1><center>1月1日~1月4日</center><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234626539.png" alt="image-20230311234626539"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234639955.png" alt="image-20230311234638791"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234648895.png" alt="image-20230311234648895"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234705429.png" alt="image-20230311234705429"></p><h2 id="沙面"><a href="#沙面" class="headerlink" title="沙面"></a>沙面</h2><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234718668.png" alt="image-20230311234718668"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234723634.png" alt="image-20230311234723634"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234904674.png" alt="image-20230311234904674"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234912315.png" alt="image-20230311234912315"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234729200.png" alt="image-20230311234729200"></p><h2 id="永庆坊"><a href="#永庆坊" class="headerlink" title="永庆坊"></a>永庆坊</h2><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234734859.png" alt="image-20230311234734859"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234739464.png" alt="image-20230311234739464"></p><h2 id="广州塔"><a href="#广州塔" class="headerlink" title="广州塔"></a>广州塔</h2><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234744991.png" alt="image-20230311234744991"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234749958.png" alt="image-20230311234749958"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234754469.png" alt="image-20230311234754469"></p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234607717.png" alt="image-20230311234607717" style="zoom:200%;" /><h2 id="陈家祠"><a href="#陈家祠" class="headerlink" title="陈家祠"></a>陈家祠</h2><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234920033.png" alt="image-20230311234920033"></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/image-20230311234944813.png" alt="image-20230311234944813"></p>]]></content>
    
    
    
    <tags>
      
      <tag>生活</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/03/11/Git/"/>
    <url>/2023/03/11/Git/</url>
    
    <content type="html"><![CDATA[<p>Git 是一个开源的<strong>分布式版本控制系统</strong>，用于敏捷高效地处理任何或小或大的项目。</p><p>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p><h1 id="Git安装"><a href="#Git安装" class="headerlink" title="Git安装"></a>Git安装</h1><p>各平台安装包下载地址为</p><p><a href="https://git-scm.com/downloads">Git - Downloads (git-scm.com)</a></p><h1 id="Git-配置"><a href="#Git-配置" class="headerlink" title="Git 配置"></a>Git 配置</h1><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><p>配置个人的用户名称和电子邮件地址：</p><ul><li>电子邮箱不一定需要真实邮箱</li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus">$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.name</span> <span class="hljs-string">&quot;runoob&quot;</span><br>$ git config <span class="hljs-attr">--global</span> user<span class="hljs-selector-class">.email</span> test@runoob.com<br></code></pre></td></tr></table></figure><h1 id="Git-创建仓库"><a href="#Git-创建仓库" class="headerlink" title="Git 创建仓库"></a>Git 创建仓库</h1><h2 id="一。git-init-初始化仓库"><a href="#一。git-init-初始化仓库" class="headerlink" title="一。git init 初始化仓库"></a>一。git init 初始化仓库</h2><h2 id="二。git-clone-拷贝仓库中项目"><a href="#二。git-clone-拷贝仓库中项目" class="headerlink" title="二。git clone 拷贝仓库中项目"></a>二。git clone 拷贝仓库中项目</h2><ul><li>git init - 初始化仓库。</li><li>git add . - 添加文件到暂存区。</li><li>git commit - 将暂存区内容添加到仓库中。</li></ul><h1 id="Git-远程仓库-Github"><a href="#Git-远程仓库-Github" class="headerlink" title="Git 远程仓库(Github)"></a>Git 远程仓库(Github)</h1><p>使用以下命令生成 SSH Key：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>ssh-keygen -t rsa -C <span class="hljs-string">&quot;youremail@example.com&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>工具</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux命令指南</title>
    <link href="/2023/03/11/Linux%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/"/>
    <url>/2023/03/11/Linux%E5%91%BD%E4%BB%A4%E6%8C%87%E5%8D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="一。命令通用格式"><a href="#一。命令通用格式" class="headerlink" title="一。命令通用格式"></a>一。命令通用格式</h1><h3 id="command-options-parameter"><a href="#command-options-parameter" class="headerlink" title="command [-options] [parameter]"></a>command [-options] [parameter]</h3><ul><li><h3 id="command-命令本身"><a href="#command-命令本身" class="headerlink" title="command: 命令本身"></a>command: 命令本身</h3></li><li><h3 id="options-可选命令-通过选项控制命令的行为细节"><a href="#options-可选命令-通过选项控制命令的行为细节" class="headerlink" title="-options:可选命令(通过选项控制命令的行为细节)"></a>-options:可选命令(通过选项控制命令的行为细节)</h3></li><li><h3 id="parameter-可选命令-多用于命令的指向目标"><a href="#parameter-可选命令-多用于命令的指向目标" class="headerlink" title="parameter:可选命令(多用于命令的指向目标)"></a>parameter:可选命令(多用于命令的指向目标)</h3></li></ul><h1 id="二。-ls命令"><a href="#二。-ls命令" class="headerlink" title="二。    ls命令"></a>二。    ls命令</h1><h2 id="1-作用："><a href="#1-作用：" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="列出目录下的内容"><a href="#列出目录下的内容" class="headerlink" title="列出目录下的内容"></a>列出目录下的内容</h3><h2 id="2-特点："><a href="#2-特点：" class="headerlink" title="2)特点："></a>2)特点：</h2><p>HOME目录(相当于Window的用户目录)——&gt;默认设置的工作目录</p><h2 id="3-格式："><a href="#3-格式：" class="headerlink" title="3)格式："></a>3)格式：</h2><h3 id="ls-a-l-h-Linux路径"><a href="#ls-a-l-h-Linux路径" class="headerlink" title="ls [-a -l -h] [Linux路径]"></a><strong>ls [-a -l -h] [Linux路径]</strong></h3><ul><li><h3 id="a-l-h是可选的选项"><a href="#a-l-h是可选的选项" class="headerlink" title="-a -l -h是可选的选项"></a>-a -l -h是可选的选项</h3></li><li><h3 id="路径是命令可选的参数"><a href="#路径是命令可选的参数" class="headerlink" title="路径是命令可选的参数"></a>路径是命令可选的参数</h3></li></ul><h2 id="4-参数："><a href="#4-参数：" class="headerlink" title="4)参数："></a>4)参数：</h2><p>查看指定路径下文件(不写是默认HOME目录)    </p><p>查看根目录： ls /</p><h2 id="5-选项"><a href="#5-选项" class="headerlink" title="5)选项"></a>5)选项</h2><p><strong>注意：</strong></p><p><strong>1)选项可以组合使用</strong></p><ul><li> ls -a -l</li><li> ls -la</li></ul><p><strong>2)-h要和-l组合使用</strong></p><p><strong>选项功能</strong></p><ul><li>-a  : 列出全部文件(包括隐藏文件/文件夹)  文件名字前有.的为隐藏文件</li><li>-l   : 以列表(竖向)形式展示内容，并展示更多信息(如时间，权限)</li><li>-h  : 以易于阅读的方式展示文件大小(有单位)  </li></ul><h1 id="三。cd-pwd命令"><a href="#三。cd-pwd命令" class="headerlink" title="三。cd/pwd命令"></a>三。cd/pwd命令</h1><h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2><h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1)作用:"></a>1)作用:</h2><h3 id="更改当前所在的工作目录"><a href="#更改当前所在的工作目录" class="headerlink" title="更改当前所在的工作目录"></a>更改当前所在的工作目录</h3><h2 id="2-格式"><a href="#2-格式" class="headerlink" title="2)格式:"></a>2)格式:</h2><h2 id="cd-【Linux路径】"><a href="#cd-【Linux路径】" class="headerlink" title="cd 【Linux路径】"></a><strong>cd 【Linux路径】</strong></h2><h2 id="3-注意"><a href="#3-注意" class="headerlink" title="3)注意"></a>3)注意</h2><ul><li><strong>不给参数，进入HOME目录</strong></li></ul><h2 id="4-特殊路径符"><a href="#4-特殊路径符" class="headerlink" title="4)特殊路径符"></a>4)特殊路径符</h2><ul><li> cd.. ：返回上一级目录</li><li> cd~:   切换到HOME路径</li></ul><h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2><h2 id="1-作用：-1"><a href="#1-作用：-1" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="查看当前所在的工作目录路径"><a href="#查看当前所在的工作目录路径" class="headerlink" title="查看当前所在的工作目录路径"></a>查看当前所在的工作目录路径</h3><h2 id="2-格式-1"><a href="#2-格式-1" class="headerlink" title="2)格式:"></a>2)格式:</h2><p><strong>直接输入pwd</strong></p><h1 id="四。-mkdir命令"><a href="#四。-mkdir命令" class="headerlink" title="四。-mkdir命令"></a>四。-mkdir命令</h1><h2 id="1-作用：-2"><a href="#1-作用：-2" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h3><h2 id="2-格式："><a href="#2-格式：" class="headerlink" title="2)格式："></a>2)格式：</h2><p><strong>mkdir [-p]  Linux路径</strong></p><ul><li>参数必填：必须有创建文件夹的路径</li><li>-p : 自动创建不存在的父目录</li></ul><h2 id="3-注意："><a href="#3-注意：" class="headerlink" title="3)注意："></a>3)注意：</h2><ul><li>创建文件夹需要修改权限，mkdir命令要在HOME目录内操作</li></ul><p>cp,</p><h1 id="五。-文件操作命令-touch-cat-more，cp-mv-rm"><a href="#五。-文件操作命令-touch-cat-more，cp-mv-rm" class="headerlink" title="五。 文件操作命令(touch,cat,more，cp,mv,rm)"></a>五。 文件操作命令(touch,cat,more，cp,mv,rm)</h1><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><h2 id="1-作用：-3"><a href="#1-作用：-3" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="创建文件"><a href="#创建文件" class="headerlink" title="创建文件"></a>创建文件</h3><h2 id="2-格式：-1"><a href="#2-格式：-1" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="touch-Linux路径"><a href="#touch-Linux路径" class="headerlink" title="touch Linux路径"></a>touch Linux路径</h3><hr><h2 id="cat命令"><a href="#cat命令" class="headerlink" title="cat命令"></a>cat命令</h2><h2 id="1-作用：-4"><a href="#1-作用：-4" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="查看文件内容"><a href="#查看文件内容" class="headerlink" title="查看文件内容"></a>查看文件内容</h3><h2 id="2-格式：-2"><a href="#2-格式：-2" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="cat-Linux路径"><a href="#cat-Linux路径" class="headerlink" title="cat Linux路径"></a>cat Linux路径</h3><hr><h2 id="more命令"><a href="#more命令" class="headerlink" title="more命令"></a>more命令</h2><h2 id="1-作用：-5"><a href="#1-作用：-5" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="查看文件内容-可翻页查看"><a href="#查看文件内容-可翻页查看" class="headerlink" title="查看文件内容,可翻页查看"></a>查看文件内容,可翻页查看</h3><h2 id="2-格式：-3"><a href="#2-格式：-3" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="more-路径"><a href="#more-路径" class="headerlink" title="more 路径"></a>more 路径</h3><h2 id="3-注意：-1"><a href="#3-注意：-1" class="headerlink" title="3)注意："></a>3)注意：</h2><ul><li>使用空格，上下键翻页</li><li>按q退出查看</li></ul><hr><h2 id="cp命令"><a href="#cp命令" class="headerlink" title="cp命令"></a>cp命令</h2><h2 id="1-作用：-6"><a href="#1-作用：-6" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="复制文件-文件夹"><a href="#复制文件-文件夹" class="headerlink" title="复制文件/文件夹"></a>复制文件/文件夹</h3><h2 id="2-格式：-4"><a href="#2-格式：-4" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="cp-r-参数1-参数2"><a href="#cp-r-参数1-参数2" class="headerlink" title="cp     [-r]    参数1      参数2"></a>cp     [-r]    参数1      参数2</h3><ul><li> -r  : 用于复制文件夹，表示递归</li><li> 参数1: 被复制文件/文件夹路径</li><li> 参数2：复制去的路径</li></ul><hr><h2 id="mv命令"><a href="#mv命令" class="headerlink" title="mv命令"></a>mv命令</h2><h2 id="1-作用：-7"><a href="#1-作用：-7" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="移动文件-文件夹"><a href="#移动文件-文件夹" class="headerlink" title="移动文件/文件夹"></a>移动文件/文件夹</h3><h2 id="2-格式：-5"><a href="#2-格式：-5" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="mv-参数1-参数2"><a href="#mv-参数1-参数2" class="headerlink" title="mv     参数1     参数2"></a>mv     参数1     参数2</h3><ul><li><strong>如果参数2中目标不存在，会给参数1改成参数2名称</strong></li></ul><hr><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><h2 id="1-作用：-8"><a href="#1-作用：-8" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="删除文件、文件夹"><a href="#删除文件、文件夹" class="headerlink" title="删除文件、文件夹"></a>删除文件、文件夹</h3><h2 id="2-格式：-6"><a href="#2-格式：-6" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="rm-r-f-参数1-参数2………参数N"><a href="#rm-r-f-参数1-参数2………参数N" class="headerlink" title="rm     [-r -f]    参数1     参数2………参数N"></a>rm     [-r -f]    参数1     参数2………参数N</h3><ul><li>-r : 删除文件夹</li><li>-f : 强制删除(不会弹出提示信息)<ul><li>一般只有root用户使用(su - root 进入root用户，exit退出到普通用户)<ul><li>rm -rf /    从根目录开始删除</li></ul></li></ul></li></ul><h2 id="3-通配符"><a href="#3-通配符" class="headerlink" title="3)通配符*"></a>3)通配符*</h2><h3 id="用于模糊匹配"><a href="#用于模糊匹配" class="headerlink" title="用于模糊匹配"></a>用于模糊匹配</h3><ul><li>rm test* ：    删除所有以test开头的内容</li><li>rm *test :       删除以test结尾的内容</li><li>rm * test *:     删除所有包含test的内容        </li></ul><hr><h1 id="六。查找命令-which-find"><a href="#六。查找命令-which-find" class="headerlink" title="六。查找命令(which/find)"></a>六。查找命令(which/find)</h1><h2 id="which命令"><a href="#which命令" class="headerlink" title="which命令"></a>which命令</h2><h2 id="1-作用：-9"><a href="#1-作用：-9" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="查看命令的程序文件存放位置"><a href="#查看命令的程序文件存放位置" class="headerlink" title="查看命令的程序文件存放位置"></a>查看命令的程序文件存放位置</h3><h2 id="2-格式：-7"><a href="#2-格式：-7" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="which-要查找的命令"><a href="#which-要查找的命令" class="headerlink" title="which 要查找的命令"></a>which 要查找的命令</h3><ul><li><strong>which cd</strong></li><li>which pwd</li></ul><hr><h2 id="find命令"><a href="#find命令" class="headerlink" title="find命令"></a>find命令</h2><h2 id="1-作用：-10"><a href="#1-作用：-10" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="搜索指定文件"><a href="#搜索指定文件" class="headerlink" title="搜索指定文件"></a>搜索指定文件</h3><h2 id="2-格式：-8"><a href="#2-格式：-8" class="headerlink" title="2)格式："></a>2)格式：</h2><hr><h3 id="一。按文件名查找文件"><a href="#一。按文件名查找文件" class="headerlink" title="一。按文件名查找文件"></a><strong>一。按文件名查找文件</strong></h3><h3 id="find-起始路径-name-“被查找文件名”"><a href="#find-起始路径-name-“被查找文件名”" class="headerlink" title="find     起始路径    -name     “被查找文件名”"></a>find     起始路径    -name     “被查找文件名”</h3><ul><li><p>为了拥有最大权限，可以切换root</p></li><li><p>可以加通配符*来进行模糊搜索</p></li></ul><hr><h3 id="二。按文件大小查找文件"><a href="#二。按文件大小查找文件" class="headerlink" title="二。按文件大小查找文件"></a>二。按文件大小查找文件</h3><p>find    起始路径    -size    +/-文件大小和单位</p><ul><li>find     /    -size    -10k(查找小于10KB的文件)    </li><li>Ctrl+c可以强制停止</li></ul><h1 id="七。grep-wc和管道符"><a href="#七。grep-wc和管道符" class="headerlink" title="七。grep,wc和管道符"></a>七。grep,wc和管道符</h1><h2 id="grep命令"><a href="#grep命令" class="headerlink" title="grep命令"></a>grep命令</h2><h2 id="1-作用-1"><a href="#1-作用-1" class="headerlink" title="1)作用"></a>1)作用</h2><h3 id="从文件中通过关键字过滤文件行，输出过滤后的内容"><a href="#从文件中通过关键字过滤文件行，输出过滤后的内容" class="headerlink" title="从文件中通过关键字过滤文件行，输出过滤后的内容"></a>从文件中通过关键字过滤文件行，输出过滤后的内容</h3><h2 id="2-格式-2"><a href="#2-格式-2" class="headerlink" title="2)格式"></a>2)格式</h2><h3 id="grep-n-关键字-文件路径"><a href="#grep-n-关键字-文件路径" class="headerlink" title="grep     [-n]    关键字    文件路径"></a>grep     [-n]    关键字    文件路径</h3><ul><li><strong>-n :    在结果中显示匹配的行的行号</strong></li><li>关键字：  表示过滤的关键字，带空格或者其他特殊符号，建议用””包围</li></ul><hr><h2 id="wc命令"><a href="#wc命令" class="headerlink" title="wc命令"></a>wc命令</h2><h2 id="1-作用：-11"><a href="#1-作用：-11" class="headerlink" title="1)作用："></a>1)作用：</h2><h3 id="统计文件的行数、单词数量等"><a href="#统计文件的行数、单词数量等" class="headerlink" title="统计文件的行数、单词数量等"></a>统计文件的行数、单词数量等</h3><h2 id="2-格式：-9"><a href="#2-格式：-9" class="headerlink" title="2)格式："></a>2)格式：</h2><h3 id="wc-c-m-l-w-文件路径"><a href="#wc-c-m-l-w-文件路径" class="headerlink" title="wc    [-c     -m    -l    -w]    文件路径"></a>wc    [-c     -m    -l    -w]    文件路径</h3><ul><li><p>-c    :    统计bytes数量</p></li><li><p>-m  :    统计字符数量</p></li><li><p>-l    :    统计行数</p></li><li><p>-w  :    统计单词数量</p></li><li><p>文件路径不填的情况下可以作为内容输入口</p></li><li><p>不加选项时默认输出 行数、单词数、字节数、文件名</p></li></ul><hr><h2 id="管道符-“-”"><a href="#管道符-“-”" class="headerlink" title="管道符  “|”"></a>管道符  “|”</h2><h2 id="1-作用：-12"><a href="#1-作用：-12" class="headerlink" title="1)作用："></a>1)作用：</h2><p>将管道符|左边的结果，作为右边的输入</p><p>例如</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata">grep it<span class="hljs-keyword">test</span>.txt   == <span class="hljs-keyword">cat</span> <span class="hljs-keyword">test</span>.txt | grep it<br><span class="hljs-keyword">cat</span><span class="hljs-keyword">test</span>.txt | wc -<span class="hljs-keyword">l</span><br></code></pre></td></tr></table></figure><h1 id="八。echo-tail-重定向符的使用"><a href="#八。echo-tail-重定向符的使用" class="headerlink" title="八。echo tail 重定向符的使用"></a>八。echo tail 重定向符的使用</h1><h2 id="echo命令"><a href="#echo命令" class="headerlink" title="echo命令"></a>echo命令</h2><h2 id="1-作用-2"><a href="#1-作用-2" class="headerlink" title="1)作用"></a>1)作用</h2><h3 id="在命令行内输出指定内容"><a href="#在命令行内输出指定内容" class="headerlink" title="在命令行内输出指定内容"></a>在命令行内输出指定内容</h3><h2 id="2-格式-3"><a href="#2-格式-3" class="headerlink" title="2)格式"></a>2)格式</h2><h3 id="echo-输出内容"><a href="#echo-输出内容" class="headerlink" title="echo    输出内容"></a>echo    输出内容</h3><ul><li>无需选项，复杂内容可以用””包围</li></ul><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> hello Linux<br></code></pre></td></tr></table></figure><hr><h2 id="反引号"><a href="#反引号" class="headerlink" title="反引号 ~~"></a>反引号 ~~</h2><h2 id="1-作用-3"><a href="#1-作用-3" class="headerlink" title="1)作用"></a>1)作用</h2><h3 id="被反引号所包围的内容会作为命令执行"><a href="#被反引号所包围的内容会作为命令执行" class="headerlink" title="被反引号所包围的内容会作为命令执行"></a>被反引号所包围的内容会作为命令执行</h3><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> `<span class="hljs-built_in">pwd</span>`<br></code></pre></td></tr></table></figure><p>ta</p><hr><h2 id="重定向符-gt-和-gt-gt"><a href="#重定向符-gt-和-gt-gt" class="headerlink" title="重定向符 &gt; 和&gt;&gt;"></a>重定向符 &gt; 和&gt;&gt;</h2><h2 id="1-作用-4"><a href="#1-作用-4" class="headerlink" title="1)作用"></a>1)作用</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ada">&gt; : 将左侧命令的结果，覆盖写入到符号右侧指定的文件中<br>&gt;&gt; : 将左侧命令的结果，追加写入到右侧指定的文件中<br></code></pre></td></tr></table></figure><hr><h2 id="tail命令"><a href="#tail命令" class="headerlink" title="tail命令"></a>tail命令</h2><h2 id="1-作用-5"><a href="#1-作用-5" class="headerlink" title="1)作用"></a>1)作用</h2><h3 id="查看文件尾部内容，跟踪文件的最新更改"><a href="#查看文件尾部内容，跟踪文件的最新更改" class="headerlink" title="查看文件尾部内容，跟踪文件的最新更改"></a>查看文件尾部内容，跟踪文件的最新更改</h3><h2 id="2-格式-4"><a href="#2-格式-4" class="headerlink" title="2)格式"></a>2)格式</h2><h3 id="tail-f-num-路径"><a href="#tail-f-num-路径" class="headerlink" title="tail     [-f     -num]    路径"></a>tail     [-f     -num]    路径</h3><ul><li>-f :    表示持续跟踪</li><li>-num :   表示查看尾部多少行，默认为10行(num为具体数字)</li></ul><p>例子</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">tail</span> -20 test.txt(查看末尾20行)<br><span class="hljs-built_in">tail</span> -f test.txt(当向文件内增加文件时，可以实时输出尾部内容)<br>退出按Ctrl+C<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTML学习</title>
    <link href="/2023/03/10/HTML%E5%AD%A6%E4%B9%A0/"/>
    <url>/2023/03/10/HTML%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="HTML学习"><a href="#HTML学习" class="headerlink" title="HTML学习"></a>HTML学习</h1><h2 id="一、HTML页面固定结构-编写规范"><a href="#一、HTML页面固定结构-编写规范" class="headerlink" title="一、HTML页面固定结构(编写规范)"></a>一、HTML页面固定结构(编写规范)</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        网页主体内容<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="VSCODE使用技巧"><a href="#VSCODE使用技巧" class="headerlink" title="VSCODE使用技巧"></a>VSCODE使用技巧</h3><h3 id="1、一键部署结构"><a href="#1、一键部署结构" class="headerlink" title="1、一键部署结构"></a>1、一键部署结构</h3><p>方法：1.新建html文件后输入<strong>“！”</strong></p><p>​            2.<strong>html:5</strong></p><h3 id="2、注释"><a href="#2、注释" class="headerlink" title="2、注释"></a>2、注释</h3><p>快捷键：Ctrl+/</p><h3 id="3、一行向下复制"><a href="#3、一行向下复制" class="headerlink" title="3、一行向下复制"></a>3、一行向下复制</h3><p>方法：点击一行Ctrl c、Ctrl v</p><h3 id="4、同时选中多个相同元素"><a href="#4、同时选中多个相同元素" class="headerlink" title="4、同时选中多个相同元素"></a>4、同时选中多个相同元素</h3><p>方法:选择一个元素后，Ctrl+D</p><h1 id="二、HTML标签学习"><a href="#二、HTML标签学习" class="headerlink" title="二、HTML标签学习"></a><strong>二、HTML标签学习</strong></h1><h1 id="1-排版标签"><a href="#1-排版标签" class="headerlink" title="1.排版标签"></a>1.排版标签</h1><h3 id="1-1、分类"><a href="#1-1、分类" class="headerlink" title="1.1、分类"></a>1.1、分类</h3><ul><li><p><strong>双标签：有开始结束标签包裹中间部分内容</strong></p><p>如：<strong></strong></p></li><li><p>单标签：自成一体，无法包裹内容</p><p>如： 换行<br></p><p>​         插入水平线<hr></p></li></ul><h3 id="1-2、标签间关系"><a href="#1-2、标签间关系" class="headerlink" title="1.2、标签间关系"></a>1.2、标签间关系</h3><ul><li><p>父子关系（嵌套关系）</p><head>    <title></title></head></li><li><p>兄弟关系（并列关系）</p><head></head><body></body></li></ul><h3 id="1-3、标题标签"><a href="#1-3、标题标签" class="headerlink" title="1.3、标题标签"></a>1.3、标题标签</h3><p>代码：h系列标签（重要程度依次递减）</p><p>1级标签：<h1>  </h1></p><p>2级标签：<h2>  </h2></p><p><strong>一共六级</strong></p><p>特点：1.同markdown语法不同级别标签（字体大小）</p><p>​            2.标题单独占一行</p><h3 id="1-4、段落标签"><a href="#1-4、段落标签" class="headerlink" title="1.4、段落标签"></a>1.4、段落标签</h3><p>代码：<p>  </p></p><p>特点：两段中间有间隔</p><hr><h1 id="2-文本格式化标签"><a href="#2-文本格式化标签" class="headerlink" title="2.文本格式化标签"></a>2.文本格式化标签</h1><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/dv03ck.png"></p><p><del>删除线</del>   <u>下划线</u></p><p><b>加粗</b>  <i>倾斜</i></p><p><strong>用strong、ins、em、del表示强调语义更强烈（最终呈现效果为相同）</strong></p><hr><h1 id="3-媒体标签"><a href="#3-媒体标签" class="headerlink" title="3.媒体标签"></a><strong>3.媒体标签</strong></h1><h2 id="3-1图片标签"><a href="#3-1图片标签" class="headerlink" title="3.1图片标签"></a>3.1图片标签</h2><p>代码： <img src="" alt=""></p><p>标签属性：</p><ol><li><h4 id="src-路径"><a href="#src-路径" class="headerlink" title="src(路径)"></a>src(路径)</h4><ul><li>绝对路径：目录下的绝对位置，可直接到达目标位置，通常从盘符开始(或者是网址)</li><li>相对路径(常用):从当前文件开始出发找目标文件<ul><li>同级目录: 直接写图片名字或者./图片名</li><li>下级目录：文件夹名/图片名</li><li>上级目录：返回到上一级目录  ../</li></ul></li></ul></li><li><p>alt(替换文本)</p><ul><li>当图片加载不成功时，显示alt的文本</li></ul></li><li><p>height width(设置图片大小)</p><ul><li>如果只设置其中一个，会自动等比例缩放</li></ul></li><li><p>title(提示文本)</p><ul><li>当鼠标悬停时，才显示的文本</li><li>title属性不仅仅可以用于图片标签，还可以用于其他标签</li></ul></li></ol><p>属性注意点：</p><p>1.标签上可以同时存在多个属性</p><p>2.属性之间用空格隔开</p><p>3.属性之间没有顺序之分</p><h2 id="3-2-音频标签"><a href="#3-2-音频标签" class="headerlink" title="3.2.音频标签"></a>3.2.音频标签</h2><p>代码: <audio src="" controls></audio></p><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/760lpr.png"></p><h2 id="3-3-视频标签"><a href="#3-3-视频标签" class="headerlink" title="3.3.视频标签"></a>3.3.视频标签</h2><p>代码：<video src=""></video></p><p>其他与音频完全相同</p><h2 id="3-4链接标签"><a href="#3-4链接标签" class="headerlink" title="3.4链接标签"></a>3.4链接标签</h2><p>代码：<a href=""></a></p><p>href中写跳转地址</p><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://www.bilibili.com/&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><p>当不知道跳转位置时，可以用空链接，即href中写#</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;#&quot;</span>&gt;</span>跳转<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="target属性-修改目标网页打开形式"><a href="#target属性-修改目标网页打开形式" class="headerlink" title="target属性(修改目标网页打开形式)"></a>target属性(修改目标网页打开形式)</h3><ul><li>target=”_self”(默认值)：在当前窗口中跳转</li><li>target=”_blank”:在新窗口中跳转</li></ul><h1 id="三、基础"><a href="#三、基础" class="headerlink" title="三、基础"></a>三、基础</h1><h1 id="1-列表"><a href="#1-列表" class="headerlink" title="1.列表"></a>1.列表</h1><h2 id="1-1应用场景"><a href="#1-1应用场景" class="headerlink" title="1.1应用场景"></a>1.1应用场景</h2><p>列表的三种类型</p><ul><li>无序列表</li><li>有序列表</li><li>自定义列表</li></ul><p>应用在需要按行的方式，整齐显示内容部分</p><h2 id="1-2无序-有序列表"><a href="#1-2无序-有序列表" class="headerlink" title="1.2无序/有序列表"></a>1.2无序/有序列表</h2><h3 id="标签组成"><a href="#标签组成" class="headerlink" title="标签组成"></a>标签组成</h3><p>​    ul            表示无序列表的整体，用于包裹li标签</p><p>​    li             表示无序列表的每一项，用于包含每一行的内容</p><p>​    ol            表示有序列表的每一项</p><p>ul与li,ol与li两者关系为父子关系(嵌套关系)</p><h3 id="显示特点"><a href="#显示特点" class="headerlink" title="显示特点"></a>显示特点</h3><p>​    无序列表的每一项前默认有圆点标识   </p><ul><li></li></ul><p>​    有序列表的每一项前有排序的序号</p><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><ul><li>ul标签只允许包含li标签</li><li>li标签可以包含任意内容</li></ul><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>​    <strong>无序</strong></p><ul>    <li><b>香蕉</b></li>    <li><u>苹果</u></li></ul><p>​    <strong>有序</strong></p><ol>    <li>香蕉</li>    <li>苹果</li></ol><h2 id="1-3自定义列表"><a href="#1-3自定义列表" class="headerlink" title="1.3自定义列表"></a>1.3自定义列表</h2><h3 id="标签组成-1"><a href="#标签组成-1" class="headerlink" title="标签组成"></a>标签组成</h3><p>​        dl            表示自定义列表的整体，用于包裹dt/dd标签</p><p>​        dt            表示自定义列表的主题</p><p>​        dd            表示自定义列表的针对主题的每一项内容</p><h3 id="显示特点-1"><a href="#显示特点-1" class="headerlink" title="显示特点"></a>显示特点</h3><ul><li>dd前会默认显示缩进效果</li></ul><h3 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a>注意点</h3><ul><li>dl标签中只允许包含dt/dd标签</li><li>dt/dl标签可以包含任意内容</li></ul><h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><dl>    <dt>帮助中心</dt>    <dd>个人中心</dd>    <dd>订单中心</dd></dl><h1 id="2-表格"><a href="#2-表格" class="headerlink" title="2.表格"></a>2.表格</h1><h2 id="2-1应用场景"><a href="#2-1应用场景" class="headerlink" title="2.1应用场景"></a>2.1应用场景</h2><p>在网页中以行+列的单元格的方式争气展示</p><h2 id="2-2基本标签"><a href="#2-2基本标签" class="headerlink" title="2.2基本标签"></a>2.2基本标签</h2><p>​    table            表格整体，用于包裹多个tr</p><p>​    tr                 表格每行，用于包裹td</p><p>​    td                 表格单元格，用于包裹内容</p><h3 id="注意点-2"><a href="#注意点-2" class="headerlink" title="注意点"></a>注意点</h3><ul><li>嵌套关系：table&gt;tr&gt;td</li></ul><table>    <tr>        <td>姓名</td>        <td>成绩</td>    </tr>    <tr>        <td>小明</td>        <td>100</td>    </tr></table><h2 id="2-3相关属性-在table中加"><a href="#2-3相关属性-在table中加" class="headerlink" title="2.3相关属性(在table中加)"></a>2.3相关属性(在table中加)</h2><p>​    </p><table><thead><tr><th>属性名</th><th>属性值</th><th>效果</th></tr></thead><tbody><tr><td>border</td><td>数字</td><td>边框宽度</td></tr><tr><td>width</td><td>数字</td><td>表格宽度</td></tr><tr><td>height</td><td>数字</td><td>表格高度</td></tr></tbody></table><h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a><strong>例子</strong></h3><table border="1">    <tr>        <td>姓名</td>        <td>成绩</td>    </tr>    <tr>        <td>小明</td>        <td>100</td>    </tr></table><h3 id="注意点："><a href="#注意点：" class="headerlink" title="注意点："></a><strong>注意点：</strong></h3><p><strong>实际开发中用CSS设置</strong></p><h2 id="2-4表格标题和表头单元格标签"><a href="#2-4表格标题和表头单元格标签" class="headerlink" title="2.4表格标题和表头单元格标签"></a>2.4表格标题和表头单元格标签</h2><h3 id="结构标签"><a href="#结构标签" class="headerlink" title="结构标签"></a>结构标签</h3><table border="1">    <tr>        <td>标签名</td>        <td>名称</td>        <td>说明</td>    </tr>    <tr>        <td>caption</td>        <td>表格大标题</td>        <td>表示表格整体大标题，默认在表格顶部居中显示</td>    </tr>    <tr>        <td>th</td>        <td>表头单元格</td>        <td>表示一列小标题，通常用于表格第一行，默认内部文字加粗居中显示</td>    </tr></table><h3 id="注意点-3"><a href="#注意点-3" class="headerlink" title="注意点"></a>注意点</h3><ul><li>caption标签书写在table标签内部</li><li>th标签书写在tr标签内部(用于替换td标签)</li></ul><h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><table border="1" >    <caption><b>成绩单</b></caption>    <tr>        <th>姓名</th>        <th>成绩</th>    </tr>    <tr>        <td>熊猫</td>        <td>100</td>    </tr></table><h2 id="2-5表格结构标签"><a href="#2-5表格结构标签" class="headerlink" title="2.5表格结构标签"></a>2.5表格结构标签</h2><h3 id="结构标签-1"><a href="#结构标签-1" class="headerlink" title="结构标签"></a>结构标签</h3><table>    <tr>        <th>标签名</th>        <th>名称</th>    </tr>    <tr>        <td>thead</td>          <td>表格头部</td>         </tr>    <tr>        <td>tbody</td>        <td>表格主体</td>    </tr>    <tr>        <td>tfoot</td>        <td>表格底部</td>    </tr></table><h3 id="注意点-4"><a href="#注意点-4" class="headerlink" title="注意点"></a>注意点</h3><ul><li>表格结构标签内部用于包裹tr标签</li><li>表格结构标签可以省略</li><li>主要用于增加代码可读性，提高执行效率</li></ul><h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><table border="1" >    <caption><b>成绩单</b></caption>    <thead>        <tr>            <th>姓名</th>            <th>成绩</th>        </tr>    </thead>    <tbody>        <tr>            <td>熊猫</td>            <td>100</td>        </tr>    </tbody></table><h2 id="2-6合并单元格"><a href="#2-6合并单元格" class="headerlink" title="2.6合并单元格"></a>2.6合并单元格</h2><h3 id="应用场景："><a href="#应用场景：" class="headerlink" title="应用场景："></a>应用场景：</h3><p>跨行合并(垂直合并)、跨列合并(水平合并)</p><h3 id="结构标签-2"><a href="#结构标签-2" class="headerlink" title="结构标签"></a>结构标签</h3><table><thead><tr><th>属性名</th><th>属性值</th><th>说明</th></tr></thead><tbody><tr><td>rowspan</td><td>合并单元格的个数</td><td>跨行合并(上下)</td></tr><tr><td>colspan</td><td>合并单元格的个数</td><td>跨列合并(左右)</td></tr></tbody></table><h3 id="合并原则（左上原则）"><a href="#合并原则（左上原则）" class="headerlink" title="合并原则（左上原则）"></a>合并原则（<strong>左上原则</strong>）</h3><ul><li>上下合并—-&gt;只保留最上的，删除其他</li><li>左右合并—-&gt;只保留最左的</li></ul><h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><table border="1" >    <caption><b>成绩单</b></caption>    <thead>        <tr>            <th>姓名</th>            <th>成绩</th>        </tr>    </thead>    <tbody>        <tr>            <td>熊猫</td>            <td rowspan="2">100</td>        </tr>         <tr>            <td>小明</td>        </tr>    </tbody></table><h3 id="注意点-5"><a href="#注意点-5" class="headerlink" title="注意点"></a>注意点</h3><ul><li>只有在同一个结构标签中的单元格才能合并(并不能跨thead,tbody,tfoot)</li></ul><h1 id="3-表单"><a href="#3-表单" class="headerlink" title="3.表单"></a>3.表单</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><p>登陆，注册，搜索等等需要输入场景(标签比较多，但是使用频率比较低)</p><h2 id="3-1-input系列标签"><a href="#3-1-input系列标签" class="headerlink" title="3.1  input系列标签"></a>3.1  input系列标签</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/okks51.png"></p><ul><li>根据type属性值不同，展示不同效果</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html">账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>   密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>   身份：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>学生 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>老师<br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>   上传文件：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/3t6r81.png"  /><h3 id="占位符标签-提示文本"><a href="#占位符标签-提示文本" class="headerlink" title="占位符标签(提示文本)"></a>占位符标签(提示文本)</h3><p>​    <strong>type属性值:text</strong></p><p>​    <strong>标签：placeholder(占位，提示用户输入内容的文本)</strong></p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html">账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入用户名&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">placeholder</span>=<span class="hljs-string">&quot;请输入密码&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/5fzilv.png"></p><h3 id="单选功能和默认选中"><a href="#单选功能和默认选中" class="headerlink" title="单选功能和默认选中"></a>单选功能和默认选中</h3><p>type属性值： radio</p><p>标签属性</p><table border="1">    <tr>        <td>属性名</td>         <td>说明</td>    </tr>    <tr>        <td>name</td>        <td>分组，有相同name属性的单选框为一组,一组中只能选一个</td>    </tr>    <tr>        <td>check</td>        <td>默认选中</td>    </tr></table><p>例子</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs html">身份：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;身份&quot;</span> <span class="hljs-attr">checked</span>&gt;</span>学生  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;身份&quot;</span>&gt;</span>老师<br><br></code></pre></td></tr></table></figure><h3 id="1-上传多个文件"><a href="#1-上传多个文件" class="headerlink" title="1.上传多个文件"></a>1.上传多个文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;file&quot;</span><span class="hljs-attr">multiple</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-按钮"><a href="#2-按钮" class="headerlink" title="2.按钮"></a>2.按钮</h3><h3 id="标签-1"><a href="#标签-1" class="headerlink" title="标签"></a>标签</h3><table><thead><tr><th>标签名</th><th>type属性值</th><th>说明</th></tr></thead><tbody><tr><td>input</td><td>submit</td><td>提交数据给后端服务器</td></tr><tr><td>input</td><td>reset</td><td>重置</td></tr><tr><td>input</td><td>button</td><td>默认无功能，可配合js添加功能</td></tr></tbody></table><ul><li><p>表单用form包裹形成一个整体表单域，才能正常使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>(action为提交地址)<br></code></pre></td></tr></table></figure></li></ul><h3 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span>&gt;</span><br>      账号：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      密码：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;password&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      身份：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>学生 <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span>&gt;</span>老师<br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;登陆&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;重置&quot;</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-2-button按钮标签-类似于input中按钮"><a href="#3-2-button按钮标签-类似于input中按钮" class="headerlink" title="3.2 button按钮标签(类似于input中按钮)"></a>3.2 button按钮标签(类似于input中按钮)</h2><h2 id="标签-2"><a href="#标签-2" class="headerlink" title="标签"></a>标签</h2><table border="2">    <tr>        <th>标签名</th>        <th>type属性值</th>        <th>说明</th>    </tr>    <tr>        <td>button</td>        <td>submit</td>        <td>提交</td>    </tr>    <tr>        <td>button</td>        <td>reset</td>        <td>重置</td>    </tr>    <tr>        <td>button</td>        <td>button</td>        <td>默认无功能，可配合js实现功能</td>    </tr></table><h3 id="注意点-6"><a href="#注意点-6" class="headerlink" title="注意点"></a>注意点</h3><ul><li>谷歌浏览器中button默认是提交按钮</li><li>button是双标签，更便于包裹其他内容(文字，图片)</li></ul><h3 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">tyoe</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    提交<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;reset&quot;</span>&gt;</span><br>    重置<br><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="3-3下拉菜单"><a href="#3-3下拉菜单" class="headerlink" title="3.3下拉菜单"></a>3.3下拉菜单</h2><h3 id="标签-3"><a href="#标签-3" class="headerlink" title="标签"></a>标签</h3><ul><li>select标签： 下拉菜单的整体</li><li>option标签： 下拉菜单的每一项<ul><li>两者为父子嵌套关系</li></ul></li></ul><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><ul><li>selected: 下拉菜单的默认选中</li></ul><h3 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">select</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>北京<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>上海<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>深圳<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">option</span>&gt;</span>广州<span class="hljs-tag">&lt;/<span class="hljs-name">option</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/76of3b.png"></p><h2 id="3-4文本域"><a href="#3-4文本域" class="headerlink" title="3.4文本域"></a>3.4文本域</h2><h3 id="应用场景：-1"><a href="#应用场景：-1" class="headerlink" title="应用场景："></a>应用场景：</h3><p>​    在网页中提供可输入多行文本的表单控件</p><h3 id="标签名："><a href="#标签名：" class="headerlink" title="标签名："></a>标签名：</h3><p>​    <strong>textarea</strong>(双标签)</p><h3 id="常见属性："><a href="#常见属性：" class="headerlink" title="常见属性："></a>常见属性：</h3><ul><li><strong>cols: 规定了文本域内可见宽度</strong></li><li><strong>rows: 规定了文本域内可见行数</strong></li></ul><h3 id="注意点：-1"><a href="#注意点：-1" class="headerlink" title="注意点："></a>注意点：</h3><ul><li>右下角可以拖拽改变大小</li><li>实际开发中针对样式效果用CSS,不用cols,rows设置</li></ul><h3 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">textarea</span> <span class="hljs-attr">cols</span>=<span class="hljs-string">&quot;30&quot;</span> <span class="hljs-attr">rows</span>=<span class="hljs-string">&quot;10&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">textarea</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/zqkl22.png"></p><h2 id="3-5-label标签"><a href="#3-5-label标签" class="headerlink" title="3.5 label标签"></a>3.5 label标签</h2><h3 id="场景："><a href="#场景：" class="headerlink" title="场景："></a>场景：</h3><p>​    用于绑定内容与表单标签的关系(点内容也可以选择)</p><h3 id="标签名：-1"><a href="#标签名：-1" class="headerlink" title="标签名："></a>标签名：</h3><p>​    <strong>label</strong> <strong>(双标签)</strong></p><h3 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h3><p>​    一。</p><ul><li>用label标签把内容(文本，图片)包裹</li><li>在表单标签上添加id属性</li><li>在label标签的for属性中设置对应的id属性</li></ul><p>​    二。</p><ul><li>用lable标签把整个内容和表单标签一起包裹</li><li>把label标签中的for属性删去</li></ul><h3 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;nan&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">label</span> <span class="hljs-attr">for</span>=<span class="hljs-string">&quot;nan&quot;</span>&gt;</span>男<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;radio&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;sex&quot;</span>&gt;</span>女<span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>​    第二种使用更加简单，但是第一种更加灵活多变</p><h2 id="3-6语义化标签"><a href="#3-6语义化标签" class="headerlink" title="3.6语义化标签"></a>3.6语义化标签</h2><h3 id="一。没有语义的布局标签-div和span"><a href="#一。没有语义的布局标签-div和span" class="headerlink" title="一。没有语义的布局标签(div和span)"></a>一。没有语义的布局标签(<strong>div和span</strong>)</h3><ul><li><p>双标签</p><ul><li><p><strong>div标签：一行只显示一个</strong></p></li><li><p><strong>span标签：一行可以显示多个</strong></p></li></ul></li></ul><h4 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>div2<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>span2<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/098fa5.png"></p><h3 id="二。有语义的布局标签-手机网页布局"><a href="#二。有语义的布局标签-手机网页布局" class="headerlink" title="二。有语义的布局标签(手机网页布局)"></a>二。有语义的布局标签(手机网页布局)</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/p5ux2b.png"></p><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul><li>都为双标签</li><li>以上标签显示特点与div一致，一行只显示一个，但比div多了不同语义</li></ul><h2 id="3-7字符实体"><a href="#3-7字符实体" class="headerlink" title="3.7字符实体"></a>3.7字符实体</h2><h3 id="场景：-1"><a href="#场景：-1" class="headerlink" title="场景："></a>场景：</h3><p>​    在网页中展示特殊傅好效果时，需要用字符实体替代</p><h3 id="常见字符实体："><a href="#常见字符实体：" class="headerlink" title="常见字符实体："></a>常见字符实体：</h3><p><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/79y0y9.png"></p><h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3><ul><li>网页只能识别一个空格，内容中打多个空格只会识别到一个</li></ul><h3 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h3><p>字&nbsp;&nbsp;&nbsp;&nbsp;符实体案例</p>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vi(vim)编辑器</title>
    <link href="/2023/03/10/vi(vim)%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <url>/2023/03/10/vi(vim)%E7%BC%96%E8%BE%91%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="vi编辑器"><a href="#vi编辑器" class="headerlink" title="vi编辑器"></a>vi编辑器</h1><p>vi/vim是Linux最经典的文本编辑器，vim是vi的加强版，兼容vi的所有指令，不仅能编辑文本，还具有shell程序编辑功能，可以不同颜色的字体辨别语法的正确性</p><h1 id="三种工作模式"><a href="#三种工作模式" class="headerlink" title="三种工作模式"></a>三种工作模式</h1><h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>​    命令模式下，所有敲下的按键编辑器都会理解成命令，执行不同功能</p><p>​    进入命令模式    vim 文件路径</p><ul><li>如果文件路径中文件不存在，命令会用于编辑新文件</li><li>如果文件路径中文件存在，命令会编辑已有文件</li></ul><h3 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h3><ul><li>/  : 进入搜索模式<ul><li>n ：向下继续搜索</li><li>N :   向下继续搜索</li></ul></li><li> dd:   删除光标所在行</li><li> ndd : 删除n行</li><li> nyy:  复制n行</li><li> p:  粘贴</li><li> u：撤回</li><li> gg：跳到首行</li><li> G:  跳到行尾</li></ul><hr><h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>​    文本内容自由编辑</p><hr><h2 id="底线模式"><a href="#底线模式" class="headerlink" title="底线模式"></a>底线模式</h2><p>​    保存退出文件</p><ul><li>:wq :保存并退出</li><li>:q :  退出</li><li>:q! :  强制退出</li><li>:w :  保存</li><li>:set nu :  显示行号</li><li>:set paste : 设置粘贴模式</li></ul><p><a href="https://imgse.com/i/pSxLhHe"><img src="https://typoranote-picture.oss-cn-guangzhou.aliyuncs.com/typora%E5%9B%BE%E7%89%87/pSxLhHe.png" alt="pSxLhHe.png"></a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/10/hello-world/"/>
    <url>/2023/03/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
